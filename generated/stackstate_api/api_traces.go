/*
StackState API

This API documentation page describes the StackState server API. The StackState UI and CLI use the StackState server API to configure and query StackState.  You can use the API for similar purposes.  Each request sent to the StackState server API must be authenticated using one of the available authentication methods.   *Note that the StackState receiver API, used to send topology, telemetry and traces to StackState, is not described on this page and requires a different authentication method.*  For more information on StackState, refer to the [StackState documentation](https://docs.stackstate.com).

API version: 5.2.0
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackstate_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

type TracesApi interface {

	/*
		GetSpan Get a span

		Get a single span for a trace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param traceId The id of the trace
		@param spanId The id of the span
		@return ApiGetSpanRequest
	*/
	GetSpan(ctx context.Context, traceId string, spanId string) ApiGetSpanRequest

	// GetSpanExecute executes the request
	//  @return Span
	GetSpanExecute(r ApiGetSpanRequest) (*Span, *http.Response, error)

	/*
		GetTrace Fetch a trace

		Get a full trace by id only

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param traceId The id of the trace
		@return ApiGetTraceRequest
	*/
	GetTrace(ctx context.Context, traceId string) ApiGetTraceRequest

	// GetTraceExecute executes the request
	//  @return Trace
	GetTraceExecute(r ApiGetTraceRequest) (*Trace, *http.Response, error)

	/*
		QueryDuration Query duration distribution

		Query for durations using filters.  Filters that accept an array of values match if any of the values match (think of a SQL IN expression).

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiQueryDurationRequest
	*/
	QueryDuration(ctx context.Context) ApiQueryDurationRequest

	// QueryDurationExecute executes the request
	//  @return DurationHistogram
	QueryDurationExecute(r ApiQueryDurationRequest) (*DurationHistogram, *http.Response, error)

	/*
		QueryTraces Query for traces

		Query for traces using filters. Filters that accept an array of values match if any of the values match (think of a SQL IN expression).

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiQueryTracesRequest
	*/
	QueryTraces(ctx context.Context) ApiQueryTracesRequest

	// QueryTracesExecute executes the request
	//  @return Traces
	QueryTracesExecute(r ApiQueryTracesRequest) (*Traces, *http.Response, error)

	/*
		SpanComponents Fetch components based on resource attributes

		Based on the resource attributes on a span, retrieve components that have a TraceBinding for it.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiSpanComponentsRequest
	*/
	SpanComponents(ctx context.Context) ApiSpanComponentsRequest

	// SpanComponentsExecute executes the request
	//  @return SpanComponents
	SpanComponentsExecute(r ApiSpanComponentsRequest) (*SpanComponents, *http.Response, error)

	/*
		SuggestionsAttributeName Suggestions for attribute names

		Suggestions for attribute names, both resource and span attributes. Attributes match when their name contains the provided part, at most 100 suggestions will be returned. Make the part longer to get more accurate suggestions.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiSuggestionsAttributeNameRequest
	*/
	SuggestionsAttributeName(ctx context.Context) ApiSuggestionsAttributeNameRequest

	// SuggestionsAttributeNameExecute executes the request
	//  @return Suggestions
	SuggestionsAttributeNameExecute(r ApiSuggestionsAttributeNameRequest) (*Suggestions, *http.Response, error)

	/*
		SuggestionsAttributeValue Suggestions for attribute values

		Suggestions for attribute values, both resource and span attributes. Attribute values match when the value contains the provided part, at most 100 suggestions will be returned. Make the part longer to get more accurate suggestions.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param attributeName Get suggestions for this attribute
		@return ApiSuggestionsAttributeValueRequest
	*/
	SuggestionsAttributeValue(ctx context.Context, attributeName string) ApiSuggestionsAttributeValueRequest

	// SuggestionsAttributeValueExecute executes the request
	//  @return Suggestions
	SuggestionsAttributeValueExecute(r ApiSuggestionsAttributeValueRequest) (*Suggestions, *http.Response, error)

	/*
		SuggestionsFieldValues Suggestions for span fields

		Suggestions for values of of the span fields that can be filtered on except resource and span attributes. Values match when they contain the provided part, at most 100 suggestions will be returned. Make the part longer to get more accurate suggestions.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param field Get suggestions for this field
		@return ApiSuggestionsFieldValuesRequest
	*/
	SuggestionsFieldValues(ctx context.Context, field SpanSuggestionField) ApiSuggestionsFieldValuesRequest

	// SuggestionsFieldValuesExecute executes the request
	//  @return Suggestions
	SuggestionsFieldValuesExecute(r ApiSuggestionsFieldValuesRequest) (*Suggestions, *http.Response, error)
}

// TracesApiService TracesApi service
type TracesApiService service

type ApiGetSpanRequest struct {
	ctx        context.Context
	ApiService TracesApi
	traceId    string
	spanId     string
}

func (r ApiGetSpanRequest) Execute() (*Span, *http.Response, error) {
	return r.ApiService.GetSpanExecute(r)
}

/*
GetSpan Get a span

Get a single span for a trace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param traceId The id of the trace
 @param spanId The id of the span
 @return ApiGetSpanRequest
*/
func (a *TracesApiService) GetSpan(ctx context.Context, traceId string, spanId string) ApiGetSpanRequest {
	return ApiGetSpanRequest{
		ApiService: a,
		ctx:        ctx,
		traceId:    traceId,
		spanId:     spanId,
	}
}

// Execute executes the request
//  @return Span
func (a *TracesApiService) GetSpanExecute(r ApiGetSpanRequest) (*Span, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Span
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracesApiService.GetSpan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traces/{traceId}/spans/{spanId}"
	localVarPath = strings.Replace(localVarPath, "{"+"traceId"+"}", url.PathEscape(parameterToString(r.traceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spanId"+"}", url.PathEscape(parameterToString(r.spanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v TraceApiSpanNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TraceApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTraceRequest struct {
	ctx        context.Context
	ApiService TracesApi
	traceId    string
}

func (r ApiGetTraceRequest) Execute() (*Trace, *http.Response, error) {
	return r.ApiService.GetTraceExecute(r)
}

/*
GetTrace Fetch a trace

Get a full trace by id only

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param traceId The id of the trace
 @return ApiGetTraceRequest
*/
func (a *TracesApiService) GetTrace(ctx context.Context, traceId string) ApiGetTraceRequest {
	return ApiGetTraceRequest{
		ApiService: a,
		ctx:        ctx,
		traceId:    traceId,
	}
}

// Execute executes the request
//  @return Trace
func (a *TracesApiService) GetTraceExecute(r ApiGetTraceRequest) (*Trace, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Trace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracesApiService.GetTrace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traces/{traceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"traceId"+"}", url.PathEscape(parameterToString(r.traceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v TraceApiTraceNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TraceApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryDurationRequest struct {
	ctx          context.Context
	ApiService   TracesApi
	start        *int32
	end          *int32
	bucketsCount *int32
	traceFilter  *TraceFilter
}

// Filter spans by start time &gt;&#x3D; value
func (r ApiQueryDurationRequest) Start(start int32) ApiQueryDurationRequest {
	r.start = &start
	return r
}

// Filter spans by start time &lt; value
func (r ApiQueryDurationRequest) End(end int32) ApiQueryDurationRequest {
	r.end = &end
	return r
}

// The number of histogram buckets.
func (r ApiQueryDurationRequest) BucketsCount(bucketsCount int32) ApiQueryDurationRequest {
	r.bucketsCount = &bucketsCount
	return r
}

// Filter for traces
func (r ApiQueryDurationRequest) TraceFilter(traceFilter TraceFilter) ApiQueryDurationRequest {
	r.traceFilter = &traceFilter
	return r
}

func (r ApiQueryDurationRequest) Execute() (*DurationHistogram, *http.Response, error) {
	return r.ApiService.QueryDurationExecute(r)
}

/*
QueryDuration Query duration distribution

Query for durations using filters.  Filters that accept an array of values match if any of the values match (think of a SQL IN expression).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryDurationRequest
*/
func (a *TracesApiService) QueryDuration(ctx context.Context) ApiQueryDurationRequest {
	return ApiQueryDurationRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return DurationHistogram
func (a *TracesApiService) QueryDurationExecute(r ApiQueryDurationRequest) (*DurationHistogram, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DurationHistogram
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracesApiService.QueryDuration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traces/duration/histogram"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}
	if r.bucketsCount == nil {
		return localVarReturnValue, nil, reportError("bucketsCount is required and must be specified")
	}
	if r.traceFilter == nil {
		return localVarReturnValue, nil, reportError("traceFilter is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	localVarQueryParams.Add("bucketsCount", parameterToString(*r.bucketsCount, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.traceFilter
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TraceApiSpansBadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TraceApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryTracesRequest struct {
	ctx        context.Context
	ApiService TracesApi
	start      *int32
	end        *int32
	traceQuery *TraceQuery
	pageSize   *int32
	page       *int32
}

// Filter spans by start time &gt;&#x3D; value
func (r ApiQueryTracesRequest) Start(start int32) ApiQueryTracesRequest {
	r.start = &start
	return r
}

// Filter spans by start time &lt; value
func (r ApiQueryTracesRequest) End(end int32) ApiQueryTracesRequest {
	r.end = &end
	return r
}

// Query for traces
func (r ApiQueryTracesRequest) TraceQuery(traceQuery TraceQuery) ApiQueryTracesRequest {
	r.traceQuery = &traceQuery
	return r
}

// Number of spans in 1 page
func (r ApiQueryTracesRequest) PageSize(pageSize int32) ApiQueryTracesRequest {
	r.pageSize = &pageSize
	return r
}

// Get the specified page (with pageSize # of spans), defaults to page 0
func (r ApiQueryTracesRequest) Page(page int32) ApiQueryTracesRequest {
	r.page = &page
	return r
}

func (r ApiQueryTracesRequest) Execute() (*Traces, *http.Response, error) {
	return r.ApiService.QueryTracesExecute(r)
}

/*
QueryTraces Query for traces

Query for traces using filters. Filters that accept an array of values match if any of the values match (think of a SQL IN expression).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiQueryTracesRequest
*/
func (a *TracesApiService) QueryTraces(ctx context.Context) ApiQueryTracesRequest {
	return ApiQueryTracesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Traces
func (a *TracesApiService) QueryTracesExecute(r ApiQueryTracesRequest) (*Traces, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Traces
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracesApiService.QueryTraces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traces/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.end == nil {
		return localVarReturnValue, nil, reportError("end is required and must be specified")
	}
	if r.traceQuery == nil {
		return localVarReturnValue, nil, reportError("traceQuery is required and must be specified")
	}

	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.traceQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TraceApiSpansBadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TraceApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpanComponentsRequest struct {
	ctx            context.Context
	ApiService     TracesApi
	componentQuery *ComponentQuery
}

// Span properties to find matching components
func (r ApiSpanComponentsRequest) ComponentQuery(componentQuery ComponentQuery) ApiSpanComponentsRequest {
	r.componentQuery = &componentQuery
	return r
}

func (r ApiSpanComponentsRequest) Execute() (*SpanComponents, *http.Response, error) {
	return r.ApiService.SpanComponentsExecute(r)
}

/*
SpanComponents Fetch components based on resource attributes

Based on the resource attributes on a span, retrieve components that have a TraceBinding for it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSpanComponentsRequest
*/
func (a *TracesApiService) SpanComponents(ctx context.Context) ApiSpanComponentsRequest {
	return ApiSpanComponentsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return SpanComponents
func (a *TracesApiService) SpanComponentsExecute(r ApiSpanComponentsRequest) (*SpanComponents, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SpanComponents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracesApiService.SpanComponents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traces/components"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.componentQuery == nil {
		return localVarReturnValue, nil, reportError("componentQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.componentQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TraceApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSuggestionsAttributeNameRequest struct {
	ctx        context.Context
	ApiService TracesApi
	contains   *string
}

// Get suggestions based of this partial name
func (r ApiSuggestionsAttributeNameRequest) Contains(contains string) ApiSuggestionsAttributeNameRequest {
	r.contains = &contains
	return r
}

func (r ApiSuggestionsAttributeNameRequest) Execute() (*Suggestions, *http.Response, error) {
	return r.ApiService.SuggestionsAttributeNameExecute(r)
}

/*
SuggestionsAttributeName Suggestions for attribute names

Suggestions for attribute names, both resource and span attributes. Attributes match when their name contains the provided part, at most 100 suggestions will be returned. Make the part longer to get more accurate suggestions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSuggestionsAttributeNameRequest
*/
func (a *TracesApiService) SuggestionsAttributeName(ctx context.Context) ApiSuggestionsAttributeNameRequest {
	return ApiSuggestionsAttributeNameRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Suggestions
func (a *TracesApiService) SuggestionsAttributeNameExecute(r ApiSuggestionsAttributeNameRequest) (*Suggestions, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Suggestions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracesApiService.SuggestionsAttributeName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traces/spans/fields/attributes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contains != nil {
		localVarQueryParams.Add("contains", parameterToString(*r.contains, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TraceApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSuggestionsAttributeValueRequest struct {
	ctx           context.Context
	ApiService    TracesApi
	attributeName string
	contains      *string
}

// Get suggestions based on this partial value
func (r ApiSuggestionsAttributeValueRequest) Contains(contains string) ApiSuggestionsAttributeValueRequest {
	r.contains = &contains
	return r
}

func (r ApiSuggestionsAttributeValueRequest) Execute() (*Suggestions, *http.Response, error) {
	return r.ApiService.SuggestionsAttributeValueExecute(r)
}

/*
SuggestionsAttributeValue Suggestions for attribute values

Suggestions for attribute values, both resource and span attributes. Attribute values match when the value contains the provided part, at most 100 suggestions will be returned. Make the part longer to get more accurate suggestions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attributeName Get suggestions for this attribute
 @return ApiSuggestionsAttributeValueRequest
*/
func (a *TracesApiService) SuggestionsAttributeValue(ctx context.Context, attributeName string) ApiSuggestionsAttributeValueRequest {
	return ApiSuggestionsAttributeValueRequest{
		ApiService:    a,
		ctx:           ctx,
		attributeName: attributeName,
	}
}

// Execute executes the request
//  @return Suggestions
func (a *TracesApiService) SuggestionsAttributeValueExecute(r ApiSuggestionsAttributeValueRequest) (*Suggestions, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Suggestions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracesApiService.SuggestionsAttributeValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traces/spans/fields/attributes/{attributeName}/values"
	localVarPath = strings.Replace(localVarPath, "{"+"attributeName"+"}", url.PathEscape(parameterToString(r.attributeName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contains != nil {
		localVarQueryParams.Add("contains", parameterToString(*r.contains, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TraceApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSuggestionsFieldValuesRequest struct {
	ctx        context.Context
	ApiService TracesApi
	field      SpanSuggestionField
	contains   *string
}

// Get suggestions for this field based on this partial value
func (r ApiSuggestionsFieldValuesRequest) Contains(contains string) ApiSuggestionsFieldValuesRequest {
	r.contains = &contains
	return r
}

func (r ApiSuggestionsFieldValuesRequest) Execute() (*Suggestions, *http.Response, error) {
	return r.ApiService.SuggestionsFieldValuesExecute(r)
}

/*
SuggestionsFieldValues Suggestions for span fields

Suggestions for values of of the span fields that can be filtered on except resource and span attributes. Values match when they contain the provided part, at most 100 suggestions will be returned. Make the part longer to get more accurate suggestions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param field Get suggestions for this field
 @return ApiSuggestionsFieldValuesRequest
*/
func (a *TracesApiService) SuggestionsFieldValues(ctx context.Context, field SpanSuggestionField) ApiSuggestionsFieldValuesRequest {
	return ApiSuggestionsFieldValuesRequest{
		ApiService: a,
		ctx:        ctx,
		field:      field,
	}
}

// Execute executes the request
//  @return Suggestions
func (a *TracesApiService) SuggestionsFieldValuesExecute(r ApiSuggestionsFieldValuesRequest) (*Suggestions, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Suggestions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracesApiService.SuggestionsFieldValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traces/spans/fields/{field}/values"
	localVarPath = strings.Replace(localVarPath, "{"+"field"+"}", url.PathEscape(parameterToString(r.field, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contains != nil {
		localVarQueryParams.Add("contains", parameterToString(*r.contains, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TraceApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ---------------------------------------------
// ------------------ MOCKS --------------------
// ---------------------------------------------

type TracesApiMock struct {
	GetSpanCalls                      *[]GetSpanCall
	GetSpanResponse                   GetSpanMockResponse
	GetTraceCalls                     *[]GetTraceCall
	GetTraceResponse                  GetTraceMockResponse
	QueryDurationCalls                *[]QueryDurationCall
	QueryDurationResponse             QueryDurationMockResponse
	QueryTracesCalls                  *[]QueryTracesCall
	QueryTracesResponse               QueryTracesMockResponse
	SpanComponentsCalls               *[]SpanComponentsCall
	SpanComponentsResponse            SpanComponentsMockResponse
	SuggestionsAttributeNameCalls     *[]SuggestionsAttributeNameCall
	SuggestionsAttributeNameResponse  SuggestionsAttributeNameMockResponse
	SuggestionsAttributeValueCalls    *[]SuggestionsAttributeValueCall
	SuggestionsAttributeValueResponse SuggestionsAttributeValueMockResponse
	SuggestionsFieldValuesCalls       *[]SuggestionsFieldValuesCall
	SuggestionsFieldValuesResponse    SuggestionsFieldValuesMockResponse
}

func NewTracesApiMock() TracesApiMock {
	xGetSpanCalls := make([]GetSpanCall, 0)
	xGetTraceCalls := make([]GetTraceCall, 0)
	xQueryDurationCalls := make([]QueryDurationCall, 0)
	xQueryTracesCalls := make([]QueryTracesCall, 0)
	xSpanComponentsCalls := make([]SpanComponentsCall, 0)
	xSuggestionsAttributeNameCalls := make([]SuggestionsAttributeNameCall, 0)
	xSuggestionsAttributeValueCalls := make([]SuggestionsAttributeValueCall, 0)
	xSuggestionsFieldValuesCalls := make([]SuggestionsFieldValuesCall, 0)
	return TracesApiMock{
		GetSpanCalls:                   &xGetSpanCalls,
		GetTraceCalls:                  &xGetTraceCalls,
		QueryDurationCalls:             &xQueryDurationCalls,
		QueryTracesCalls:               &xQueryTracesCalls,
		SpanComponentsCalls:            &xSpanComponentsCalls,
		SuggestionsAttributeNameCalls:  &xSuggestionsAttributeNameCalls,
		SuggestionsAttributeValueCalls: &xSuggestionsAttributeValueCalls,
		SuggestionsFieldValuesCalls:    &xSuggestionsFieldValuesCalls,
	}
}

type GetSpanMockResponse struct {
	Result   Span
	Response *http.Response
	Error    error
}

type GetSpanCall struct {
	PtraceId string
	PspanId  string
}

func (mock TracesApiMock) GetSpan(ctx context.Context, traceId string, spanId string) ApiGetSpanRequest {
	return ApiGetSpanRequest{
		ApiService: mock,
		ctx:        ctx,
		traceId:    traceId,
		spanId:     spanId,
	}
}

func (mock TracesApiMock) GetSpanExecute(r ApiGetSpanRequest) (*Span, *http.Response, error) {
	p := GetSpanCall{
		PtraceId: r.traceId,
		PspanId:  r.spanId,
	}
	*mock.GetSpanCalls = append(*mock.GetSpanCalls, p)
	return &mock.GetSpanResponse.Result, mock.GetSpanResponse.Response, mock.GetSpanResponse.Error
}

type GetTraceMockResponse struct {
	Result   Trace
	Response *http.Response
	Error    error
}

type GetTraceCall struct {
	PtraceId string
}

func (mock TracesApiMock) GetTrace(ctx context.Context, traceId string) ApiGetTraceRequest {
	return ApiGetTraceRequest{
		ApiService: mock,
		ctx:        ctx,
		traceId:    traceId,
	}
}

func (mock TracesApiMock) GetTraceExecute(r ApiGetTraceRequest) (*Trace, *http.Response, error) {
	p := GetTraceCall{
		PtraceId: r.traceId,
	}
	*mock.GetTraceCalls = append(*mock.GetTraceCalls, p)
	return &mock.GetTraceResponse.Result, mock.GetTraceResponse.Response, mock.GetTraceResponse.Error
}

type QueryDurationMockResponse struct {
	Result   DurationHistogram
	Response *http.Response
	Error    error
}

type QueryDurationCall struct {
	Pstart        *int32
	Pend          *int32
	PbucketsCount *int32
	PtraceFilter  *TraceFilter
}

func (mock TracesApiMock) QueryDuration(ctx context.Context) ApiQueryDurationRequest {
	return ApiQueryDurationRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock TracesApiMock) QueryDurationExecute(r ApiQueryDurationRequest) (*DurationHistogram, *http.Response, error) {
	p := QueryDurationCall{
		Pstart:        r.start,
		Pend:          r.end,
		PbucketsCount: r.bucketsCount,
		PtraceFilter:  r.traceFilter,
	}
	*mock.QueryDurationCalls = append(*mock.QueryDurationCalls, p)
	return &mock.QueryDurationResponse.Result, mock.QueryDurationResponse.Response, mock.QueryDurationResponse.Error
}

type QueryTracesMockResponse struct {
	Result   Traces
	Response *http.Response
	Error    error
}

type QueryTracesCall struct {
	Pstart      *int32
	Pend        *int32
	PtraceQuery *TraceQuery
	PpageSize   *int32
	Ppage       *int32
}

func (mock TracesApiMock) QueryTraces(ctx context.Context) ApiQueryTracesRequest {
	return ApiQueryTracesRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock TracesApiMock) QueryTracesExecute(r ApiQueryTracesRequest) (*Traces, *http.Response, error) {
	p := QueryTracesCall{
		Pstart:      r.start,
		Pend:        r.end,
		PtraceQuery: r.traceQuery,
		PpageSize:   r.pageSize,
		Ppage:       r.page,
	}
	*mock.QueryTracesCalls = append(*mock.QueryTracesCalls, p)
	return &mock.QueryTracesResponse.Result, mock.QueryTracesResponse.Response, mock.QueryTracesResponse.Error
}

type SpanComponentsMockResponse struct {
	Result   SpanComponents
	Response *http.Response
	Error    error
}

type SpanComponentsCall struct {
	PcomponentQuery *ComponentQuery
}

func (mock TracesApiMock) SpanComponents(ctx context.Context) ApiSpanComponentsRequest {
	return ApiSpanComponentsRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock TracesApiMock) SpanComponentsExecute(r ApiSpanComponentsRequest) (*SpanComponents, *http.Response, error) {
	p := SpanComponentsCall{
		PcomponentQuery: r.componentQuery,
	}
	*mock.SpanComponentsCalls = append(*mock.SpanComponentsCalls, p)
	return &mock.SpanComponentsResponse.Result, mock.SpanComponentsResponse.Response, mock.SpanComponentsResponse.Error
}

type SuggestionsAttributeNameMockResponse struct {
	Result   Suggestions
	Response *http.Response
	Error    error
}

type SuggestionsAttributeNameCall struct {
	Pcontains *string
}

func (mock TracesApiMock) SuggestionsAttributeName(ctx context.Context) ApiSuggestionsAttributeNameRequest {
	return ApiSuggestionsAttributeNameRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock TracesApiMock) SuggestionsAttributeNameExecute(r ApiSuggestionsAttributeNameRequest) (*Suggestions, *http.Response, error) {
	p := SuggestionsAttributeNameCall{
		Pcontains: r.contains,
	}
	*mock.SuggestionsAttributeNameCalls = append(*mock.SuggestionsAttributeNameCalls, p)
	return &mock.SuggestionsAttributeNameResponse.Result, mock.SuggestionsAttributeNameResponse.Response, mock.SuggestionsAttributeNameResponse.Error
}

type SuggestionsAttributeValueMockResponse struct {
	Result   Suggestions
	Response *http.Response
	Error    error
}

type SuggestionsAttributeValueCall struct {
	PattributeName string
	Pcontains      *string
}

func (mock TracesApiMock) SuggestionsAttributeValue(ctx context.Context, attributeName string) ApiSuggestionsAttributeValueRequest {
	return ApiSuggestionsAttributeValueRequest{
		ApiService:    mock,
		ctx:           ctx,
		attributeName: attributeName,
	}
}

func (mock TracesApiMock) SuggestionsAttributeValueExecute(r ApiSuggestionsAttributeValueRequest) (*Suggestions, *http.Response, error) {
	p := SuggestionsAttributeValueCall{
		PattributeName: r.attributeName,
		Pcontains:      r.contains,
	}
	*mock.SuggestionsAttributeValueCalls = append(*mock.SuggestionsAttributeValueCalls, p)
	return &mock.SuggestionsAttributeValueResponse.Result, mock.SuggestionsAttributeValueResponse.Response, mock.SuggestionsAttributeValueResponse.Error
}

type SuggestionsFieldValuesMockResponse struct {
	Result   Suggestions
	Response *http.Response
	Error    error
}

type SuggestionsFieldValuesCall struct {
	Pfield    SpanSuggestionField
	Pcontains *string
}

func (mock TracesApiMock) SuggestionsFieldValues(ctx context.Context, field SpanSuggestionField) ApiSuggestionsFieldValuesRequest {
	return ApiSuggestionsFieldValuesRequest{
		ApiService: mock,
		ctx:        ctx,
		field:      field,
	}
}

func (mock TracesApiMock) SuggestionsFieldValuesExecute(r ApiSuggestionsFieldValuesRequest) (*Suggestions, *http.Response, error) {
	p := SuggestionsFieldValuesCall{
		Pfield:    r.field,
		Pcontains: r.contains,
	}
	*mock.SuggestionsFieldValuesCalls = append(*mock.SuggestionsFieldValuesCalls, p)
	return &mock.SuggestionsFieldValuesResponse.Result, mock.SuggestionsFieldValuesResponse.Response, mock.SuggestionsFieldValuesResponse.Error
}
