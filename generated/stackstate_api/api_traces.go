/*
StackState API

This API documentation page describes the StackState server API. The StackState UI and CLI use the StackState server API to configure and query StackState.  You can use the API for similar purposes.  Each request sent to the StackState server API must be authenticated using one of the available authentication methods.   *Note that the StackState receiver API, used to send topology, telemetry and traces to StackState, is not described on this page and requires a different authentication method.*  For more information on StackState, refer to the [StackState documentation](https://docs.stackstate.com).

API version: 5.2.0
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackstate_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

type TracesAPI interface {

	/*
		GetSpan Get a span

		Get a single span for a trace

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param traceId The id of the trace
		@param spanId The id of the span
		@return ApiGetSpanRequest
	*/
	GetSpan(ctx context.Context, traceId string, spanId string) ApiGetSpanRequest

	// GetSpanExecute executes the request
	//  @return Span
	GetSpanExecute(r ApiGetSpanRequest) (*Span, *http.Response, error)

	/*
		GetTrace Fetch a trace

		Get a full trace by id only

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param traceId The id of the trace
		@return ApiGetTraceRequest
	*/
	GetTrace(ctx context.Context, traceId string) ApiGetTraceRequest

	// GetTraceExecute executes the request
	//  @return Trace
	GetTraceExecute(r ApiGetTraceRequest) (*Trace, *http.Response, error)

	/*
		QueryDuration Query duration distribution

		Query for durations using filters.  Filters that accept an array of values match if any of the values match (think of a SQL IN expression).

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiQueryDurationRequest
	*/
	QueryDuration(ctx context.Context) ApiQueryDurationRequest

	// QueryDurationExecute executes the request
	//  @return DurationHistogram
	QueryDurationExecute(r ApiQueryDurationRequest) (*DurationHistogram, *http.Response, error)

	/*
		QuerySpans Query for spans

		Query for spans using filters, get all spans for a trace by trace id. Filters that accept an array of values match if any of the values match (think of a SQL IN expression).

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiQuerySpansRequest
	*/
	QuerySpans(ctx context.Context) ApiQuerySpansRequest

	// QuerySpansExecute executes the request
	//  @return Spans
	QuerySpansExecute(r ApiQuerySpansRequest) (*Spans, *http.Response, error)

	/*
		SpanComponents Fetch components based on resource attributes

		Based on the resource attributes on a span, retrieve components that have a TraceBinding for it.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiSpanComponentsRequest
	*/
	SpanComponents(ctx context.Context) ApiSpanComponentsRequest

	// SpanComponentsExecute executes the request
	//  @return SpanComponents
	SpanComponentsExecute(r ApiSpanComponentsRequest) (*SpanComponents, *http.Response, error)

	/*
		SuggestionsAttributeName Suggestions for attribute names

		Suggestions for attribute names, both resource and span attributes. Attributes match when their name contains the provided part, at most 100 suggestions will be returned. Make the part longer to get more accurate suggestions.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiSuggestionsAttributeNameRequest
	*/
	SuggestionsAttributeName(ctx context.Context) ApiSuggestionsAttributeNameRequest

	// SuggestionsAttributeNameExecute executes the request
	//  @return Suggestions
	SuggestionsAttributeNameExecute(r ApiSuggestionsAttributeNameRequest) (*Suggestions, *http.Response, error)

	/*
		SuggestionsAttributeValue Suggestions for attribute values

		Suggestions for attribute values, both resource and span attributes. Attribute values match when the value contains the provided part, at most 100 suggestions will be returned. Make the part longer to get more accurate suggestions.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param attributeName Get suggestions for this attribute
		@return ApiSuggestionsAttributeValueRequest
	*/
	SuggestionsAttributeValue(ctx context.Context, attributeName string) ApiSuggestionsAttributeValueRequest

	// SuggestionsAttributeValueExecute executes the request
	//  @return Suggestions
	SuggestionsAttributeValueExecute(r ApiSuggestionsAttributeValueRequest) (*Suggestions, *http.Response, error)

	/*
		SuggestionsFieldValues Suggestions for span fields

		Suggestions for values of of the span fields that can be filtered on except resource and span attributes. Values match when they contain the provided part, at most 100 suggestions will be returned. Make the part longer to get more accurate suggestions.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param field Get suggestions for this field
		@return ApiSuggestionsFieldValuesRequest
	*/
	SuggestionsFieldValues(ctx context.Context, field SpanSuggestionField) ApiSuggestionsFieldValuesRequest

	// SuggestionsFieldValuesExecute executes the request
	//  @return Suggestions
	SuggestionsFieldValuesExecute(r ApiSuggestionsFieldValuesRequest) (*Suggestions, *http.Response, error)
}

// TracesAPIService TracesAPI service
type TracesAPIService service

type ApiGetSpanRequest struct {
	ctx        context.Context
	ApiService TracesAPI
	traceId    string
	spanId     string
}

func (r ApiGetSpanRequest) Execute() (*Span, *http.Response, error) {
	return r.ApiService.GetSpanExecute(r)
}

/*
GetSpan Get a span

Get a single span for a trace

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param traceId The id of the trace
	@param spanId The id of the span
	@return ApiGetSpanRequest
*/
func (a *TracesAPIService) GetSpan(ctx context.Context, traceId string, spanId string) ApiGetSpanRequest {
	return ApiGetSpanRequest{
		ApiService: a,
		ctx:        ctx,
		traceId:    traceId,
		spanId:     spanId,
	}
}

// Execute executes the request
//
//	@return Span
func (a *TracesAPIService) GetSpanExecute(r ApiGetSpanRequest) (*Span, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Span
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracesAPIService.GetSpan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traces/{traceId}/spans/{spanId}"
	localVarPath = strings.Replace(localVarPath, "{"+"traceId"+"}", url.PathEscape(parameterToString(r.traceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spanId"+"}", url.PathEscape(parameterToString(r.spanId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v TraceApiSpanNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TraceApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTraceRequest struct {
	ctx        context.Context
	ApiService TracesAPI
	traceId    string
}

func (r ApiGetTraceRequest) Execute() (*Trace, *http.Response, error) {
	return r.ApiService.GetTraceExecute(r)
}

/*
GetTrace Fetch a trace

Get a full trace by id only

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param traceId The id of the trace
	@return ApiGetTraceRequest
*/
func (a *TracesAPIService) GetTrace(ctx context.Context, traceId string) ApiGetTraceRequest {
	return ApiGetTraceRequest{
		ApiService: a,
		ctx:        ctx,
		traceId:    traceId,
	}
}

// Execute executes the request
//
//	@return Trace
func (a *TracesAPIService) GetTraceExecute(r ApiGetTraceRequest) (*Trace, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Trace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracesAPIService.GetTrace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traces/{traceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"traceId"+"}", url.PathEscape(parameterToString(r.traceId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v TraceApiTraceNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TraceApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryDurationRequest struct {
	ctx          context.Context
	ApiService   TracesAPI
	startTime    *int32
	bucketsCount *int32
	spanFilter   *SpanFilter
	endTime      *int32
}

// The start time of a time range to query resources.
func (r ApiQueryDurationRequest) StartTime(startTime int32) ApiQueryDurationRequest {
	r.startTime = &startTime
	return r
}

// The number of histogram buckets.
func (r ApiQueryDurationRequest) BucketsCount(bucketsCount int32) ApiQueryDurationRequest {
	r.bucketsCount = &bucketsCount
	return r
}

// Filter for spans
func (r ApiQueryDurationRequest) SpanFilter(spanFilter SpanFilter) ApiQueryDurationRequest {
	r.spanFilter = &spanFilter
	return r
}

// The end time of a time range to query resources. If not given the endTime is set to current time.
func (r ApiQueryDurationRequest) EndTime(endTime int32) ApiQueryDurationRequest {
	r.endTime = &endTime
	return r
}

func (r ApiQueryDurationRequest) Execute() (*DurationHistogram, *http.Response, error) {
	return r.ApiService.QueryDurationExecute(r)
}

/*
QueryDuration Query duration distribution

Query for durations using filters.  Filters that accept an array of values match if any of the values match (think of a SQL IN expression).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiQueryDurationRequest
*/
func (a *TracesAPIService) QueryDuration(ctx context.Context) ApiQueryDurationRequest {
	return ApiQueryDurationRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DurationHistogram
func (a *TracesAPIService) QueryDurationExecute(r ApiQueryDurationRequest) (*DurationHistogram, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DurationHistogram
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracesAPIService.QueryDuration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traces/spans/duration/histogram"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.bucketsCount == nil {
		return localVarReturnValue, nil, reportError("bucketsCount is required and must be specified")
	}
	if r.spanFilter == nil {
		return localVarReturnValue, nil, reportError("spanFilter is required and must be specified")
	}

	localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	localVarQueryParams.Add("bucketsCount", parameterToString(*r.bucketsCount, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.spanFilter
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TraceApiSpansBadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TraceApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuerySpansRequest struct {
	ctx        context.Context
	ApiService TracesAPI
	startTime  *int32
	spanQuery  *SpanQuery
	endTime    *int32
	pageSize   *int32
	page       *int32
}

// The start time of a time range to query resources.
func (r ApiQuerySpansRequest) StartTime(startTime int32) ApiQuerySpansRequest {
	r.startTime = &startTime
	return r
}

// Query for spans
func (r ApiQuerySpansRequest) SpanQuery(spanQuery SpanQuery) ApiQuerySpansRequest {
	r.spanQuery = &spanQuery
	return r
}

// The end time of a time range to query resources. If not given the endTime is set to current time.
func (r ApiQuerySpansRequest) EndTime(endTime int32) ApiQuerySpansRequest {
	r.endTime = &endTime
	return r
}

// Maximum number of the log lines in the result.
func (r ApiQuerySpansRequest) PageSize(pageSize int32) ApiQuerySpansRequest {
	r.pageSize = &pageSize
	return r
}

// The page for which the log lines of pageSize must be returned.
func (r ApiQuerySpansRequest) Page(page int32) ApiQuerySpansRequest {
	r.page = &page
	return r
}

func (r ApiQuerySpansRequest) Execute() (*Spans, *http.Response, error) {
	return r.ApiService.QuerySpansExecute(r)
}

/*
QuerySpans Query for spans

Query for spans using filters, get all spans for a trace by trace id. Filters that accept an array of values match if any of the values match (think of a SQL IN expression).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiQuerySpansRequest
*/
func (a *TracesAPIService) QuerySpans(ctx context.Context) ApiQuerySpansRequest {
	return ApiQuerySpansRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Spans
func (a *TracesAPIService) QuerySpansExecute(r ApiQuerySpansRequest) (*Spans, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Spans
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracesAPIService.QuerySpans")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traces/spans"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}
	if r.spanQuery == nil {
		return localVarReturnValue, nil, reportError("spanQuery is required and must be specified")
	}

	localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.spanQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TraceApiSpansBadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TraceApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpanComponentsRequest struct {
	ctx            context.Context
	ApiService     TracesAPI
	componentQuery *ComponentQuery
}

// Span properties to find matching components
func (r ApiSpanComponentsRequest) ComponentQuery(componentQuery ComponentQuery) ApiSpanComponentsRequest {
	r.componentQuery = &componentQuery
	return r
}

func (r ApiSpanComponentsRequest) Execute() (*SpanComponents, *http.Response, error) {
	return r.ApiService.SpanComponentsExecute(r)
}

/*
SpanComponents Fetch components based on resource attributes

Based on the resource attributes on a span, retrieve components that have a TraceBinding for it.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSpanComponentsRequest
*/
func (a *TracesAPIService) SpanComponents(ctx context.Context) ApiSpanComponentsRequest {
	return ApiSpanComponentsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SpanComponents
func (a *TracesAPIService) SpanComponentsExecute(r ApiSpanComponentsRequest) (*SpanComponents, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SpanComponents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracesAPIService.SpanComponents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traces/components"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.componentQuery == nil {
		return localVarReturnValue, nil, reportError("componentQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.componentQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TraceApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSuggestionsAttributeNameRequest struct {
	ctx        context.Context
	ApiService TracesAPI
	contains   *string
}

// Get suggestions based of this partial name
func (r ApiSuggestionsAttributeNameRequest) Contains(contains string) ApiSuggestionsAttributeNameRequest {
	r.contains = &contains
	return r
}

func (r ApiSuggestionsAttributeNameRequest) Execute() (*Suggestions, *http.Response, error) {
	return r.ApiService.SuggestionsAttributeNameExecute(r)
}

/*
SuggestionsAttributeName Suggestions for attribute names

Suggestions for attribute names, both resource and span attributes. Attributes match when their name contains the provided part, at most 100 suggestions will be returned. Make the part longer to get more accurate suggestions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSuggestionsAttributeNameRequest
*/
func (a *TracesAPIService) SuggestionsAttributeName(ctx context.Context) ApiSuggestionsAttributeNameRequest {
	return ApiSuggestionsAttributeNameRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Suggestions
func (a *TracesAPIService) SuggestionsAttributeNameExecute(r ApiSuggestionsAttributeNameRequest) (*Suggestions, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Suggestions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracesAPIService.SuggestionsAttributeName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traces/spans/fields/attributes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contains != nil {
		localVarQueryParams.Add("contains", parameterToString(*r.contains, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TraceApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSuggestionsAttributeValueRequest struct {
	ctx           context.Context
	ApiService    TracesAPI
	attributeName string
	contains      *string
}

// Get suggestions based on this partial value
func (r ApiSuggestionsAttributeValueRequest) Contains(contains string) ApiSuggestionsAttributeValueRequest {
	r.contains = &contains
	return r
}

func (r ApiSuggestionsAttributeValueRequest) Execute() (*Suggestions, *http.Response, error) {
	return r.ApiService.SuggestionsAttributeValueExecute(r)
}

/*
SuggestionsAttributeValue Suggestions for attribute values

Suggestions for attribute values, both resource and span attributes. Attribute values match when the value contains the provided part, at most 100 suggestions will be returned. Make the part longer to get more accurate suggestions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param attributeName Get suggestions for this attribute
	@return ApiSuggestionsAttributeValueRequest
*/
func (a *TracesAPIService) SuggestionsAttributeValue(ctx context.Context, attributeName string) ApiSuggestionsAttributeValueRequest {
	return ApiSuggestionsAttributeValueRequest{
		ApiService:    a,
		ctx:           ctx,
		attributeName: attributeName,
	}
}

// Execute executes the request
//
//	@return Suggestions
func (a *TracesAPIService) SuggestionsAttributeValueExecute(r ApiSuggestionsAttributeValueRequest) (*Suggestions, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Suggestions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracesAPIService.SuggestionsAttributeValue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traces/spans/fields/attributes/{attributeName}/values"
	localVarPath = strings.Replace(localVarPath, "{"+"attributeName"+"}", url.PathEscape(parameterToString(r.attributeName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contains != nil {
		localVarQueryParams.Add("contains", parameterToString(*r.contains, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TraceApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSuggestionsFieldValuesRequest struct {
	ctx        context.Context
	ApiService TracesAPI
	field      SpanSuggestionField
	contains   *string
}

// Get suggestions for this field based on this partial value
func (r ApiSuggestionsFieldValuesRequest) Contains(contains string) ApiSuggestionsFieldValuesRequest {
	r.contains = &contains
	return r
}

func (r ApiSuggestionsFieldValuesRequest) Execute() (*Suggestions, *http.Response, error) {
	return r.ApiService.SuggestionsFieldValuesExecute(r)
}

/*
SuggestionsFieldValues Suggestions for span fields

Suggestions for values of of the span fields that can be filtered on except resource and span attributes. Values match when they contain the provided part, at most 100 suggestions will be returned. Make the part longer to get more accurate suggestions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param field Get suggestions for this field
	@return ApiSuggestionsFieldValuesRequest
*/
func (a *TracesAPIService) SuggestionsFieldValues(ctx context.Context, field SpanSuggestionField) ApiSuggestionsFieldValuesRequest {
	return ApiSuggestionsFieldValuesRequest{
		ApiService: a,
		ctx:        ctx,
		field:      field,
	}
}

// Execute executes the request
//
//	@return Suggestions
func (a *TracesAPIService) SuggestionsFieldValuesExecute(r ApiSuggestionsFieldValuesRequest) (*Suggestions, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Suggestions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracesAPIService.SuggestionsFieldValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/traces/spans/fields/{field}/values"
	localVarPath = strings.Replace(localVarPath, "{"+"field"+"}", url.PathEscape(parameterToString(r.field, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.contains != nil {
		localVarQueryParams.Add("contains", parameterToString(*r.contains, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TraceApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ---------------------------------------------
// ------------------ MOCKS --------------------
// ---------------------------------------------

type TracesAPIMock struct {
	GetSpanCalls                      *[]GetSpanCall
	GetSpanResponse                   GetSpanMockResponse
	GetTraceCalls                     *[]GetTraceCall
	GetTraceResponse                  GetTraceMockResponse
	QueryDurationCalls                *[]QueryDurationCall
	QueryDurationResponse             QueryDurationMockResponse
	QuerySpansCalls                   *[]QuerySpansCall
	QuerySpansResponse                QuerySpansMockResponse
	SpanComponentsCalls               *[]SpanComponentsCall
	SpanComponentsResponse            SpanComponentsMockResponse
	SuggestionsAttributeNameCalls     *[]SuggestionsAttributeNameCall
	SuggestionsAttributeNameResponse  SuggestionsAttributeNameMockResponse
	SuggestionsAttributeValueCalls    *[]SuggestionsAttributeValueCall
	SuggestionsAttributeValueResponse SuggestionsAttributeValueMockResponse
	SuggestionsFieldValuesCalls       *[]SuggestionsFieldValuesCall
	SuggestionsFieldValuesResponse    SuggestionsFieldValuesMockResponse
}

func NewTracesAPIMock() TracesAPIMock {
	xGetSpanCalls := make([]GetSpanCall, 0)
	xGetTraceCalls := make([]GetTraceCall, 0)
	xQueryDurationCalls := make([]QueryDurationCall, 0)
	xQuerySpansCalls := make([]QuerySpansCall, 0)
	xSpanComponentsCalls := make([]SpanComponentsCall, 0)
	xSuggestionsAttributeNameCalls := make([]SuggestionsAttributeNameCall, 0)
	xSuggestionsAttributeValueCalls := make([]SuggestionsAttributeValueCall, 0)
	xSuggestionsFieldValuesCalls := make([]SuggestionsFieldValuesCall, 0)
	return TracesAPIMock{
		GetSpanCalls:                   &xGetSpanCalls,
		GetTraceCalls:                  &xGetTraceCalls,
		QueryDurationCalls:             &xQueryDurationCalls,
		QuerySpansCalls:                &xQuerySpansCalls,
		SpanComponentsCalls:            &xSpanComponentsCalls,
		SuggestionsAttributeNameCalls:  &xSuggestionsAttributeNameCalls,
		SuggestionsAttributeValueCalls: &xSuggestionsAttributeValueCalls,
		SuggestionsFieldValuesCalls:    &xSuggestionsFieldValuesCalls,
	}
}

type GetSpanMockResponse struct {
	Result   Span
	Response *http.Response
	Error    error
}

type GetSpanCall struct {
	PtraceId string
	PspanId  string
}

func (mock TracesAPIMock) GetSpan(ctx context.Context, traceId string, spanId string) ApiGetSpanRequest {
	return ApiGetSpanRequest{
		ApiService: mock,
		ctx:        ctx,
		traceId:    traceId,
		spanId:     spanId,
	}
}

func (mock TracesAPIMock) GetSpanExecute(r ApiGetSpanRequest) (*Span, *http.Response, error) {
	p := GetSpanCall{
		PtraceId: r.traceId,
		PspanId:  r.spanId,
	}
	*mock.GetSpanCalls = append(*mock.GetSpanCalls, p)
	return &mock.GetSpanResponse.Result, mock.GetSpanResponse.Response, mock.GetSpanResponse.Error
}

type GetTraceMockResponse struct {
	Result   Trace
	Response *http.Response
	Error    error
}

type GetTraceCall struct {
	PtraceId string
}

func (mock TracesAPIMock) GetTrace(ctx context.Context, traceId string) ApiGetTraceRequest {
	return ApiGetTraceRequest{
		ApiService: mock,
		ctx:        ctx,
		traceId:    traceId,
	}
}

func (mock TracesAPIMock) GetTraceExecute(r ApiGetTraceRequest) (*Trace, *http.Response, error) {
	p := GetTraceCall{
		PtraceId: r.traceId,
	}
	*mock.GetTraceCalls = append(*mock.GetTraceCalls, p)
	return &mock.GetTraceResponse.Result, mock.GetTraceResponse.Response, mock.GetTraceResponse.Error
}

type QueryDurationMockResponse struct {
	Result   DurationHistogram
	Response *http.Response
	Error    error
}

type QueryDurationCall struct {
	PstartTime    *int32
	PbucketsCount *int32
	PspanFilter   *SpanFilter
	PendTime      *int32
}

func (mock TracesAPIMock) QueryDuration(ctx context.Context) ApiQueryDurationRequest {
	return ApiQueryDurationRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock TracesAPIMock) QueryDurationExecute(r ApiQueryDurationRequest) (*DurationHistogram, *http.Response, error) {
	p := QueryDurationCall{
		PstartTime:    r.startTime,
		PbucketsCount: r.bucketsCount,
		PspanFilter:   r.spanFilter,
		PendTime:      r.endTime,
	}
	*mock.QueryDurationCalls = append(*mock.QueryDurationCalls, p)
	return &mock.QueryDurationResponse.Result, mock.QueryDurationResponse.Response, mock.QueryDurationResponse.Error
}

type QuerySpansMockResponse struct {
	Result   Spans
	Response *http.Response
	Error    error
}

type QuerySpansCall struct {
	PstartTime *int32
	PspanQuery *SpanQuery
	PendTime   *int32
	PpageSize  *int32
	Ppage      *int32
}

func (mock TracesAPIMock) QuerySpans(ctx context.Context) ApiQuerySpansRequest {
	return ApiQuerySpansRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock TracesAPIMock) QuerySpansExecute(r ApiQuerySpansRequest) (*Spans, *http.Response, error) {
	p := QuerySpansCall{
		PstartTime: r.startTime,
		PspanQuery: r.spanQuery,
		PendTime:   r.endTime,
		PpageSize:  r.pageSize,
		Ppage:      r.page,
	}
	*mock.QuerySpansCalls = append(*mock.QuerySpansCalls, p)
	return &mock.QuerySpansResponse.Result, mock.QuerySpansResponse.Response, mock.QuerySpansResponse.Error
}

type SpanComponentsMockResponse struct {
	Result   SpanComponents
	Response *http.Response
	Error    error
}

type SpanComponentsCall struct {
	PcomponentQuery *ComponentQuery
}

func (mock TracesAPIMock) SpanComponents(ctx context.Context) ApiSpanComponentsRequest {
	return ApiSpanComponentsRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock TracesAPIMock) SpanComponentsExecute(r ApiSpanComponentsRequest) (*SpanComponents, *http.Response, error) {
	p := SpanComponentsCall{
		PcomponentQuery: r.componentQuery,
	}
	*mock.SpanComponentsCalls = append(*mock.SpanComponentsCalls, p)
	return &mock.SpanComponentsResponse.Result, mock.SpanComponentsResponse.Response, mock.SpanComponentsResponse.Error
}

type SuggestionsAttributeNameMockResponse struct {
	Result   Suggestions
	Response *http.Response
	Error    error
}

type SuggestionsAttributeNameCall struct {
	Pcontains *string
}

func (mock TracesAPIMock) SuggestionsAttributeName(ctx context.Context) ApiSuggestionsAttributeNameRequest {
	return ApiSuggestionsAttributeNameRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock TracesAPIMock) SuggestionsAttributeNameExecute(r ApiSuggestionsAttributeNameRequest) (*Suggestions, *http.Response, error) {
	p := SuggestionsAttributeNameCall{
		Pcontains: r.contains,
	}
	*mock.SuggestionsAttributeNameCalls = append(*mock.SuggestionsAttributeNameCalls, p)
	return &mock.SuggestionsAttributeNameResponse.Result, mock.SuggestionsAttributeNameResponse.Response, mock.SuggestionsAttributeNameResponse.Error
}

type SuggestionsAttributeValueMockResponse struct {
	Result   Suggestions
	Response *http.Response
	Error    error
}

type SuggestionsAttributeValueCall struct {
	PattributeName string
	Pcontains      *string
}

func (mock TracesAPIMock) SuggestionsAttributeValue(ctx context.Context, attributeName string) ApiSuggestionsAttributeValueRequest {
	return ApiSuggestionsAttributeValueRequest{
		ApiService:    mock,
		ctx:           ctx,
		attributeName: attributeName,
	}
}

func (mock TracesAPIMock) SuggestionsAttributeValueExecute(r ApiSuggestionsAttributeValueRequest) (*Suggestions, *http.Response, error) {
	p := SuggestionsAttributeValueCall{
		PattributeName: r.attributeName,
		Pcontains:      r.contains,
	}
	*mock.SuggestionsAttributeValueCalls = append(*mock.SuggestionsAttributeValueCalls, p)
	return &mock.SuggestionsAttributeValueResponse.Result, mock.SuggestionsAttributeValueResponse.Response, mock.SuggestionsAttributeValueResponse.Error
}

type SuggestionsFieldValuesMockResponse struct {
	Result   Suggestions
	Response *http.Response
	Error    error
}

type SuggestionsFieldValuesCall struct {
	Pfield    SpanSuggestionField
	Pcontains *string
}

func (mock TracesAPIMock) SuggestionsFieldValues(ctx context.Context, field SpanSuggestionField) ApiSuggestionsFieldValuesRequest {
	return ApiSuggestionsFieldValuesRequest{
		ApiService: mock,
		ctx:        ctx,
		field:      field,
	}
}

func (mock TracesAPIMock) SuggestionsFieldValuesExecute(r ApiSuggestionsFieldValuesRequest) (*Suggestions, *http.Response, error) {
	p := SuggestionsFieldValuesCall{
		Pfield:    r.field,
		Pcontains: r.contains,
	}
	*mock.SuggestionsFieldValuesCalls = append(*mock.SuggestionsFieldValuesCalls, p)
	return &mock.SuggestionsFieldValuesResponse.Result, mock.SuggestionsFieldValuesResponse.Response, mock.SuggestionsFieldValuesResponse.Error
}
