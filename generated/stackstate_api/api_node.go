/*
StackState API

This API documentation page describes the StackState server API. The StackState UI and CLI use the StackState server API to configure and query StackState.  You can use the API for similar purposes.  Each request sent to the StackState server API must be authenticated using one of the available authentication methods.   *Note that the StackState receiver API, used to send topology, telemetry and traces to StackState, is not described on this page and requires a different authentication method.*  For more information on StackState, refer to the [StackState documentation](https://docs.stackstate.com).

API version: 5.2.0
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackstate_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

type NodeApi interface {

	/*
		Clone Clone a node with a new name

		Clone a node with a new name

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nodeType
		@param nodeIdOrUrn
		@return ApiCloneRequest
	*/
	Clone(ctx context.Context, nodeType string, nodeIdOrUrn string) ApiCloneRequest

	// CloneExecute executes the request
	//  @return Node
	CloneExecute(r ApiCloneRequest) (*Node, *http.Response, error)

	/*
		Delete Node deletion API

		Delete a locked node

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nodeType
		@param nodeId
		@return ApiDeleteRequest
	*/
	Delete(ctx context.Context, nodeType string, nodeId int64) ApiDeleteRequest

	// DeleteExecute executes the request
	DeleteExecute(r ApiDeleteRequest) (*http.Response, error)

	/*
		Lock Retrieve if a node is locked

		Retrieve if a node is locked

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nodeType
		@param nodeId
		@return ApiLockRequest
	*/
	Lock(ctx context.Context, nodeType string, nodeId int64) ApiLockRequest

	// LockExecute executes the request
	//  @return LockedResponse
	LockExecute(r ApiLockRequest) (*LockedResponse, *http.Response, error)

	/*
		NodeListTypes Node API

		list all node types

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiNodeListTypesRequest
	*/
	NodeListTypes(ctx context.Context) ApiNodeListTypesRequest

	// NodeListTypesExecute executes the request
	//  @return NodeTypes
	NodeListTypesExecute(r ApiNodeListTypesRequest) (*NodeTypes, *http.Response, error)

	/*
		TypeList Node type API

		list all nodes of that type

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nodeType
		@return ApiTypeListRequest
	*/
	TypeList(ctx context.Context, nodeType string) ApiTypeListRequest

	// TypeListExecute executes the request
	//  @return []Node
	TypeListExecute(r ApiTypeListRequest) ([]Node, *http.Response, error)

	/*
		Unlock Node unlock API

		Unlock a locked node

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param nodeType
		@param nodeId
		@return ApiUnlockRequest
	*/
	Unlock(ctx context.Context, nodeType string, nodeId int64) ApiUnlockRequest

	// UnlockExecute executes the request
	//  @return Node
	UnlockExecute(r ApiUnlockRequest) (*Node, *http.Response, error)
}

// NodeApiService NodeApi service
type NodeApiService service

type ApiCloneRequest struct {
	ctx         context.Context
	ApiService  NodeApi
	nodeType    string
	nodeIdOrUrn string
	nodeName    *NodeName
}

// New name for the node
func (r ApiCloneRequest) NodeName(nodeName NodeName) ApiCloneRequest {
	r.nodeName = &nodeName
	return r
}

func (r ApiCloneRequest) Execute() (*Node, *http.Response, error) {
	return r.ApiService.CloneExecute(r)
}

/*
Clone Clone a node with a new name

Clone a node with a new name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeType
 @param nodeIdOrUrn
 @return ApiCloneRequest
*/
func (a *NodeApiService) Clone(ctx context.Context, nodeType string, nodeIdOrUrn string) ApiCloneRequest {
	return ApiCloneRequest{
		ApiService:  a,
		ctx:         ctx,
		nodeType:    nodeType,
		nodeIdOrUrn: nodeIdOrUrn,
	}
}

// Execute executes the request
//  @return Node
func (a *NodeApiService) CloneExecute(r ApiCloneRequest) (*Node, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Node
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeApiService.Clone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/node/{nodeType}/{nodeIdOrUrn}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"nodeType"+"}", url.PathEscape(parameterToString(r.nodeType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeIdOrUrn"+"}", url.PathEscape(parameterToString(r.nodeIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nodeName == nil {
		return localVarReturnValue, nil, reportError("nodeName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nodeName
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRequest struct {
	ctx            context.Context
	ApiService     NodeApi
	nodeType       string
	nodeId         int64
	timeoutSeconds *int64
}

func (r ApiDeleteRequest) TimeoutSeconds(timeoutSeconds int64) ApiDeleteRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteExecute(r)
}

/*
Delete Node deletion API

Delete a locked node

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeType
 @param nodeId
 @return ApiDeleteRequest
*/
func (a *NodeApiService) Delete(ctx context.Context, nodeType string, nodeId int64) ApiDeleteRequest {
	return ApiDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		nodeType:   nodeType,
		nodeId:     nodeId,
	}
}

// Execute executes the request
func (a *NodeApiService) DeleteExecute(r ApiDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeApiService.Delete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/node/{nodeType}/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nodeType"+"}", url.PathEscape(parameterToString(r.nodeType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", url.PathEscape(parameterToString(r.nodeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLockRequest struct {
	ctx        context.Context
	ApiService NodeApi
	nodeType   string
	nodeId     int64
}

func (r ApiLockRequest) Execute() (*LockedResponse, *http.Response, error) {
	return r.ApiService.LockExecute(r)
}

/*
Lock Retrieve if a node is locked

Retrieve if a node is locked

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeType
 @param nodeId
 @return ApiLockRequest
*/
func (a *NodeApiService) Lock(ctx context.Context, nodeType string, nodeId int64) ApiLockRequest {
	return ApiLockRequest{
		ApiService: a,
		ctx:        ctx,
		nodeType:   nodeType,
		nodeId:     nodeId,
	}
}

// Execute executes the request
//  @return LockedResponse
func (a *NodeApiService) LockExecute(r ApiLockRequest) (*LockedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LockedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeApiService.Lock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/node/{nodeType}/{nodeId}/islocked"
	localVarPath = strings.Replace(localVarPath, "{"+"nodeType"+"}", url.PathEscape(parameterToString(r.nodeType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", url.PathEscape(parameterToString(r.nodeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNodeListTypesRequest struct {
	ctx        context.Context
	ApiService NodeApi
}

func (r ApiNodeListTypesRequest) Execute() (*NodeTypes, *http.Response, error) {
	return r.ApiService.NodeListTypesExecute(r)
}

/*
NodeListTypes Node API

list all node types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiNodeListTypesRequest
*/
func (a *NodeApiService) NodeListTypes(ctx context.Context) ApiNodeListTypesRequest {
	return ApiNodeListTypesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return NodeTypes
func (a *NodeApiService) NodeListTypesExecute(r ApiNodeListTypesRequest) (*NodeTypes, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NodeTypes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeApiService.NodeListTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/node"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTypeListRequest struct {
	ctx        context.Context
	ApiService NodeApi
	nodeType   string
	namespace  *string
	ownedBy    *string
}

func (r ApiTypeListRequest) Namespace(namespace string) ApiTypeListRequest {
	r.namespace = &namespace
	return r
}

func (r ApiTypeListRequest) OwnedBy(ownedBy string) ApiTypeListRequest {
	r.ownedBy = &ownedBy
	return r
}

func (r ApiTypeListRequest) Execute() ([]Node, *http.Response, error) {
	return r.ApiService.TypeListExecute(r)
}

/*
TypeList Node type API

list all nodes of that type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeType
 @return ApiTypeListRequest
*/
func (a *NodeApiService) TypeList(ctx context.Context, nodeType string) ApiTypeListRequest {
	return ApiTypeListRequest{
		ApiService: a,
		ctx:        ctx,
		nodeType:   nodeType,
	}
}

// Execute executes the request
//  @return []Node
func (a *NodeApiService) TypeListExecute(r ApiTypeListRequest) ([]Node, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Node
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeApiService.TypeList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/node/{nodeType}"
	localVarPath = strings.Replace(localVarPath, "{"+"nodeType"+"}", url.PathEscape(parameterToString(r.nodeType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.namespace != nil {
		localVarQueryParams.Add("namespace", parameterToString(*r.namespace, ""))
	}
	if r.ownedBy != nil {
		localVarQueryParams.Add("ownedBy", parameterToString(*r.ownedBy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnlockRequest struct {
	ctx        context.Context
	ApiService NodeApi
	nodeType   string
	nodeId     int64
}

func (r ApiUnlockRequest) Execute() (*Node, *http.Response, error) {
	return r.ApiService.UnlockExecute(r)
}

/*
Unlock Node unlock API

Unlock a locked node

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeType
 @param nodeId
 @return ApiUnlockRequest
*/
func (a *NodeApiService) Unlock(ctx context.Context, nodeType string, nodeId int64) ApiUnlockRequest {
	return ApiUnlockRequest{
		ApiService: a,
		ctx:        ctx,
		nodeType:   nodeType,
		nodeId:     nodeId,
	}
}

// Execute executes the request
//  @return Node
func (a *NodeApiService) UnlockExecute(r ApiUnlockRequest) (*Node, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Node
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeApiService.Unlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/node/{nodeType}/{nodeId}/unlock"
	localVarPath = strings.Replace(localVarPath, "{"+"nodeType"+"}", url.PathEscape(parameterToString(r.nodeType, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", url.PathEscape(parameterToString(r.nodeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ---------------------------------------------
// ------------------ MOCKS --------------------
// ---------------------------------------------

type NodeApiMock struct {
	CloneCalls            *[]CloneCall
	CloneResponse         CloneMockResponse
	DeleteCalls           *[]DeleteCall
	DeleteResponse        DeleteMockResponse
	LockCalls             *[]LockCall
	LockResponse          LockMockResponse
	NodeListTypesCalls    *[]NodeListTypesCall
	NodeListTypesResponse NodeListTypesMockResponse
	TypeListCalls         *[]TypeListCall
	TypeListResponse      TypeListMockResponse
	UnlockCalls           *[]UnlockCall
	UnlockResponse        UnlockMockResponse
}

func NewNodeApiMock() NodeApiMock {
	xCloneCalls := make([]CloneCall, 0)
	xDeleteCalls := make([]DeleteCall, 0)
	xLockCalls := make([]LockCall, 0)
	xNodeListTypesCalls := make([]NodeListTypesCall, 0)
	xTypeListCalls := make([]TypeListCall, 0)
	xUnlockCalls := make([]UnlockCall, 0)
	return NodeApiMock{
		CloneCalls:         &xCloneCalls,
		DeleteCalls:        &xDeleteCalls,
		LockCalls:          &xLockCalls,
		NodeListTypesCalls: &xNodeListTypesCalls,
		TypeListCalls:      &xTypeListCalls,
		UnlockCalls:        &xUnlockCalls,
	}
}

type CloneMockResponse struct {
	Result   Node
	Response *http.Response
	Error    error
}

type CloneCall struct {
	PnodeType    string
	PnodeIdOrUrn string
	PnodeName    *NodeName
}

func (mock NodeApiMock) Clone(ctx context.Context, nodeType string, nodeIdOrUrn string) ApiCloneRequest {
	return ApiCloneRequest{
		ApiService:  mock,
		ctx:         ctx,
		nodeType:    nodeType,
		nodeIdOrUrn: nodeIdOrUrn,
	}
}

func (mock NodeApiMock) CloneExecute(r ApiCloneRequest) (*Node, *http.Response, error) {
	p := CloneCall{
		PnodeType:    r.nodeType,
		PnodeIdOrUrn: r.nodeIdOrUrn,
		PnodeName:    r.nodeName,
	}
	*mock.CloneCalls = append(*mock.CloneCalls, p)
	return &mock.CloneResponse.Result, mock.CloneResponse.Response, mock.CloneResponse.Error
}

type DeleteMockResponse struct {
	Response *http.Response
	Error    error
}

type DeleteCall struct {
	PnodeType       string
	PnodeId         int64
	PtimeoutSeconds *int64
}

func (mock NodeApiMock) Delete(ctx context.Context, nodeType string, nodeId int64) ApiDeleteRequest {
	return ApiDeleteRequest{
		ApiService: mock,
		ctx:        ctx,
		nodeType:   nodeType,
		nodeId:     nodeId,
	}
}

func (mock NodeApiMock) DeleteExecute(r ApiDeleteRequest) (*http.Response, error) {
	p := DeleteCall{
		PnodeType:       r.nodeType,
		PnodeId:         r.nodeId,
		PtimeoutSeconds: r.timeoutSeconds,
	}
	*mock.DeleteCalls = append(*mock.DeleteCalls, p)
	return mock.DeleteResponse.Response, mock.DeleteResponse.Error
}

type LockMockResponse struct {
	Result   LockedResponse
	Response *http.Response
	Error    error
}

type LockCall struct {
	PnodeType string
	PnodeId   int64
}

func (mock NodeApiMock) Lock(ctx context.Context, nodeType string, nodeId int64) ApiLockRequest {
	return ApiLockRequest{
		ApiService: mock,
		ctx:        ctx,
		nodeType:   nodeType,
		nodeId:     nodeId,
	}
}

func (mock NodeApiMock) LockExecute(r ApiLockRequest) (*LockedResponse, *http.Response, error) {
	p := LockCall{
		PnodeType: r.nodeType,
		PnodeId:   r.nodeId,
	}
	*mock.LockCalls = append(*mock.LockCalls, p)
	return &mock.LockResponse.Result, mock.LockResponse.Response, mock.LockResponse.Error
}

type NodeListTypesMockResponse struct {
	Result   NodeTypes
	Response *http.Response
	Error    error
}

type NodeListTypesCall struct {
}

func (mock NodeApiMock) NodeListTypes(ctx context.Context) ApiNodeListTypesRequest {
	return ApiNodeListTypesRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock NodeApiMock) NodeListTypesExecute(r ApiNodeListTypesRequest) (*NodeTypes, *http.Response, error) {
	p := NodeListTypesCall{}
	*mock.NodeListTypesCalls = append(*mock.NodeListTypesCalls, p)
	return &mock.NodeListTypesResponse.Result, mock.NodeListTypesResponse.Response, mock.NodeListTypesResponse.Error
}

type TypeListMockResponse struct {
	Result   []Node
	Response *http.Response
	Error    error
}

type TypeListCall struct {
	PnodeType  string
	Pnamespace *string
	PownedBy   *string
}

func (mock NodeApiMock) TypeList(ctx context.Context, nodeType string) ApiTypeListRequest {
	return ApiTypeListRequest{
		ApiService: mock,
		ctx:        ctx,
		nodeType:   nodeType,
	}
}

func (mock NodeApiMock) TypeListExecute(r ApiTypeListRequest) ([]Node, *http.Response, error) {
	p := TypeListCall{
		PnodeType:  r.nodeType,
		Pnamespace: r.namespace,
		PownedBy:   r.ownedBy,
	}
	*mock.TypeListCalls = append(*mock.TypeListCalls, p)
	return mock.TypeListResponse.Result, mock.TypeListResponse.Response, mock.TypeListResponse.Error
}

type UnlockMockResponse struct {
	Result   Node
	Response *http.Response
	Error    error
}

type UnlockCall struct {
	PnodeType string
	PnodeId   int64
}

func (mock NodeApiMock) Unlock(ctx context.Context, nodeType string, nodeId int64) ApiUnlockRequest {
	return ApiUnlockRequest{
		ApiService: mock,
		ctx:        ctx,
		nodeType:   nodeType,
		nodeId:     nodeId,
	}
}

func (mock NodeApiMock) UnlockExecute(r ApiUnlockRequest) (*Node, *http.Response, error) {
	p := UnlockCall{
		PnodeType: r.nodeType,
		PnodeId:   r.nodeId,
	}
	*mock.UnlockCalls = append(*mock.UnlockCalls, p)
	return &mock.UnlockResponse.Result, mock.UnlockResponse.Response, mock.UnlockResponse.Error
}
