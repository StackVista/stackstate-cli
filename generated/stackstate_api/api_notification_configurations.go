/*
StackState API

This API documentation page describes the StackState server API. The StackState UI and CLI use the StackState server API to configure and query StackState.  You can use the API for similar purposes.  Each request sent to the StackState server API must be authenticated using one of the available authentication methods.   *Note that the StackState receiver API, used to send topology, telemetry and traces to StackState, is not described on this page and requires a different authentication method.*  For more information on StackState, refer to the [StackState documentation](https://docs.stackstate.com).

API version: 5.2.0
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackstate_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

type NotificationConfigurationsAPI interface {

	/*
		CreateNotificationConfiguration Create a new notification configuration

		Create a new notification configuration

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateNotificationConfigurationRequest
	*/
	CreateNotificationConfiguration(ctx context.Context) ApiCreateNotificationConfigurationRequest

	// CreateNotificationConfigurationExecute executes the request
	//  @return NotificationConfigurationReadSchema
	CreateNotificationConfigurationExecute(r ApiCreateNotificationConfigurationRequest) (*NotificationConfigurationReadSchema, *http.Response, error)

	/*
		DeleteNotificationConfiguration Delete the notification configuration

		Delete the notification configuration

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param notificationConfigurationIdOrUrn Notification identifier
		@return ApiDeleteNotificationConfigurationRequest
	*/
	DeleteNotificationConfiguration(ctx context.Context, notificationConfigurationIdOrUrn string) ApiDeleteNotificationConfigurationRequest

	// DeleteNotificationConfigurationExecute executes the request
	DeleteNotificationConfigurationExecute(r ApiDeleteNotificationConfigurationRequest) (*http.Response, error)

	/*
		GetNotificationConfiguration Get the notification configuration

		Get the notification configuration

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param notificationConfigurationIdOrUrn Notification identifier
		@return ApiGetNotificationConfigurationRequest
	*/
	GetNotificationConfiguration(ctx context.Context, notificationConfigurationIdOrUrn string) ApiGetNotificationConfigurationRequest

	// GetNotificationConfigurationExecute executes the request
	//  @return NotificationConfigurationReadSchema
	GetNotificationConfigurationExecute(r ApiGetNotificationConfigurationRequest) (*NotificationConfigurationReadSchema, *http.Response, error)

	/*
		GetNotificationConfigurationChannels Get the channels for the notification configuration

		Get the channels for the notification configuration

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param notificationConfigurationIdOrUrn Notification identifier
		@return ApiGetNotificationConfigurationChannelsRequest
	*/
	GetNotificationConfigurationChannels(ctx context.Context, notificationConfigurationIdOrUrn string) ApiGetNotificationConfigurationChannelsRequest

	// GetNotificationConfigurationChannelsExecute executes the request
	//  @return []NotificationChannel
	GetNotificationConfigurationChannelsExecute(r ApiGetNotificationConfigurationChannelsRequest) ([]NotificationChannel, *http.Response, error)

	/*
		GetNotificationConfigurations Get all notification configurations

		Get all notification configurations

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetNotificationConfigurationsRequest
	*/
	GetNotificationConfigurations(ctx context.Context) ApiGetNotificationConfigurationsRequest

	// GetNotificationConfigurationsExecute executes the request
	//  @return []NotificationConfigurationReadSchema
	GetNotificationConfigurationsExecute(r ApiGetNotificationConfigurationsRequest) ([]NotificationConfigurationReadSchema, *http.Response, error)

	/*
		UpdateNotificationConfiguration Update the notification configuration

		Update the notification configuration

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param notificationConfigurationIdOrUrn Notification identifier
		@return ApiUpdateNotificationConfigurationRequest
	*/
	UpdateNotificationConfiguration(ctx context.Context, notificationConfigurationIdOrUrn string) ApiUpdateNotificationConfigurationRequest

	// UpdateNotificationConfigurationExecute executes the request
	//  @return NotificationConfigurationReadSchema
	UpdateNotificationConfigurationExecute(r ApiUpdateNotificationConfigurationRequest) (*NotificationConfigurationReadSchema, *http.Response, error)
}

// NotificationConfigurationsAPIService NotificationConfigurationsAPI service
type NotificationConfigurationsAPIService service

type ApiCreateNotificationConfigurationRequest struct {
	ctx                                  context.Context
	ApiService                           NotificationConfigurationsAPI
	notificationConfigurationWriteSchema *NotificationConfigurationWriteSchema
}

// Create or update a notification configuration
func (r ApiCreateNotificationConfigurationRequest) NotificationConfigurationWriteSchema(notificationConfigurationWriteSchema NotificationConfigurationWriteSchema) ApiCreateNotificationConfigurationRequest {
	r.notificationConfigurationWriteSchema = &notificationConfigurationWriteSchema
	return r
}

func (r ApiCreateNotificationConfigurationRequest) Execute() (*NotificationConfigurationReadSchema, *http.Response, error) {
	return r.ApiService.CreateNotificationConfigurationExecute(r)
}

/*
CreateNotificationConfiguration Create a new notification configuration

Create a new notification configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateNotificationConfigurationRequest
*/
func (a *NotificationConfigurationsAPIService) CreateNotificationConfiguration(ctx context.Context) ApiCreateNotificationConfigurationRequest {
	return ApiCreateNotificationConfigurationRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return NotificationConfigurationReadSchema
func (a *NotificationConfigurationsAPIService) CreateNotificationConfigurationExecute(r ApiCreateNotificationConfigurationRequest) (*NotificationConfigurationReadSchema, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NotificationConfigurationReadSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationConfigurationsAPIService.CreateNotificationConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.notificationConfigurationWriteSchema == nil {
		return localVarReturnValue, nil, reportError("notificationConfigurationWriteSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationConfigurationWriteSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationConfigurationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationConfigurationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteNotificationConfigurationRequest struct {
	ctx                              context.Context
	ApiService                       NotificationConfigurationsAPI
	notificationConfigurationIdOrUrn string
}

func (r ApiDeleteNotificationConfigurationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteNotificationConfigurationExecute(r)
}

/*
DeleteNotificationConfiguration Delete the notification configuration

Delete the notification configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param notificationConfigurationIdOrUrn Notification identifier
	@return ApiDeleteNotificationConfigurationRequest
*/
func (a *NotificationConfigurationsAPIService) DeleteNotificationConfiguration(ctx context.Context, notificationConfigurationIdOrUrn string) ApiDeleteNotificationConfigurationRequest {
	return ApiDeleteNotificationConfigurationRequest{
		ApiService:                       a,
		ctx:                              ctx,
		notificationConfigurationIdOrUrn: notificationConfigurationIdOrUrn,
	}
}

// Execute executes the request
func (a *NotificationConfigurationsAPIService) DeleteNotificationConfigurationExecute(r ApiDeleteNotificationConfigurationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationConfigurationsAPIService.DeleteNotificationConfiguration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/configurations/{notificationConfigurationIdOrUrn}"
	localVarPath = strings.Replace(localVarPath, "{"+"notificationConfigurationIdOrUrn"+"}", url.PathEscape(parameterToString(r.notificationConfigurationIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationConfigurationByIdErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationConfigurationNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationConfigurationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetNotificationConfigurationRequest struct {
	ctx                              context.Context
	ApiService                       NotificationConfigurationsAPI
	notificationConfigurationIdOrUrn string
}

func (r ApiGetNotificationConfigurationRequest) Execute() (*NotificationConfigurationReadSchema, *http.Response, error) {
	return r.ApiService.GetNotificationConfigurationExecute(r)
}

/*
GetNotificationConfiguration Get the notification configuration

Get the notification configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param notificationConfigurationIdOrUrn Notification identifier
	@return ApiGetNotificationConfigurationRequest
*/
func (a *NotificationConfigurationsAPIService) GetNotificationConfiguration(ctx context.Context, notificationConfigurationIdOrUrn string) ApiGetNotificationConfigurationRequest {
	return ApiGetNotificationConfigurationRequest{
		ApiService:                       a,
		ctx:                              ctx,
		notificationConfigurationIdOrUrn: notificationConfigurationIdOrUrn,
	}
}

// Execute executes the request
//
//	@return NotificationConfigurationReadSchema
func (a *NotificationConfigurationsAPIService) GetNotificationConfigurationExecute(r ApiGetNotificationConfigurationRequest) (*NotificationConfigurationReadSchema, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NotificationConfigurationReadSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationConfigurationsAPIService.GetNotificationConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/configurations/{notificationConfigurationIdOrUrn}"
	localVarPath = strings.Replace(localVarPath, "{"+"notificationConfigurationIdOrUrn"+"}", url.PathEscape(parameterToString(r.notificationConfigurationIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationConfigurationByIdErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationConfigurationNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationConfigurationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNotificationConfigurationChannelsRequest struct {
	ctx                              context.Context
	ApiService                       NotificationConfigurationsAPI
	notificationConfigurationIdOrUrn string
}

func (r ApiGetNotificationConfigurationChannelsRequest) Execute() ([]NotificationChannel, *http.Response, error) {
	return r.ApiService.GetNotificationConfigurationChannelsExecute(r)
}

/*
GetNotificationConfigurationChannels Get the channels for the notification configuration

Get the channels for the notification configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param notificationConfigurationIdOrUrn Notification identifier
	@return ApiGetNotificationConfigurationChannelsRequest
*/
func (a *NotificationConfigurationsAPIService) GetNotificationConfigurationChannels(ctx context.Context, notificationConfigurationIdOrUrn string) ApiGetNotificationConfigurationChannelsRequest {
	return ApiGetNotificationConfigurationChannelsRequest{
		ApiService:                       a,
		ctx:                              ctx,
		notificationConfigurationIdOrUrn: notificationConfigurationIdOrUrn,
	}
}

// Execute executes the request
//
//	@return []NotificationChannel
func (a *NotificationConfigurationsAPIService) GetNotificationConfigurationChannelsExecute(r ApiGetNotificationConfigurationChannelsRequest) ([]NotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []NotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationConfigurationsAPIService.GetNotificationConfigurationChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/configurations/{notificationConfigurationIdOrUrn}/channels"
	localVarPath = strings.Replace(localVarPath, "{"+"notificationConfigurationIdOrUrn"+"}", url.PathEscape(parameterToString(r.notificationConfigurationIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationConfigurationByIdErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationConfigurationNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationConfigurationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNotificationConfigurationsRequest struct {
	ctx        context.Context
	ApiService NotificationConfigurationsAPI
}

func (r ApiGetNotificationConfigurationsRequest) Execute() ([]NotificationConfigurationReadSchema, *http.Response, error) {
	return r.ApiService.GetNotificationConfigurationsExecute(r)
}

/*
GetNotificationConfigurations Get all notification configurations

Get all notification configurations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetNotificationConfigurationsRequest
*/
func (a *NotificationConfigurationsAPIService) GetNotificationConfigurations(ctx context.Context) ApiGetNotificationConfigurationsRequest {
	return ApiGetNotificationConfigurationsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []NotificationConfigurationReadSchema
func (a *NotificationConfigurationsAPIService) GetNotificationConfigurationsExecute(r ApiGetNotificationConfigurationsRequest) ([]NotificationConfigurationReadSchema, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []NotificationConfigurationReadSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationConfigurationsAPIService.GetNotificationConfigurations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/configurations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationConfigurationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationConfigurationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateNotificationConfigurationRequest struct {
	ctx                                  context.Context
	ApiService                           NotificationConfigurationsAPI
	notificationConfigurationIdOrUrn     string
	notificationConfigurationWriteSchema *NotificationConfigurationWriteSchema
}

// Create or update a notification configuration
func (r ApiUpdateNotificationConfigurationRequest) NotificationConfigurationWriteSchema(notificationConfigurationWriteSchema NotificationConfigurationWriteSchema) ApiUpdateNotificationConfigurationRequest {
	r.notificationConfigurationWriteSchema = &notificationConfigurationWriteSchema
	return r
}

func (r ApiUpdateNotificationConfigurationRequest) Execute() (*NotificationConfigurationReadSchema, *http.Response, error) {
	return r.ApiService.UpdateNotificationConfigurationExecute(r)
}

/*
UpdateNotificationConfiguration Update the notification configuration

Update the notification configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param notificationConfigurationIdOrUrn Notification identifier
	@return ApiUpdateNotificationConfigurationRequest
*/
func (a *NotificationConfigurationsAPIService) UpdateNotificationConfiguration(ctx context.Context, notificationConfigurationIdOrUrn string) ApiUpdateNotificationConfigurationRequest {
	return ApiUpdateNotificationConfigurationRequest{
		ApiService:                       a,
		ctx:                              ctx,
		notificationConfigurationIdOrUrn: notificationConfigurationIdOrUrn,
	}
}

// Execute executes the request
//
//	@return NotificationConfigurationReadSchema
func (a *NotificationConfigurationsAPIService) UpdateNotificationConfigurationExecute(r ApiUpdateNotificationConfigurationRequest) (*NotificationConfigurationReadSchema, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NotificationConfigurationReadSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationConfigurationsAPIService.UpdateNotificationConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/configurations/{notificationConfigurationIdOrUrn}"
	localVarPath = strings.Replace(localVarPath, "{"+"notificationConfigurationIdOrUrn"+"}", url.PathEscape(parameterToString(r.notificationConfigurationIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.notificationConfigurationWriteSchema == nil {
		return localVarReturnValue, nil, reportError("notificationConfigurationWriteSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationConfigurationWriteSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationConfigurationByIdErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationConfigurationNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationConfigurationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ---------------------------------------------
// ------------------ MOCKS --------------------
// ---------------------------------------------

type NotificationConfigurationsAPIMock struct {
	CreateNotificationConfigurationCalls         *[]CreateNotificationConfigurationCall
	CreateNotificationConfigurationResponse      CreateNotificationConfigurationMockResponse
	DeleteNotificationConfigurationCalls         *[]DeleteNotificationConfigurationCall
	DeleteNotificationConfigurationResponse      DeleteNotificationConfigurationMockResponse
	GetNotificationConfigurationCalls            *[]GetNotificationConfigurationCall
	GetNotificationConfigurationResponse         GetNotificationConfigurationMockResponse
	GetNotificationConfigurationChannelsCalls    *[]GetNotificationConfigurationChannelsCall
	GetNotificationConfigurationChannelsResponse GetNotificationConfigurationChannelsMockResponse
	GetNotificationConfigurationsCalls           *[]GetNotificationConfigurationsCall
	GetNotificationConfigurationsResponse        GetNotificationConfigurationsMockResponse
	UpdateNotificationConfigurationCalls         *[]UpdateNotificationConfigurationCall
	UpdateNotificationConfigurationResponse      UpdateNotificationConfigurationMockResponse
}

func NewNotificationConfigurationsAPIMock() NotificationConfigurationsAPIMock {
	xCreateNotificationConfigurationCalls := make([]CreateNotificationConfigurationCall, 0)
	xDeleteNotificationConfigurationCalls := make([]DeleteNotificationConfigurationCall, 0)
	xGetNotificationConfigurationCalls := make([]GetNotificationConfigurationCall, 0)
	xGetNotificationConfigurationChannelsCalls := make([]GetNotificationConfigurationChannelsCall, 0)
	xGetNotificationConfigurationsCalls := make([]GetNotificationConfigurationsCall, 0)
	xUpdateNotificationConfigurationCalls := make([]UpdateNotificationConfigurationCall, 0)
	return NotificationConfigurationsAPIMock{
		CreateNotificationConfigurationCalls:      &xCreateNotificationConfigurationCalls,
		DeleteNotificationConfigurationCalls:      &xDeleteNotificationConfigurationCalls,
		GetNotificationConfigurationCalls:         &xGetNotificationConfigurationCalls,
		GetNotificationConfigurationChannelsCalls: &xGetNotificationConfigurationChannelsCalls,
		GetNotificationConfigurationsCalls:        &xGetNotificationConfigurationsCalls,
		UpdateNotificationConfigurationCalls:      &xUpdateNotificationConfigurationCalls,
	}
}

type CreateNotificationConfigurationMockResponse struct {
	Result   NotificationConfigurationReadSchema
	Response *http.Response
	Error    error
}

type CreateNotificationConfigurationCall struct {
	PnotificationConfigurationWriteSchema *NotificationConfigurationWriteSchema
}

func (mock NotificationConfigurationsAPIMock) CreateNotificationConfiguration(ctx context.Context) ApiCreateNotificationConfigurationRequest {
	return ApiCreateNotificationConfigurationRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock NotificationConfigurationsAPIMock) CreateNotificationConfigurationExecute(r ApiCreateNotificationConfigurationRequest) (*NotificationConfigurationReadSchema, *http.Response, error) {
	p := CreateNotificationConfigurationCall{
		PnotificationConfigurationWriteSchema: r.notificationConfigurationWriteSchema,
	}
	*mock.CreateNotificationConfigurationCalls = append(*mock.CreateNotificationConfigurationCalls, p)
	return &mock.CreateNotificationConfigurationResponse.Result, mock.CreateNotificationConfigurationResponse.Response, mock.CreateNotificationConfigurationResponse.Error
}

type DeleteNotificationConfigurationMockResponse struct {
	Response *http.Response
	Error    error
}

type DeleteNotificationConfigurationCall struct {
	PnotificationConfigurationIdOrUrn string
}

func (mock NotificationConfigurationsAPIMock) DeleteNotificationConfiguration(ctx context.Context, notificationConfigurationIdOrUrn string) ApiDeleteNotificationConfigurationRequest {
	return ApiDeleteNotificationConfigurationRequest{
		ApiService:                       mock,
		ctx:                              ctx,
		notificationConfigurationIdOrUrn: notificationConfigurationIdOrUrn,
	}
}

func (mock NotificationConfigurationsAPIMock) DeleteNotificationConfigurationExecute(r ApiDeleteNotificationConfigurationRequest) (*http.Response, error) {
	p := DeleteNotificationConfigurationCall{
		PnotificationConfigurationIdOrUrn: r.notificationConfigurationIdOrUrn,
	}
	*mock.DeleteNotificationConfigurationCalls = append(*mock.DeleteNotificationConfigurationCalls, p)
	return mock.DeleteNotificationConfigurationResponse.Response, mock.DeleteNotificationConfigurationResponse.Error
}

type GetNotificationConfigurationMockResponse struct {
	Result   NotificationConfigurationReadSchema
	Response *http.Response
	Error    error
}

type GetNotificationConfigurationCall struct {
	PnotificationConfigurationIdOrUrn string
}

func (mock NotificationConfigurationsAPIMock) GetNotificationConfiguration(ctx context.Context, notificationConfigurationIdOrUrn string) ApiGetNotificationConfigurationRequest {
	return ApiGetNotificationConfigurationRequest{
		ApiService:                       mock,
		ctx:                              ctx,
		notificationConfigurationIdOrUrn: notificationConfigurationIdOrUrn,
	}
}

func (mock NotificationConfigurationsAPIMock) GetNotificationConfigurationExecute(r ApiGetNotificationConfigurationRequest) (*NotificationConfigurationReadSchema, *http.Response, error) {
	p := GetNotificationConfigurationCall{
		PnotificationConfigurationIdOrUrn: r.notificationConfigurationIdOrUrn,
	}
	*mock.GetNotificationConfigurationCalls = append(*mock.GetNotificationConfigurationCalls, p)
	return &mock.GetNotificationConfigurationResponse.Result, mock.GetNotificationConfigurationResponse.Response, mock.GetNotificationConfigurationResponse.Error
}

type GetNotificationConfigurationChannelsMockResponse struct {
	Result   []NotificationChannel
	Response *http.Response
	Error    error
}

type GetNotificationConfigurationChannelsCall struct {
	PnotificationConfigurationIdOrUrn string
}

func (mock NotificationConfigurationsAPIMock) GetNotificationConfigurationChannels(ctx context.Context, notificationConfigurationIdOrUrn string) ApiGetNotificationConfigurationChannelsRequest {
	return ApiGetNotificationConfigurationChannelsRequest{
		ApiService:                       mock,
		ctx:                              ctx,
		notificationConfigurationIdOrUrn: notificationConfigurationIdOrUrn,
	}
}

func (mock NotificationConfigurationsAPIMock) GetNotificationConfigurationChannelsExecute(r ApiGetNotificationConfigurationChannelsRequest) ([]NotificationChannel, *http.Response, error) {
	p := GetNotificationConfigurationChannelsCall{
		PnotificationConfigurationIdOrUrn: r.notificationConfigurationIdOrUrn,
	}
	*mock.GetNotificationConfigurationChannelsCalls = append(*mock.GetNotificationConfigurationChannelsCalls, p)
	return mock.GetNotificationConfigurationChannelsResponse.Result, mock.GetNotificationConfigurationChannelsResponse.Response, mock.GetNotificationConfigurationChannelsResponse.Error
}

type GetNotificationConfigurationsMockResponse struct {
	Result   []NotificationConfigurationReadSchema
	Response *http.Response
	Error    error
}

type GetNotificationConfigurationsCall struct {
}

func (mock NotificationConfigurationsAPIMock) GetNotificationConfigurations(ctx context.Context) ApiGetNotificationConfigurationsRequest {
	return ApiGetNotificationConfigurationsRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock NotificationConfigurationsAPIMock) GetNotificationConfigurationsExecute(r ApiGetNotificationConfigurationsRequest) ([]NotificationConfigurationReadSchema, *http.Response, error) {
	p := GetNotificationConfigurationsCall{}
	*mock.GetNotificationConfigurationsCalls = append(*mock.GetNotificationConfigurationsCalls, p)
	return mock.GetNotificationConfigurationsResponse.Result, mock.GetNotificationConfigurationsResponse.Response, mock.GetNotificationConfigurationsResponse.Error
}

type UpdateNotificationConfigurationMockResponse struct {
	Result   NotificationConfigurationReadSchema
	Response *http.Response
	Error    error
}

type UpdateNotificationConfigurationCall struct {
	PnotificationConfigurationIdOrUrn     string
	PnotificationConfigurationWriteSchema *NotificationConfigurationWriteSchema
}

func (mock NotificationConfigurationsAPIMock) UpdateNotificationConfiguration(ctx context.Context, notificationConfigurationIdOrUrn string) ApiUpdateNotificationConfigurationRequest {
	return ApiUpdateNotificationConfigurationRequest{
		ApiService:                       mock,
		ctx:                              ctx,
		notificationConfigurationIdOrUrn: notificationConfigurationIdOrUrn,
	}
}

func (mock NotificationConfigurationsAPIMock) UpdateNotificationConfigurationExecute(r ApiUpdateNotificationConfigurationRequest) (*NotificationConfigurationReadSchema, *http.Response, error) {
	p := UpdateNotificationConfigurationCall{
		PnotificationConfigurationIdOrUrn:     r.notificationConfigurationIdOrUrn,
		PnotificationConfigurationWriteSchema: r.notificationConfigurationWriteSchema,
	}
	*mock.UpdateNotificationConfigurationCalls = append(*mock.UpdateNotificationConfigurationCalls, p)
	return &mock.UpdateNotificationConfigurationResponse.Result, mock.UpdateNotificationConfigurationResponse.Response, mock.UpdateNotificationConfigurationResponse.Error
}
