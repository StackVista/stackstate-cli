/*
StackState API

This API documentation page describes the StackState server API. The StackState UI and CLI use the StackState server API to configure and query StackState.  You can use the API for similar purposes.  Each request sent to the StackState server API must be authenticated using one of the available authentication methods.   *Note that the StackState receiver API, used to send topology, telemetry and traces to StackState, is not described on this page and requires a different authentication method.*  For more information on StackState, refer to the [StackState documentation](https://docs.stackstate.com).

API version: 5.2.0
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackstate_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

type MonitorAPI interface {

	/*
		DeleteMonitor Delete a monitor

		Deletes existing monitor

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorIdOrUrn The id or identifier (urn) of a monitor
		@return ApiDeleteMonitorRequest
	*/
	DeleteMonitor(ctx context.Context, monitorIdOrUrn string) ApiDeleteMonitorRequest

	// DeleteMonitorExecute executes the request
	DeleteMonitorExecute(r ApiDeleteMonitorRequest) (*http.Response, error)

	/*
		GetAllMonitors List monitors

		List all available monitor in the system

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetAllMonitorsRequest
	*/
	GetAllMonitors(ctx context.Context) ApiGetAllMonitorsRequest

	// GetAllMonitorsExecute executes the request
	//  @return MonitorList
	GetAllMonitorsExecute(r ApiGetAllMonitorsRequest) (*MonitorList, *http.Response, error)

	/*
		GetMonitor Get a monitor

		Returns a monitor full representation

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorIdOrUrn The id or identifier (urn) of a monitor
		@return ApiGetMonitorRequest
	*/
	GetMonitor(ctx context.Context, monitorIdOrUrn string) ApiGetMonitorRequest

	// GetMonitorExecute executes the request
	//  @return Monitor
	GetMonitorExecute(r ApiGetMonitorRequest) (*Monitor, *http.Response, error)

	/*
		GetMonitorWithStatus Get a monitor with stream information

		Returns a monitor full representation with the stream status information

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorIdOrUrn The id or identifier (urn) of a monitor
		@return ApiGetMonitorWithStatusRequest
	*/
	GetMonitorWithStatus(ctx context.Context, monitorIdOrUrn string) ApiGetMonitorWithStatusRequest

	// GetMonitorWithStatusExecute executes the request
	//  @return MonitorStatus
	GetMonitorWithStatusExecute(r ApiGetMonitorWithStatusRequest) (*MonitorStatus, *http.Response, error)

	/*
		GetMonitorsOverview List monitors overview

		List all available monitor in the system with their function and runtime data

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetMonitorsOverviewRequest
	*/
	GetMonitorsOverview(ctx context.Context) ApiGetMonitorsOverviewRequest

	// GetMonitorsOverviewExecute executes the request
	//  @return MonitorOverviewList
	GetMonitorsOverviewExecute(r ApiGetMonitorsOverviewRequest) (*MonitorOverviewList, *http.Response, error)

	/*
		LookupIdentifier Multiple component identifier lookup

		Find identifier templates using a component type and a metrics query

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiLookupIdentifierRequest
	*/
	LookupIdentifier(ctx context.Context) ApiLookupIdentifierRequest

	// LookupIdentifierExecute executes the request
	//  @return MonitorIdentifierSuggestions
	LookupIdentifierExecute(r ApiLookupIdentifierRequest) (*MonitorIdentifierSuggestions, *http.Response, error)

	/*
		PatchMonitor Update some monitor properties

		Performs a patch on the monitor base properties.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorIdOrUrn The id or identifier (urn) of a monitor
		@return ApiPatchMonitorRequest
	*/
	PatchMonitor(ctx context.Context, monitorIdOrUrn string) ApiPatchMonitorRequest

	// PatchMonitorExecute executes the request
	//  @return Monitor
	PatchMonitorExecute(r ApiPatchMonitorRequest) (*Monitor, *http.Response, error)

	/*
		PreviewMonitor Preview a monitor

		Performs a run of a monitor allowing to test it with new arguments and delivers a summary of the health states produced

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorIdOrUrn The id or identifier (urn) of a monitor
		@return ApiPreviewMonitorRequest
	*/
	PreviewMonitor(ctx context.Context, monitorIdOrUrn string) ApiPreviewMonitorRequest

	// PreviewMonitorExecute executes the request
	//  @return MonitorPreviewResult
	PreviewMonitorExecute(r ApiPreviewMonitorRequest) (*MonitorPreviewResult, *http.Response, error)

	/*
		PublishHealthStates Post monitor health states

		Publish health states for monitor

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorIdOrUrn The id or identifier (urn) of a monitor
		@return ApiPublishHealthStatesRequest
	*/
	PublishHealthStates(ctx context.Context, monitorIdOrUrn string) ApiPublishHealthStatesRequest

	// PublishHealthStatesExecute executes the request
	PublishHealthStatesExecute(r ApiPublishHealthStatesRequest) (*http.Response, error)

	/*
		RunMonitor Run a monitor

		Performs a run of a monitor. If 'dryRun' is set, topology state will not be modified.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorIdOrUrn The id or identifier (urn) of a monitor
		@return ApiRunMonitorRequest
	*/
	RunMonitor(ctx context.Context, monitorIdOrUrn string) ApiRunMonitorRequest

	// RunMonitorExecute executes the request
	//  @return MonitorRunResult
	RunMonitorExecute(r ApiRunMonitorRequest) (*MonitorRunResult, *http.Response, error)

	/*
		TestMonitorFunction Test a monitor

		Performs a run of a monitor function to test arguments and delivers a summary of the health states produced

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorFunctionIdOrUrn The id or identifier (urn) of a monitor function
		@return ApiTestMonitorFunctionRequest
	*/
	TestMonitorFunction(ctx context.Context, monitorFunctionIdOrUrn string) ApiTestMonitorFunctionRequest

	// TestMonitorFunctionExecute executes the request
	//  @return MonitorPreviewResult
	TestMonitorFunctionExecute(r ApiTestMonitorFunctionRequest) (*MonitorPreviewResult, *http.Response, error)
}

// MonitorAPIService MonitorAPI service
type MonitorAPIService service

type ApiDeleteMonitorRequest struct {
	ctx            context.Context
	ApiService     MonitorAPI
	monitorIdOrUrn string
}

func (r ApiDeleteMonitorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteMonitorExecute(r)
}

/*
DeleteMonitor Delete a monitor

Deletes existing monitor

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param monitorIdOrUrn The id or identifier (urn) of a monitor
	@return ApiDeleteMonitorRequest
*/
func (a *MonitorAPIService) DeleteMonitor(ctx context.Context, monitorIdOrUrn string) ApiDeleteMonitorRequest {
	return ApiDeleteMonitorRequest{
		ApiService:     a,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

// Execute executes the request
func (a *MonitorAPIService) DeleteMonitorExecute(r ApiDeleteMonitorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorAPIService.DeleteMonitor")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorIdOrUrn}"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllMonitorsRequest struct {
	ctx        context.Context
	ApiService MonitorAPI
}

func (r ApiGetAllMonitorsRequest) Execute() (*MonitorList, *http.Response, error) {
	return r.ApiService.GetAllMonitorsExecute(r)
}

/*
GetAllMonitors List monitors

List all available monitor in the system

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAllMonitorsRequest
*/
func (a *MonitorAPIService) GetAllMonitors(ctx context.Context) ApiGetAllMonitorsRequest {
	return ApiGetAllMonitorsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MonitorList
func (a *MonitorAPIService) GetAllMonitorsExecute(r ApiGetAllMonitorsRequest) (*MonitorList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorAPIService.GetAllMonitors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMonitorRequest struct {
	ctx            context.Context
	ApiService     MonitorAPI
	monitorIdOrUrn string
}

func (r ApiGetMonitorRequest) Execute() (*Monitor, *http.Response, error) {
	return r.ApiService.GetMonitorExecute(r)
}

/*
GetMonitor Get a monitor

Returns a monitor full representation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param monitorIdOrUrn The id or identifier (urn) of a monitor
	@return ApiGetMonitorRequest
*/
func (a *MonitorAPIService) GetMonitor(ctx context.Context, monitorIdOrUrn string) ApiGetMonitorRequest {
	return ApiGetMonitorRequest{
		ApiService:     a,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

// Execute executes the request
//
//	@return Monitor
func (a *MonitorAPIService) GetMonitorExecute(r ApiGetMonitorRequest) (*Monitor, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Monitor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorAPIService.GetMonitor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorIdOrUrn}"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMonitorWithStatusRequest struct {
	ctx            context.Context
	ApiService     MonitorAPI
	monitorIdOrUrn string
}

func (r ApiGetMonitorWithStatusRequest) Execute() (*MonitorStatus, *http.Response, error) {
	return r.ApiService.GetMonitorWithStatusExecute(r)
}

/*
GetMonitorWithStatus Get a monitor with stream information

Returns a monitor full representation with the stream status information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param monitorIdOrUrn The id or identifier (urn) of a monitor
	@return ApiGetMonitorWithStatusRequest
*/
func (a *MonitorAPIService) GetMonitorWithStatus(ctx context.Context, monitorIdOrUrn string) ApiGetMonitorWithStatusRequest {
	return ApiGetMonitorWithStatusRequest{
		ApiService:     a,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

// Execute executes the request
//
//	@return MonitorStatus
func (a *MonitorAPIService) GetMonitorWithStatusExecute(r ApiGetMonitorWithStatusRequest) (*MonitorStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorAPIService.GetMonitorWithStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorIdOrUrn}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMonitorsOverviewRequest struct {
	ctx        context.Context
	ApiService MonitorAPI
}

func (r ApiGetMonitorsOverviewRequest) Execute() (*MonitorOverviewList, *http.Response, error) {
	return r.ApiService.GetMonitorsOverviewExecute(r)
}

/*
GetMonitorsOverview List monitors overview

List all available monitor in the system with their function and runtime data

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMonitorsOverviewRequest
*/
func (a *MonitorAPIService) GetMonitorsOverview(ctx context.Context) ApiGetMonitorsOverviewRequest {
	return ApiGetMonitorsOverviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MonitorOverviewList
func (a *MonitorAPIService) GetMonitorsOverviewExecute(r ApiGetMonitorsOverviewRequest) (*MonitorOverviewList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorOverviewList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorAPIService.GetMonitorsOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/overview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLookupIdentifierRequest struct {
	ctx                     context.Context
	ApiService              MonitorAPI
	monitorIdentifierLookup *MonitorIdentifierLookup
}

// Component type and metric query for identifier lookup
func (r ApiLookupIdentifierRequest) MonitorIdentifierLookup(monitorIdentifierLookup MonitorIdentifierLookup) ApiLookupIdentifierRequest {
	r.monitorIdentifierLookup = &monitorIdentifierLookup
	return r
}

func (r ApiLookupIdentifierRequest) Execute() (*MonitorIdentifierSuggestions, *http.Response, error) {
	return r.ApiService.LookupIdentifierExecute(r)
}

/*
LookupIdentifier Multiple component identifier lookup

Find identifier templates using a component type and a metrics query

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLookupIdentifierRequest
*/
func (a *MonitorAPIService) LookupIdentifier(ctx context.Context) ApiLookupIdentifierRequest {
	return ApiLookupIdentifierRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MonitorIdentifierSuggestions
func (a *MonitorAPIService) LookupIdentifierExecute(r ApiLookupIdentifierRequest) (*MonitorIdentifierSuggestions, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorIdentifierSuggestions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorAPIService.LookupIdentifier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/identifierLookup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.monitorIdentifierLookup == nil {
		return localVarReturnValue, nil, reportError("monitorIdentifierLookup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.monitorIdentifierLookup
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchMonitorRequest struct {
	ctx            context.Context
	ApiService     MonitorAPI
	monitorIdOrUrn string
	monitorPatch   *MonitorPatch
}

// Monitor base properties
func (r ApiPatchMonitorRequest) MonitorPatch(monitorPatch MonitorPatch) ApiPatchMonitorRequest {
	r.monitorPatch = &monitorPatch
	return r
}

func (r ApiPatchMonitorRequest) Execute() (*Monitor, *http.Response, error) {
	return r.ApiService.PatchMonitorExecute(r)
}

/*
PatchMonitor Update some monitor properties

Performs a patch on the monitor base properties.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param monitorIdOrUrn The id or identifier (urn) of a monitor
	@return ApiPatchMonitorRequest
*/
func (a *MonitorAPIService) PatchMonitor(ctx context.Context, monitorIdOrUrn string) ApiPatchMonitorRequest {
	return ApiPatchMonitorRequest{
		ApiService:     a,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

// Execute executes the request
//
//	@return Monitor
func (a *MonitorAPIService) PatchMonitorExecute(r ApiPatchMonitorRequest) (*Monitor, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Monitor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorAPIService.PatchMonitor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorIdOrUrn}"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.monitorPatch == nil {
		return localVarReturnValue, nil, reportError("monitorPatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.monitorPatch
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MonitorValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPreviewMonitorRequest struct {
	ctx            context.Context
	ApiService     MonitorAPI
	monitorIdOrUrn string
	monitorPreview *MonitorPreview
}

// Monitor overrides in order to run a preview
func (r ApiPreviewMonitorRequest) MonitorPreview(monitorPreview MonitorPreview) ApiPreviewMonitorRequest {
	r.monitorPreview = &monitorPreview
	return r
}

func (r ApiPreviewMonitorRequest) Execute() (*MonitorPreviewResult, *http.Response, error) {
	return r.ApiService.PreviewMonitorExecute(r)
}

/*
PreviewMonitor Preview a monitor

Performs a run of a monitor allowing to test it with new arguments and delivers a summary of the health states produced

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param monitorIdOrUrn The id or identifier (urn) of a monitor
	@return ApiPreviewMonitorRequest
*/
func (a *MonitorAPIService) PreviewMonitor(ctx context.Context, monitorIdOrUrn string) ApiPreviewMonitorRequest {
	return ApiPreviewMonitorRequest{
		ApiService:     a,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

// Execute executes the request
//
//	@return MonitorPreviewResult
func (a *MonitorAPIService) PreviewMonitorExecute(r ApiPreviewMonitorRequest) (*MonitorPreviewResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorPreviewResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorAPIService.PreviewMonitor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorIdOrUrn}/preview"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.monitorPreview == nil {
		return localVarReturnValue, nil, reportError("monitorPreview is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.monitorPreview
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishHealthStatesRequest struct {
	ctx             context.Context
	ApiService      MonitorAPI
	monitorIdOrUrn  string
	monitorSnapshot *MonitorSnapshot
}

// Monitor snapshot of health states
func (r ApiPublishHealthStatesRequest) MonitorSnapshot(monitorSnapshot MonitorSnapshot) ApiPublishHealthStatesRequest {
	r.monitorSnapshot = &monitorSnapshot
	return r
}

func (r ApiPublishHealthStatesRequest) Execute() (*http.Response, error) {
	return r.ApiService.PublishHealthStatesExecute(r)
}

/*
PublishHealthStates Post monitor health states

Publish health states for monitor

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param monitorIdOrUrn The id or identifier (urn) of a monitor
	@return ApiPublishHealthStatesRequest
*/
func (a *MonitorAPIService) PublishHealthStates(ctx context.Context, monitorIdOrUrn string) ApiPublishHealthStatesRequest {
	return ApiPublishHealthStatesRequest{
		ApiService:     a,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

// Execute executes the request
func (a *MonitorAPIService) PublishHealthStatesExecute(r ApiPublishHealthStatesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorAPIService.PublishHealthStates")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorIdOrUrn}/publish"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.monitorSnapshot == nil {
		return nil, reportError("monitorSnapshot is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.monitorSnapshot
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRunMonitorRequest struct {
	ctx            context.Context
	ApiService     MonitorAPI
	monitorIdOrUrn string
	dryRun         *bool
}

// If set, the topology state will not be modified
func (r ApiRunMonitorRequest) DryRun(dryRun bool) ApiRunMonitorRequest {
	r.dryRun = &dryRun
	return r
}

func (r ApiRunMonitorRequest) Execute() (*MonitorRunResult, *http.Response, error) {
	return r.ApiService.RunMonitorExecute(r)
}

/*
RunMonitor Run a monitor

Performs a run of a monitor. If 'dryRun' is set, topology state will not be modified.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param monitorIdOrUrn The id or identifier (urn) of a monitor
	@return ApiRunMonitorRequest
*/
func (a *MonitorAPIService) RunMonitor(ctx context.Context, monitorIdOrUrn string) ApiRunMonitorRequest {
	return ApiRunMonitorRequest{
		ApiService:     a,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

// Execute executes the request
//
//	@return MonitorRunResult
func (a *MonitorAPIService) RunMonitorExecute(r ApiRunMonitorRequest) (*MonitorRunResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorRunResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorAPIService.RunMonitor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorIdOrUrn}/run"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestMonitorFunctionRequest struct {
	ctx                    context.Context
	ApiService             MonitorAPI
	monitorFunctionIdOrUrn string
	monitorFunctionTest    *MonitorFunctionTest
}

// Monitor function arguments to test
func (r ApiTestMonitorFunctionRequest) MonitorFunctionTest(monitorFunctionTest MonitorFunctionTest) ApiTestMonitorFunctionRequest {
	r.monitorFunctionTest = &monitorFunctionTest
	return r
}

func (r ApiTestMonitorFunctionRequest) Execute() (*MonitorPreviewResult, *http.Response, error) {
	return r.ApiService.TestMonitorFunctionExecute(r)
}

/*
TestMonitorFunction Test a monitor

Performs a run of a monitor function to test arguments and delivers a summary of the health states produced

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param monitorFunctionIdOrUrn The id or identifier (urn) of a monitor function
	@return ApiTestMonitorFunctionRequest
*/
func (a *MonitorAPIService) TestMonitorFunction(ctx context.Context, monitorFunctionIdOrUrn string) ApiTestMonitorFunctionRequest {
	return ApiTestMonitorFunctionRequest{
		ApiService:             a,
		ctx:                    ctx,
		monitorFunctionIdOrUrn: monitorFunctionIdOrUrn,
	}
}

// Execute executes the request
//
//	@return MonitorPreviewResult
func (a *MonitorAPIService) TestMonitorFunctionExecute(r ApiTestMonitorFunctionRequest) (*MonitorPreviewResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorPreviewResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorAPIService.TestMonitorFunction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorFunctionIdOrUrn}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorFunctionIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorFunctionIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.monitorFunctionTest == nil {
		return localVarReturnValue, nil, reportError("monitorFunctionTest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.monitorFunctionTest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorFunctionNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ---------------------------------------------
// ------------------ MOCKS --------------------
// ---------------------------------------------

type MonitorAPIMock struct {
	DeleteMonitorCalls           *[]DeleteMonitorCall
	DeleteMonitorResponse        DeleteMonitorMockResponse
	GetAllMonitorsCalls          *[]GetAllMonitorsCall
	GetAllMonitorsResponse       GetAllMonitorsMockResponse
	GetMonitorCalls              *[]GetMonitorCall
	GetMonitorResponse           GetMonitorMockResponse
	GetMonitorWithStatusCalls    *[]GetMonitorWithStatusCall
	GetMonitorWithStatusResponse GetMonitorWithStatusMockResponse
	GetMonitorsOverviewCalls     *[]GetMonitorsOverviewCall
	GetMonitorsOverviewResponse  GetMonitorsOverviewMockResponse
	LookupIdentifierCalls        *[]LookupIdentifierCall
	LookupIdentifierResponse     LookupIdentifierMockResponse
	PatchMonitorCalls            *[]PatchMonitorCall
	PatchMonitorResponse         PatchMonitorMockResponse
	PreviewMonitorCalls          *[]PreviewMonitorCall
	PreviewMonitorResponse       PreviewMonitorMockResponse
	PublishHealthStatesCalls     *[]PublishHealthStatesCall
	PublishHealthStatesResponse  PublishHealthStatesMockResponse
	RunMonitorCalls              *[]RunMonitorCall
	RunMonitorResponse           RunMonitorMockResponse
	TestMonitorFunctionCalls     *[]TestMonitorFunctionCall
	TestMonitorFunctionResponse  TestMonitorFunctionMockResponse
}

func NewMonitorAPIMock() MonitorAPIMock {
	xDeleteMonitorCalls := make([]DeleteMonitorCall, 0)
	xGetAllMonitorsCalls := make([]GetAllMonitorsCall, 0)
	xGetMonitorCalls := make([]GetMonitorCall, 0)
	xGetMonitorWithStatusCalls := make([]GetMonitorWithStatusCall, 0)
	xGetMonitorsOverviewCalls := make([]GetMonitorsOverviewCall, 0)
	xLookupIdentifierCalls := make([]LookupIdentifierCall, 0)
	xPatchMonitorCalls := make([]PatchMonitorCall, 0)
	xPreviewMonitorCalls := make([]PreviewMonitorCall, 0)
	xPublishHealthStatesCalls := make([]PublishHealthStatesCall, 0)
	xRunMonitorCalls := make([]RunMonitorCall, 0)
	xTestMonitorFunctionCalls := make([]TestMonitorFunctionCall, 0)
	return MonitorAPIMock{
		DeleteMonitorCalls:        &xDeleteMonitorCalls,
		GetAllMonitorsCalls:       &xGetAllMonitorsCalls,
		GetMonitorCalls:           &xGetMonitorCalls,
		GetMonitorWithStatusCalls: &xGetMonitorWithStatusCalls,
		GetMonitorsOverviewCalls:  &xGetMonitorsOverviewCalls,
		LookupIdentifierCalls:     &xLookupIdentifierCalls,
		PatchMonitorCalls:         &xPatchMonitorCalls,
		PreviewMonitorCalls:       &xPreviewMonitorCalls,
		PublishHealthStatesCalls:  &xPublishHealthStatesCalls,
		RunMonitorCalls:           &xRunMonitorCalls,
		TestMonitorFunctionCalls:  &xTestMonitorFunctionCalls,
	}
}

type DeleteMonitorMockResponse struct {
	Response *http.Response
	Error    error
}

type DeleteMonitorCall struct {
	PmonitorIdOrUrn string
}

func (mock MonitorAPIMock) DeleteMonitor(ctx context.Context, monitorIdOrUrn string) ApiDeleteMonitorRequest {
	return ApiDeleteMonitorRequest{
		ApiService:     mock,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

func (mock MonitorAPIMock) DeleteMonitorExecute(r ApiDeleteMonitorRequest) (*http.Response, error) {
	p := DeleteMonitorCall{
		PmonitorIdOrUrn: r.monitorIdOrUrn,
	}
	*mock.DeleteMonitorCalls = append(*mock.DeleteMonitorCalls, p)
	return mock.DeleteMonitorResponse.Response, mock.DeleteMonitorResponse.Error
}

type GetAllMonitorsMockResponse struct {
	Result   MonitorList
	Response *http.Response
	Error    error
}

type GetAllMonitorsCall struct {
}

func (mock MonitorAPIMock) GetAllMonitors(ctx context.Context) ApiGetAllMonitorsRequest {
	return ApiGetAllMonitorsRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock MonitorAPIMock) GetAllMonitorsExecute(r ApiGetAllMonitorsRequest) (*MonitorList, *http.Response, error) {
	p := GetAllMonitorsCall{}
	*mock.GetAllMonitorsCalls = append(*mock.GetAllMonitorsCalls, p)
	return &mock.GetAllMonitorsResponse.Result, mock.GetAllMonitorsResponse.Response, mock.GetAllMonitorsResponse.Error
}

type GetMonitorMockResponse struct {
	Result   Monitor
	Response *http.Response
	Error    error
}

type GetMonitorCall struct {
	PmonitorIdOrUrn string
}

func (mock MonitorAPIMock) GetMonitor(ctx context.Context, monitorIdOrUrn string) ApiGetMonitorRequest {
	return ApiGetMonitorRequest{
		ApiService:     mock,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

func (mock MonitorAPIMock) GetMonitorExecute(r ApiGetMonitorRequest) (*Monitor, *http.Response, error) {
	p := GetMonitorCall{
		PmonitorIdOrUrn: r.monitorIdOrUrn,
	}
	*mock.GetMonitorCalls = append(*mock.GetMonitorCalls, p)
	return &mock.GetMonitorResponse.Result, mock.GetMonitorResponse.Response, mock.GetMonitorResponse.Error
}

type GetMonitorWithStatusMockResponse struct {
	Result   MonitorStatus
	Response *http.Response
	Error    error
}

type GetMonitorWithStatusCall struct {
	PmonitorIdOrUrn string
}

func (mock MonitorAPIMock) GetMonitorWithStatus(ctx context.Context, monitorIdOrUrn string) ApiGetMonitorWithStatusRequest {
	return ApiGetMonitorWithStatusRequest{
		ApiService:     mock,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

func (mock MonitorAPIMock) GetMonitorWithStatusExecute(r ApiGetMonitorWithStatusRequest) (*MonitorStatus, *http.Response, error) {
	p := GetMonitorWithStatusCall{
		PmonitorIdOrUrn: r.monitorIdOrUrn,
	}
	*mock.GetMonitorWithStatusCalls = append(*mock.GetMonitorWithStatusCalls, p)
	return &mock.GetMonitorWithStatusResponse.Result, mock.GetMonitorWithStatusResponse.Response, mock.GetMonitorWithStatusResponse.Error
}

type GetMonitorsOverviewMockResponse struct {
	Result   MonitorOverviewList
	Response *http.Response
	Error    error
}

type GetMonitorsOverviewCall struct {
}

func (mock MonitorAPIMock) GetMonitorsOverview(ctx context.Context) ApiGetMonitorsOverviewRequest {
	return ApiGetMonitorsOverviewRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock MonitorAPIMock) GetMonitorsOverviewExecute(r ApiGetMonitorsOverviewRequest) (*MonitorOverviewList, *http.Response, error) {
	p := GetMonitorsOverviewCall{}
	*mock.GetMonitorsOverviewCalls = append(*mock.GetMonitorsOverviewCalls, p)
	return &mock.GetMonitorsOverviewResponse.Result, mock.GetMonitorsOverviewResponse.Response, mock.GetMonitorsOverviewResponse.Error
}

type LookupIdentifierMockResponse struct {
	Result   MonitorIdentifierSuggestions
	Response *http.Response
	Error    error
}

type LookupIdentifierCall struct {
	PmonitorIdentifierLookup *MonitorIdentifierLookup
}

func (mock MonitorAPIMock) LookupIdentifier(ctx context.Context) ApiLookupIdentifierRequest {
	return ApiLookupIdentifierRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock MonitorAPIMock) LookupIdentifierExecute(r ApiLookupIdentifierRequest) (*MonitorIdentifierSuggestions, *http.Response, error) {
	p := LookupIdentifierCall{
		PmonitorIdentifierLookup: r.monitorIdentifierLookup,
	}
	*mock.LookupIdentifierCalls = append(*mock.LookupIdentifierCalls, p)
	return &mock.LookupIdentifierResponse.Result, mock.LookupIdentifierResponse.Response, mock.LookupIdentifierResponse.Error
}

type PatchMonitorMockResponse struct {
	Result   Monitor
	Response *http.Response
	Error    error
}

type PatchMonitorCall struct {
	PmonitorIdOrUrn string
	PmonitorPatch   *MonitorPatch
}

func (mock MonitorAPIMock) PatchMonitor(ctx context.Context, monitorIdOrUrn string) ApiPatchMonitorRequest {
	return ApiPatchMonitorRequest{
		ApiService:     mock,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

func (mock MonitorAPIMock) PatchMonitorExecute(r ApiPatchMonitorRequest) (*Monitor, *http.Response, error) {
	p := PatchMonitorCall{
		PmonitorIdOrUrn: r.monitorIdOrUrn,
		PmonitorPatch:   r.monitorPatch,
	}
	*mock.PatchMonitorCalls = append(*mock.PatchMonitorCalls, p)
	return &mock.PatchMonitorResponse.Result, mock.PatchMonitorResponse.Response, mock.PatchMonitorResponse.Error
}

type PreviewMonitorMockResponse struct {
	Result   MonitorPreviewResult
	Response *http.Response
	Error    error
}

type PreviewMonitorCall struct {
	PmonitorIdOrUrn string
	PmonitorPreview *MonitorPreview
}

func (mock MonitorAPIMock) PreviewMonitor(ctx context.Context, monitorIdOrUrn string) ApiPreviewMonitorRequest {
	return ApiPreviewMonitorRequest{
		ApiService:     mock,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

func (mock MonitorAPIMock) PreviewMonitorExecute(r ApiPreviewMonitorRequest) (*MonitorPreviewResult, *http.Response, error) {
	p := PreviewMonitorCall{
		PmonitorIdOrUrn: r.monitorIdOrUrn,
		PmonitorPreview: r.monitorPreview,
	}
	*mock.PreviewMonitorCalls = append(*mock.PreviewMonitorCalls, p)
	return &mock.PreviewMonitorResponse.Result, mock.PreviewMonitorResponse.Response, mock.PreviewMonitorResponse.Error
}

type PublishHealthStatesMockResponse struct {
	Response *http.Response
	Error    error
}

type PublishHealthStatesCall struct {
	PmonitorIdOrUrn  string
	PmonitorSnapshot *MonitorSnapshot
}

func (mock MonitorAPIMock) PublishHealthStates(ctx context.Context, monitorIdOrUrn string) ApiPublishHealthStatesRequest {
	return ApiPublishHealthStatesRequest{
		ApiService:     mock,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

func (mock MonitorAPIMock) PublishHealthStatesExecute(r ApiPublishHealthStatesRequest) (*http.Response, error) {
	p := PublishHealthStatesCall{
		PmonitorIdOrUrn:  r.monitorIdOrUrn,
		PmonitorSnapshot: r.monitorSnapshot,
	}
	*mock.PublishHealthStatesCalls = append(*mock.PublishHealthStatesCalls, p)
	return mock.PublishHealthStatesResponse.Response, mock.PublishHealthStatesResponse.Error
}

type RunMonitorMockResponse struct {
	Result   MonitorRunResult
	Response *http.Response
	Error    error
}

type RunMonitorCall struct {
	PmonitorIdOrUrn string
	PdryRun         *bool
}

func (mock MonitorAPIMock) RunMonitor(ctx context.Context, monitorIdOrUrn string) ApiRunMonitorRequest {
	return ApiRunMonitorRequest{
		ApiService:     mock,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

func (mock MonitorAPIMock) RunMonitorExecute(r ApiRunMonitorRequest) (*MonitorRunResult, *http.Response, error) {
	p := RunMonitorCall{
		PmonitorIdOrUrn: r.monitorIdOrUrn,
		PdryRun:         r.dryRun,
	}
	*mock.RunMonitorCalls = append(*mock.RunMonitorCalls, p)
	return &mock.RunMonitorResponse.Result, mock.RunMonitorResponse.Response, mock.RunMonitorResponse.Error
}

type TestMonitorFunctionMockResponse struct {
	Result   MonitorPreviewResult
	Response *http.Response
	Error    error
}

type TestMonitorFunctionCall struct {
	PmonitorFunctionIdOrUrn string
	PmonitorFunctionTest    *MonitorFunctionTest
}

func (mock MonitorAPIMock) TestMonitorFunction(ctx context.Context, monitorFunctionIdOrUrn string) ApiTestMonitorFunctionRequest {
	return ApiTestMonitorFunctionRequest{
		ApiService:             mock,
		ctx:                    ctx,
		monitorFunctionIdOrUrn: monitorFunctionIdOrUrn,
	}
}

func (mock MonitorAPIMock) TestMonitorFunctionExecute(r ApiTestMonitorFunctionRequest) (*MonitorPreviewResult, *http.Response, error) {
	p := TestMonitorFunctionCall{
		PmonitorFunctionIdOrUrn: r.monitorFunctionIdOrUrn,
		PmonitorFunctionTest:    r.monitorFunctionTest,
	}
	*mock.TestMonitorFunctionCalls = append(*mock.TestMonitorFunctionCalls, p)
	return &mock.TestMonitorFunctionResponse.Result, mock.TestMonitorFunctionResponse.Response, mock.TestMonitorFunctionResponse.Error
}
