/*
StackState API

This API documentation page describes the StackState server API. The StackState UI and CLI use the StackState server API to configure and query StackState.  You can use the API for similar purposes.  Each request sent to the StackState server API must be authenticated using one of the available authentication methods.   *Note that the StackState receiver API, used to send topology, telemetry and traces to StackState, is not described on this page and requires a different authentication method.*  For more information on StackState, refer to the [StackState documentation](https://docs.stackstate.com).

API version: 5.2.0
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackstate_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

type MonitorApi interface {

	/*
		DeleteMonitor Delete a monitor

		Deletes existing monitor

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorIdOrUrn The id or identifier (urn) of a monitor
		@return ApiDeleteMonitorRequest
	*/
	DeleteMonitor(ctx context.Context, monitorIdOrUrn string) ApiDeleteMonitorRequest

	// DeleteMonitorExecute executes the request
	DeleteMonitorExecute(r ApiDeleteMonitorRequest) (*http.Response, error)

	/*
		GetAllMonitors List monitors

		List all available monitor in the system

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetAllMonitorsRequest
	*/
	GetAllMonitors(ctx context.Context) ApiGetAllMonitorsRequest

	// GetAllMonitorsExecute executes the request
	//  @return MonitorList
	GetAllMonitorsExecute(r ApiGetAllMonitorsRequest) (*MonitorList, *http.Response, error)

	/*
		GetMonitor Get a monitor

		Returns a monitor full representation

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorIdOrUrn The id or identifier (urn) of a monitor
		@return ApiGetMonitorRequest
	*/
	GetMonitor(ctx context.Context, monitorIdOrUrn string) ApiGetMonitorRequest

	// GetMonitorExecute executes the request
	//  @return Monitor
	GetMonitorExecute(r ApiGetMonitorRequest) (*Monitor, *http.Response, error)

	/*
		GetMonitorCheckStates Get the check states for a monitor

		Returns the checkstates that a monitor generated

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorIdOrUrn The id or identifier (urn) of a monitor
		@return ApiGetMonitorCheckStatesRequest
	*/
	GetMonitorCheckStates(ctx context.Context, monitorIdOrUrn string) ApiGetMonitorCheckStatesRequest

	// GetMonitorCheckStatesExecute executes the request
	//  @return MonitorCheckStates
	GetMonitorCheckStatesExecute(r ApiGetMonitorCheckStatesRequest) (*MonitorCheckStates, *http.Response, error)

	/*
		GetMonitorWithStatus Get a monitor with stream information

		Returns a monitor full representation with the stream status information

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorIdOrUrn The id or identifier (urn) of a monitor
		@return ApiGetMonitorWithStatusRequest
	*/
	GetMonitorWithStatus(ctx context.Context, monitorIdOrUrn string) ApiGetMonitorWithStatusRequest

	// GetMonitorWithStatusExecute executes the request
	//  @return MonitorStatus
	GetMonitorWithStatusExecute(r ApiGetMonitorWithStatusRequest) (*MonitorStatus, *http.Response, error)

	/*
		GetMonitorsOverview List monitors overview

		List all available monitor in the system with their function and runtime data

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetMonitorsOverviewRequest
	*/
	GetMonitorsOverview(ctx context.Context) ApiGetMonitorsOverviewRequest

	// GetMonitorsOverviewExecute executes the request
	//  @return MonitorOverviewList
	GetMonitorsOverviewExecute(r ApiGetMonitorsOverviewRequest) (*MonitorOverviewList, *http.Response, error)

	/*
		LookupIdentifier Multiple component identifier lookup

		Find identifier templates using a component type and a metrics query

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiLookupIdentifierRequest
	*/
	LookupIdentifier(ctx context.Context) ApiLookupIdentifierRequest

	// LookupIdentifierExecute executes the request
	//  @return MonitorIdentifierSuggestions
	LookupIdentifierExecute(r ApiLookupIdentifierRequest) (*MonitorIdentifierSuggestions, *http.Response, error)

	/*
		PatchMonitor Update some monitor properties

		Performs a patch on the monitor base properties.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorIdOrUrn The id or identifier (urn) of a monitor
		@return ApiPatchMonitorRequest
	*/
	PatchMonitor(ctx context.Context, monitorIdOrUrn string) ApiPatchMonitorRequest

	// PatchMonitorExecute executes the request
	//  @return Monitor
	PatchMonitorExecute(r ApiPatchMonitorRequest) (*Monitor, *http.Response, error)

	/*
		PreviewMonitor Preview a monitor

		Performs a run of a monitor allowing to test it with new arguments and delivers a summary of the health states produced

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorIdOrUrn The id or identifier (urn) of a monitor
		@return ApiPreviewMonitorRequest
	*/
	PreviewMonitor(ctx context.Context, monitorIdOrUrn string) ApiPreviewMonitorRequest

	// PreviewMonitorExecute executes the request
	//  @return MonitorPreviewResult
	PreviewMonitorExecute(r ApiPreviewMonitorRequest) (*MonitorPreviewResult, *http.Response, error)

	/*
		PreviewMonitorCheckStates Preview a monitor

		Performs a run of a monitor allowing to test it with new arguments and returns the health states produced

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorIdOrUrn The id or identifier (urn) of a monitor
		@return ApiPreviewMonitorCheckStatesRequest
	*/
	PreviewMonitorCheckStates(ctx context.Context, monitorIdOrUrn string) ApiPreviewMonitorCheckStatesRequest

	// PreviewMonitorCheckStatesExecute executes the request
	//  @return MonitorCheckStates
	PreviewMonitorCheckStatesExecute(r ApiPreviewMonitorCheckStatesRequest) (*MonitorCheckStates, *http.Response, error)

	/*
		PublishHealthStates Post monitor health states

		Publish health states for monitor

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorIdOrUrn The id or identifier (urn) of a monitor
		@return ApiPublishHealthStatesRequest
	*/
	PublishHealthStates(ctx context.Context, monitorIdOrUrn string) ApiPublishHealthStatesRequest

	// PublishHealthStatesExecute executes the request
	PublishHealthStatesExecute(r ApiPublishHealthStatesRequest) (*http.Response, error)

	/*
		RunMonitor Run a monitor

		Performs a run of a monitor. If 'dryRun' is set, topology state will not be modified.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorIdOrUrn The id or identifier (urn) of a monitor
		@return ApiRunMonitorRequest
	*/
	RunMonitor(ctx context.Context, monitorIdOrUrn string) ApiRunMonitorRequest

	// RunMonitorExecute executes the request
	//  @return MonitorRunResult
	RunMonitorExecute(r ApiRunMonitorRequest) (*MonitorRunResult, *http.Response, error)

	/*
		TestMonitorFunction Test a monitor

		Performs a run of a monitor function to test arguments and delivers a summary of the health states produced

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorFunctionIdOrUrn The id or identifier (urn) of a monitor function
		@return ApiTestMonitorFunctionRequest
	*/
	TestMonitorFunction(ctx context.Context, monitorFunctionIdOrUrn string) ApiTestMonitorFunctionRequest

	// TestMonitorFunctionExecute executes the request
	//  @return MonitorPreviewResult
	TestMonitorFunctionExecute(r ApiTestMonitorFunctionRequest) (*MonitorPreviewResult, *http.Response, error)

	/*
		TestMonitorFunctionCheckStates Test a monitor

		Performs a run of a monitor function to test arguments and returns the health states produced

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param monitorFunctionIdOrUrn The id or identifier (urn) of a monitor function
		@return ApiTestMonitorFunctionCheckStatesRequest
	*/
	TestMonitorFunctionCheckStates(ctx context.Context, monitorFunctionIdOrUrn string) ApiTestMonitorFunctionCheckStatesRequest

	// TestMonitorFunctionCheckStatesExecute executes the request
	//  @return MonitorCheckStates
	TestMonitorFunctionCheckStatesExecute(r ApiTestMonitorFunctionCheckStatesRequest) (*MonitorCheckStates, *http.Response, error)
}

// MonitorApiService MonitorApi service
type MonitorApiService service

type ApiDeleteMonitorRequest struct {
	ctx            context.Context
	ApiService     MonitorApi
	monitorIdOrUrn string
}

func (r ApiDeleteMonitorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteMonitorExecute(r)
}

/*
DeleteMonitor Delete a monitor

Deletes existing monitor

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorIdOrUrn The id or identifier (urn) of a monitor
 @return ApiDeleteMonitorRequest
*/
func (a *MonitorApiService) DeleteMonitor(ctx context.Context, monitorIdOrUrn string) ApiDeleteMonitorRequest {
	return ApiDeleteMonitorRequest{
		ApiService:     a,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

// Execute executes the request
func (a *MonitorApiService) DeleteMonitorExecute(r ApiDeleteMonitorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.DeleteMonitor")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorIdOrUrn}"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllMonitorsRequest struct {
	ctx        context.Context
	ApiService MonitorApi
}

func (r ApiGetAllMonitorsRequest) Execute() (*MonitorList, *http.Response, error) {
	return r.ApiService.GetAllMonitorsExecute(r)
}

/*
GetAllMonitors List monitors

List all available monitor in the system

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllMonitorsRequest
*/
func (a *MonitorApiService) GetAllMonitors(ctx context.Context) ApiGetAllMonitorsRequest {
	return ApiGetAllMonitorsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return MonitorList
func (a *MonitorApiService) GetAllMonitorsExecute(r ApiGetAllMonitorsRequest) (*MonitorList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.GetAllMonitors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMonitorRequest struct {
	ctx            context.Context
	ApiService     MonitorApi
	monitorIdOrUrn string
}

func (r ApiGetMonitorRequest) Execute() (*Monitor, *http.Response, error) {
	return r.ApiService.GetMonitorExecute(r)
}

/*
GetMonitor Get a monitor

Returns a monitor full representation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorIdOrUrn The id or identifier (urn) of a monitor
 @return ApiGetMonitorRequest
*/
func (a *MonitorApiService) GetMonitor(ctx context.Context, monitorIdOrUrn string) ApiGetMonitorRequest {
	return ApiGetMonitorRequest{
		ApiService:     a,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

// Execute executes the request
//  @return Monitor
func (a *MonitorApiService) GetMonitorExecute(r ApiGetMonitorRequest) (*Monitor, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Monitor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.GetMonitor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorIdOrUrn}"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMonitorCheckStatesRequest struct {
	ctx            context.Context
	ApiService     MonitorApi
	monitorIdOrUrn string
	healthState    *HealthStateValue
	limit          *int32
}

// Health state of check states
func (r ApiGetMonitorCheckStatesRequest) HealthState(healthState HealthStateValue) ApiGetMonitorCheckStatesRequest {
	r.healthState = &healthState
	return r
}

func (r ApiGetMonitorCheckStatesRequest) Limit(limit int32) ApiGetMonitorCheckStatesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetMonitorCheckStatesRequest) Execute() (*MonitorCheckStates, *http.Response, error) {
	return r.ApiService.GetMonitorCheckStatesExecute(r)
}

/*
GetMonitorCheckStates Get the check states for a monitor

Returns the checkstates that a monitor generated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorIdOrUrn The id or identifier (urn) of a monitor
 @return ApiGetMonitorCheckStatesRequest
*/
func (a *MonitorApiService) GetMonitorCheckStates(ctx context.Context, monitorIdOrUrn string) ApiGetMonitorCheckStatesRequest {
	return ApiGetMonitorCheckStatesRequest{
		ApiService:     a,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

// Execute executes the request
//  @return MonitorCheckStates
func (a *MonitorApiService) GetMonitorCheckStatesExecute(r ApiGetMonitorCheckStatesRequest) (*MonitorCheckStates, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorCheckStates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.GetMonitorCheckStates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorIdOrUrn}/checkStates"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.healthState != nil {
		localVarQueryParams.Add("healthState", parameterToString(*r.healthState, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMonitorWithStatusRequest struct {
	ctx            context.Context
	ApiService     MonitorApi
	monitorIdOrUrn string
}

func (r ApiGetMonitorWithStatusRequest) Execute() (*MonitorStatus, *http.Response, error) {
	return r.ApiService.GetMonitorWithStatusExecute(r)
}

/*
GetMonitorWithStatus Get a monitor with stream information

Returns a monitor full representation with the stream status information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorIdOrUrn The id or identifier (urn) of a monitor
 @return ApiGetMonitorWithStatusRequest
*/
func (a *MonitorApiService) GetMonitorWithStatus(ctx context.Context, monitorIdOrUrn string) ApiGetMonitorWithStatusRequest {
	return ApiGetMonitorWithStatusRequest{
		ApiService:     a,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

// Execute executes the request
//  @return MonitorStatus
func (a *MonitorApiService) GetMonitorWithStatusExecute(r ApiGetMonitorWithStatusRequest) (*MonitorStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.GetMonitorWithStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorIdOrUrn}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMonitorsOverviewRequest struct {
	ctx        context.Context
	ApiService MonitorApi
}

func (r ApiGetMonitorsOverviewRequest) Execute() (*MonitorOverviewList, *http.Response, error) {
	return r.ApiService.GetMonitorsOverviewExecute(r)
}

/*
GetMonitorsOverview List monitors overview

List all available monitor in the system with their function and runtime data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMonitorsOverviewRequest
*/
func (a *MonitorApiService) GetMonitorsOverview(ctx context.Context) ApiGetMonitorsOverviewRequest {
	return ApiGetMonitorsOverviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return MonitorOverviewList
func (a *MonitorApiService) GetMonitorsOverviewExecute(r ApiGetMonitorsOverviewRequest) (*MonitorOverviewList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorOverviewList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.GetMonitorsOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/overview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLookupIdentifierRequest struct {
	ctx                     context.Context
	ApiService              MonitorApi
	monitorIdentifierLookup *MonitorIdentifierLookup
}

// Component type and metric query for identifier lookup
func (r ApiLookupIdentifierRequest) MonitorIdentifierLookup(monitorIdentifierLookup MonitorIdentifierLookup) ApiLookupIdentifierRequest {
	r.monitorIdentifierLookup = &monitorIdentifierLookup
	return r
}

func (r ApiLookupIdentifierRequest) Execute() (*MonitorIdentifierSuggestions, *http.Response, error) {
	return r.ApiService.LookupIdentifierExecute(r)
}

/*
LookupIdentifier Multiple component identifier lookup

Find identifier templates using a component type and a metrics query

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLookupIdentifierRequest
*/
func (a *MonitorApiService) LookupIdentifier(ctx context.Context) ApiLookupIdentifierRequest {
	return ApiLookupIdentifierRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return MonitorIdentifierSuggestions
func (a *MonitorApiService) LookupIdentifierExecute(r ApiLookupIdentifierRequest) (*MonitorIdentifierSuggestions, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorIdentifierSuggestions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.LookupIdentifier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/identifierLookup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.monitorIdentifierLookup == nil {
		return localVarReturnValue, nil, reportError("monitorIdentifierLookup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.monitorIdentifierLookup
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchMonitorRequest struct {
	ctx            context.Context
	ApiService     MonitorApi
	monitorIdOrUrn string
	monitorPatch   *MonitorPatch
}

// Monitor base properties
func (r ApiPatchMonitorRequest) MonitorPatch(monitorPatch MonitorPatch) ApiPatchMonitorRequest {
	r.monitorPatch = &monitorPatch
	return r
}

func (r ApiPatchMonitorRequest) Execute() (*Monitor, *http.Response, error) {
	return r.ApiService.PatchMonitorExecute(r)
}

/*
PatchMonitor Update some monitor properties

Performs a patch on the monitor base properties.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorIdOrUrn The id or identifier (urn) of a monitor
 @return ApiPatchMonitorRequest
*/
func (a *MonitorApiService) PatchMonitor(ctx context.Context, monitorIdOrUrn string) ApiPatchMonitorRequest {
	return ApiPatchMonitorRequest{
		ApiService:     a,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

// Execute executes the request
//  @return Monitor
func (a *MonitorApiService) PatchMonitorExecute(r ApiPatchMonitorRequest) (*Monitor, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Monitor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.PatchMonitor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorIdOrUrn}"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.monitorPatch == nil {
		return localVarReturnValue, nil, reportError("monitorPatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.monitorPatch
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v MonitorValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPreviewMonitorRequest struct {
	ctx            context.Context
	ApiService     MonitorApi
	monitorIdOrUrn string
	monitorPreview *MonitorPreview
}

// Monitor overrides in order to run a preview
func (r ApiPreviewMonitorRequest) MonitorPreview(monitorPreview MonitorPreview) ApiPreviewMonitorRequest {
	r.monitorPreview = &monitorPreview
	return r
}

func (r ApiPreviewMonitorRequest) Execute() (*MonitorPreviewResult, *http.Response, error) {
	return r.ApiService.PreviewMonitorExecute(r)
}

/*
PreviewMonitor Preview a monitor

Performs a run of a monitor allowing to test it with new arguments and delivers a summary of the health states produced

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorIdOrUrn The id or identifier (urn) of a monitor
 @return ApiPreviewMonitorRequest
*/
func (a *MonitorApiService) PreviewMonitor(ctx context.Context, monitorIdOrUrn string) ApiPreviewMonitorRequest {
	return ApiPreviewMonitorRequest{
		ApiService:     a,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

// Execute executes the request
//  @return MonitorPreviewResult
func (a *MonitorApiService) PreviewMonitorExecute(r ApiPreviewMonitorRequest) (*MonitorPreviewResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorPreviewResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.PreviewMonitor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorIdOrUrn}/preview"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.monitorPreview == nil {
		return localVarReturnValue, nil, reportError("monitorPreview is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.monitorPreview
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPreviewMonitorCheckStatesRequest struct {
	ctx            context.Context
	ApiService     MonitorApi
	monitorIdOrUrn string
	monitorPreview *MonitorPreview
	healthState    *HealthStateValue
	limit          *int32
}

// Monitor overrides in order to run a preview
func (r ApiPreviewMonitorCheckStatesRequest) MonitorPreview(monitorPreview MonitorPreview) ApiPreviewMonitorCheckStatesRequest {
	r.monitorPreview = &monitorPreview
	return r
}

// Health state of check states
func (r ApiPreviewMonitorCheckStatesRequest) HealthState(healthState HealthStateValue) ApiPreviewMonitorCheckStatesRequest {
	r.healthState = &healthState
	return r
}

func (r ApiPreviewMonitorCheckStatesRequest) Limit(limit int32) ApiPreviewMonitorCheckStatesRequest {
	r.limit = &limit
	return r
}

func (r ApiPreviewMonitorCheckStatesRequest) Execute() (*MonitorCheckStates, *http.Response, error) {
	return r.ApiService.PreviewMonitorCheckStatesExecute(r)
}

/*
PreviewMonitorCheckStates Preview a monitor

Performs a run of a monitor allowing to test it with new arguments and returns the health states produced

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorIdOrUrn The id or identifier (urn) of a monitor
 @return ApiPreviewMonitorCheckStatesRequest
*/
func (a *MonitorApiService) PreviewMonitorCheckStates(ctx context.Context, monitorIdOrUrn string) ApiPreviewMonitorCheckStatesRequest {
	return ApiPreviewMonitorCheckStatesRequest{
		ApiService:     a,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

// Execute executes the request
//  @return MonitorCheckStates
func (a *MonitorApiService) PreviewMonitorCheckStatesExecute(r ApiPreviewMonitorCheckStatesRequest) (*MonitorCheckStates, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorCheckStates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.PreviewMonitorCheckStates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorIdOrUrn}/preview/checkStates"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.monitorPreview == nil {
		return localVarReturnValue, nil, reportError("monitorPreview is required and must be specified")
	}

	if r.healthState != nil {
		localVarQueryParams.Add("healthState", parameterToString(*r.healthState, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.monitorPreview
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishHealthStatesRequest struct {
	ctx             context.Context
	ApiService      MonitorApi
	monitorIdOrUrn  string
	monitorSnapshot *MonitorSnapshot
}

// Monitor snapshot of health states
func (r ApiPublishHealthStatesRequest) MonitorSnapshot(monitorSnapshot MonitorSnapshot) ApiPublishHealthStatesRequest {
	r.monitorSnapshot = &monitorSnapshot
	return r
}

func (r ApiPublishHealthStatesRequest) Execute() (*http.Response, error) {
	return r.ApiService.PublishHealthStatesExecute(r)
}

/*
PublishHealthStates Post monitor health states

Publish health states for monitor

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorIdOrUrn The id or identifier (urn) of a monitor
 @return ApiPublishHealthStatesRequest
*/
func (a *MonitorApiService) PublishHealthStates(ctx context.Context, monitorIdOrUrn string) ApiPublishHealthStatesRequest {
	return ApiPublishHealthStatesRequest{
		ApiService:     a,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

// Execute executes the request
func (a *MonitorApiService) PublishHealthStatesExecute(r ApiPublishHealthStatesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.PublishHealthStates")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorIdOrUrn}/publish"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.monitorSnapshot == nil {
		return nil, reportError("monitorSnapshot is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.monitorSnapshot
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRunMonitorRequest struct {
	ctx            context.Context
	ApiService     MonitorApi
	monitorIdOrUrn string
	dryRun         *bool
}

// If set, the topology state will not be modified
func (r ApiRunMonitorRequest) DryRun(dryRun bool) ApiRunMonitorRequest {
	r.dryRun = &dryRun
	return r
}

func (r ApiRunMonitorRequest) Execute() (*MonitorRunResult, *http.Response, error) {
	return r.ApiService.RunMonitorExecute(r)
}

/*
RunMonitor Run a monitor

Performs a run of a monitor. If 'dryRun' is set, topology state will not be modified.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorIdOrUrn The id or identifier (urn) of a monitor
 @return ApiRunMonitorRequest
*/
func (a *MonitorApiService) RunMonitor(ctx context.Context, monitorIdOrUrn string) ApiRunMonitorRequest {
	return ApiRunMonitorRequest{
		ApiService:     a,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

// Execute executes the request
//  @return MonitorRunResult
func (a *MonitorApiService) RunMonitorExecute(r ApiRunMonitorRequest) (*MonitorRunResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorRunResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.RunMonitor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorIdOrUrn}/run"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestMonitorFunctionRequest struct {
	ctx                    context.Context
	ApiService             MonitorApi
	monitorFunctionIdOrUrn string
	monitorFunctionTest    *MonitorFunctionTest
}

// Monitor function arguments to test
func (r ApiTestMonitorFunctionRequest) MonitorFunctionTest(monitorFunctionTest MonitorFunctionTest) ApiTestMonitorFunctionRequest {
	r.monitorFunctionTest = &monitorFunctionTest
	return r
}

func (r ApiTestMonitorFunctionRequest) Execute() (*MonitorPreviewResult, *http.Response, error) {
	return r.ApiService.TestMonitorFunctionExecute(r)
}

/*
TestMonitorFunction Test a monitor

Performs a run of a monitor function to test arguments and delivers a summary of the health states produced

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorFunctionIdOrUrn The id or identifier (urn) of a monitor function
 @return ApiTestMonitorFunctionRequest
*/
func (a *MonitorApiService) TestMonitorFunction(ctx context.Context, monitorFunctionIdOrUrn string) ApiTestMonitorFunctionRequest {
	return ApiTestMonitorFunctionRequest{
		ApiService:             a,
		ctx:                    ctx,
		monitorFunctionIdOrUrn: monitorFunctionIdOrUrn,
	}
}

// Execute executes the request
//  @return MonitorPreviewResult
func (a *MonitorApiService) TestMonitorFunctionExecute(r ApiTestMonitorFunctionRequest) (*MonitorPreviewResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorPreviewResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.TestMonitorFunction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorFunctionIdOrUrn}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorFunctionIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorFunctionIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.monitorFunctionTest == nil {
		return localVarReturnValue, nil, reportError("monitorFunctionTest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.monitorFunctionTest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorFunctionNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestMonitorFunctionCheckStatesRequest struct {
	ctx                    context.Context
	ApiService             MonitorApi
	monitorFunctionIdOrUrn string
	monitorFunctionTest    *MonitorFunctionTest
	healthState            *HealthStateValue
	limit                  *int32
}

// Monitor function arguments to test
func (r ApiTestMonitorFunctionCheckStatesRequest) MonitorFunctionTest(monitorFunctionTest MonitorFunctionTest) ApiTestMonitorFunctionCheckStatesRequest {
	r.monitorFunctionTest = &monitorFunctionTest
	return r
}

// Health state of check states
func (r ApiTestMonitorFunctionCheckStatesRequest) HealthState(healthState HealthStateValue) ApiTestMonitorFunctionCheckStatesRequest {
	r.healthState = &healthState
	return r
}

func (r ApiTestMonitorFunctionCheckStatesRequest) Limit(limit int32) ApiTestMonitorFunctionCheckStatesRequest {
	r.limit = &limit
	return r
}

func (r ApiTestMonitorFunctionCheckStatesRequest) Execute() (*MonitorCheckStates, *http.Response, error) {
	return r.ApiService.TestMonitorFunctionCheckStatesExecute(r)
}

/*
TestMonitorFunctionCheckStates Test a monitor

Performs a run of a monitor function to test arguments and returns the health states produced

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param monitorFunctionIdOrUrn The id or identifier (urn) of a monitor function
 @return ApiTestMonitorFunctionCheckStatesRequest
*/
func (a *MonitorApiService) TestMonitorFunctionCheckStates(ctx context.Context, monitorFunctionIdOrUrn string) ApiTestMonitorFunctionCheckStatesRequest {
	return ApiTestMonitorFunctionCheckStatesRequest{
		ApiService:             a,
		ctx:                    ctx,
		monitorFunctionIdOrUrn: monitorFunctionIdOrUrn,
	}
}

// Execute executes the request
//  @return MonitorCheckStates
func (a *MonitorApiService) TestMonitorFunctionCheckStatesExecute(r ApiTestMonitorFunctionCheckStatesRequest) (*MonitorCheckStates, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MonitorCheckStates
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitorApiService.TestMonitorFunctionCheckStates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitors/{monitorFunctionIdOrUrn}/test/checkStates"
	localVarPath = strings.Replace(localVarPath, "{"+"monitorFunctionIdOrUrn"+"}", url.PathEscape(parameterToString(r.monitorFunctionIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.monitorFunctionTest == nil {
		return localVarReturnValue, nil, reportError("monitorFunctionTest is required and must be specified")
	}

	if r.healthState != nil {
		localVarQueryParams.Add("healthState", parameterToString(*r.healthState, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.monitorFunctionTest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidMonitorIdentifierError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v MonitorFunctionNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v MonitorApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ---------------------------------------------
// ------------------ MOCKS --------------------
// ---------------------------------------------

type MonitorApiMock struct {
	DeleteMonitorCalls                     *[]DeleteMonitorCall
	DeleteMonitorResponse                  DeleteMonitorMockResponse
	GetAllMonitorsCalls                    *[]GetAllMonitorsCall
	GetAllMonitorsResponse                 GetAllMonitorsMockResponse
	GetMonitorCalls                        *[]GetMonitorCall
	GetMonitorResponse                     GetMonitorMockResponse
	GetMonitorCheckStatesCalls             *[]GetMonitorCheckStatesCall
	GetMonitorCheckStatesResponse          GetMonitorCheckStatesMockResponse
	GetMonitorWithStatusCalls              *[]GetMonitorWithStatusCall
	GetMonitorWithStatusResponse           GetMonitorWithStatusMockResponse
	GetMonitorsOverviewCalls               *[]GetMonitorsOverviewCall
	GetMonitorsOverviewResponse            GetMonitorsOverviewMockResponse
	LookupIdentifierCalls                  *[]LookupIdentifierCall
	LookupIdentifierResponse               LookupIdentifierMockResponse
	PatchMonitorCalls                      *[]PatchMonitorCall
	PatchMonitorResponse                   PatchMonitorMockResponse
	PreviewMonitorCalls                    *[]PreviewMonitorCall
	PreviewMonitorResponse                 PreviewMonitorMockResponse
	PreviewMonitorCheckStatesCalls         *[]PreviewMonitorCheckStatesCall
	PreviewMonitorCheckStatesResponse      PreviewMonitorCheckStatesMockResponse
	PublishHealthStatesCalls               *[]PublishHealthStatesCall
	PublishHealthStatesResponse            PublishHealthStatesMockResponse
	RunMonitorCalls                        *[]RunMonitorCall
	RunMonitorResponse                     RunMonitorMockResponse
	TestMonitorFunctionCalls               *[]TestMonitorFunctionCall
	TestMonitorFunctionResponse            TestMonitorFunctionMockResponse
	TestMonitorFunctionCheckStatesCalls    *[]TestMonitorFunctionCheckStatesCall
	TestMonitorFunctionCheckStatesResponse TestMonitorFunctionCheckStatesMockResponse
}

func NewMonitorApiMock() MonitorApiMock {
	xDeleteMonitorCalls := make([]DeleteMonitorCall, 0)
	xGetAllMonitorsCalls := make([]GetAllMonitorsCall, 0)
	xGetMonitorCalls := make([]GetMonitorCall, 0)
	xGetMonitorCheckStatesCalls := make([]GetMonitorCheckStatesCall, 0)
	xGetMonitorWithStatusCalls := make([]GetMonitorWithStatusCall, 0)
	xGetMonitorsOverviewCalls := make([]GetMonitorsOverviewCall, 0)
	xLookupIdentifierCalls := make([]LookupIdentifierCall, 0)
	xPatchMonitorCalls := make([]PatchMonitorCall, 0)
	xPreviewMonitorCalls := make([]PreviewMonitorCall, 0)
	xPreviewMonitorCheckStatesCalls := make([]PreviewMonitorCheckStatesCall, 0)
	xPublishHealthStatesCalls := make([]PublishHealthStatesCall, 0)
	xRunMonitorCalls := make([]RunMonitorCall, 0)
	xTestMonitorFunctionCalls := make([]TestMonitorFunctionCall, 0)
	xTestMonitorFunctionCheckStatesCalls := make([]TestMonitorFunctionCheckStatesCall, 0)
	return MonitorApiMock{
		DeleteMonitorCalls:                  &xDeleteMonitorCalls,
		GetAllMonitorsCalls:                 &xGetAllMonitorsCalls,
		GetMonitorCalls:                     &xGetMonitorCalls,
		GetMonitorCheckStatesCalls:          &xGetMonitorCheckStatesCalls,
		GetMonitorWithStatusCalls:           &xGetMonitorWithStatusCalls,
		GetMonitorsOverviewCalls:            &xGetMonitorsOverviewCalls,
		LookupIdentifierCalls:               &xLookupIdentifierCalls,
		PatchMonitorCalls:                   &xPatchMonitorCalls,
		PreviewMonitorCalls:                 &xPreviewMonitorCalls,
		PreviewMonitorCheckStatesCalls:      &xPreviewMonitorCheckStatesCalls,
		PublishHealthStatesCalls:            &xPublishHealthStatesCalls,
		RunMonitorCalls:                     &xRunMonitorCalls,
		TestMonitorFunctionCalls:            &xTestMonitorFunctionCalls,
		TestMonitorFunctionCheckStatesCalls: &xTestMonitorFunctionCheckStatesCalls,
	}
}

type DeleteMonitorMockResponse struct {
	Response *http.Response
	Error    error
}

type DeleteMonitorCall struct {
	PmonitorIdOrUrn string
}

func (mock MonitorApiMock) DeleteMonitor(ctx context.Context, monitorIdOrUrn string) ApiDeleteMonitorRequest {
	return ApiDeleteMonitorRequest{
		ApiService:     mock,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

func (mock MonitorApiMock) DeleteMonitorExecute(r ApiDeleteMonitorRequest) (*http.Response, error) {
	p := DeleteMonitorCall{
		PmonitorIdOrUrn: r.monitorIdOrUrn,
	}
	*mock.DeleteMonitorCalls = append(*mock.DeleteMonitorCalls, p)
	return mock.DeleteMonitorResponse.Response, mock.DeleteMonitorResponse.Error
}

type GetAllMonitorsMockResponse struct {
	Result   MonitorList
	Response *http.Response
	Error    error
}

type GetAllMonitorsCall struct {
}

func (mock MonitorApiMock) GetAllMonitors(ctx context.Context) ApiGetAllMonitorsRequest {
	return ApiGetAllMonitorsRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock MonitorApiMock) GetAllMonitorsExecute(r ApiGetAllMonitorsRequest) (*MonitorList, *http.Response, error) {
	p := GetAllMonitorsCall{}
	*mock.GetAllMonitorsCalls = append(*mock.GetAllMonitorsCalls, p)
	return &mock.GetAllMonitorsResponse.Result, mock.GetAllMonitorsResponse.Response, mock.GetAllMonitorsResponse.Error
}

type GetMonitorMockResponse struct {
	Result   Monitor
	Response *http.Response
	Error    error
}

type GetMonitorCall struct {
	PmonitorIdOrUrn string
}

func (mock MonitorApiMock) GetMonitor(ctx context.Context, monitorIdOrUrn string) ApiGetMonitorRequest {
	return ApiGetMonitorRequest{
		ApiService:     mock,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

func (mock MonitorApiMock) GetMonitorExecute(r ApiGetMonitorRequest) (*Monitor, *http.Response, error) {
	p := GetMonitorCall{
		PmonitorIdOrUrn: r.monitorIdOrUrn,
	}
	*mock.GetMonitorCalls = append(*mock.GetMonitorCalls, p)
	return &mock.GetMonitorResponse.Result, mock.GetMonitorResponse.Response, mock.GetMonitorResponse.Error
}

type GetMonitorCheckStatesMockResponse struct {
	Result   MonitorCheckStates
	Response *http.Response
	Error    error
}

type GetMonitorCheckStatesCall struct {
	PmonitorIdOrUrn string
	PhealthState    *HealthStateValue
	Plimit          *int32
}

func (mock MonitorApiMock) GetMonitorCheckStates(ctx context.Context, monitorIdOrUrn string) ApiGetMonitorCheckStatesRequest {
	return ApiGetMonitorCheckStatesRequest{
		ApiService:     mock,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

func (mock MonitorApiMock) GetMonitorCheckStatesExecute(r ApiGetMonitorCheckStatesRequest) (*MonitorCheckStates, *http.Response, error) {
	p := GetMonitorCheckStatesCall{
		PmonitorIdOrUrn: r.monitorIdOrUrn,
		PhealthState:    r.healthState,
		Plimit:          r.limit,
	}
	*mock.GetMonitorCheckStatesCalls = append(*mock.GetMonitorCheckStatesCalls, p)
	return &mock.GetMonitorCheckStatesResponse.Result, mock.GetMonitorCheckStatesResponse.Response, mock.GetMonitorCheckStatesResponse.Error
}

type GetMonitorWithStatusMockResponse struct {
	Result   MonitorStatus
	Response *http.Response
	Error    error
}

type GetMonitorWithStatusCall struct {
	PmonitorIdOrUrn string
}

func (mock MonitorApiMock) GetMonitorWithStatus(ctx context.Context, monitorIdOrUrn string) ApiGetMonitorWithStatusRequest {
	return ApiGetMonitorWithStatusRequest{
		ApiService:     mock,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

func (mock MonitorApiMock) GetMonitorWithStatusExecute(r ApiGetMonitorWithStatusRequest) (*MonitorStatus, *http.Response, error) {
	p := GetMonitorWithStatusCall{
		PmonitorIdOrUrn: r.monitorIdOrUrn,
	}
	*mock.GetMonitorWithStatusCalls = append(*mock.GetMonitorWithStatusCalls, p)
	return &mock.GetMonitorWithStatusResponse.Result, mock.GetMonitorWithStatusResponse.Response, mock.GetMonitorWithStatusResponse.Error
}

type GetMonitorsOverviewMockResponse struct {
	Result   MonitorOverviewList
	Response *http.Response
	Error    error
}

type GetMonitorsOverviewCall struct {
}

func (mock MonitorApiMock) GetMonitorsOverview(ctx context.Context) ApiGetMonitorsOverviewRequest {
	return ApiGetMonitorsOverviewRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock MonitorApiMock) GetMonitorsOverviewExecute(r ApiGetMonitorsOverviewRequest) (*MonitorOverviewList, *http.Response, error) {
	p := GetMonitorsOverviewCall{}
	*mock.GetMonitorsOverviewCalls = append(*mock.GetMonitorsOverviewCalls, p)
	return &mock.GetMonitorsOverviewResponse.Result, mock.GetMonitorsOverviewResponse.Response, mock.GetMonitorsOverviewResponse.Error
}

type LookupIdentifierMockResponse struct {
	Result   MonitorIdentifierSuggestions
	Response *http.Response
	Error    error
}

type LookupIdentifierCall struct {
	PmonitorIdentifierLookup *MonitorIdentifierLookup
}

func (mock MonitorApiMock) LookupIdentifier(ctx context.Context) ApiLookupIdentifierRequest {
	return ApiLookupIdentifierRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock MonitorApiMock) LookupIdentifierExecute(r ApiLookupIdentifierRequest) (*MonitorIdentifierSuggestions, *http.Response, error) {
	p := LookupIdentifierCall{
		PmonitorIdentifierLookup: r.monitorIdentifierLookup,
	}
	*mock.LookupIdentifierCalls = append(*mock.LookupIdentifierCalls, p)
	return &mock.LookupIdentifierResponse.Result, mock.LookupIdentifierResponse.Response, mock.LookupIdentifierResponse.Error
}

type PatchMonitorMockResponse struct {
	Result   Monitor
	Response *http.Response
	Error    error
}

type PatchMonitorCall struct {
	PmonitorIdOrUrn string
	PmonitorPatch   *MonitorPatch
}

func (mock MonitorApiMock) PatchMonitor(ctx context.Context, monitorIdOrUrn string) ApiPatchMonitorRequest {
	return ApiPatchMonitorRequest{
		ApiService:     mock,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

func (mock MonitorApiMock) PatchMonitorExecute(r ApiPatchMonitorRequest) (*Monitor, *http.Response, error) {
	p := PatchMonitorCall{
		PmonitorIdOrUrn: r.monitorIdOrUrn,
		PmonitorPatch:   r.monitorPatch,
	}
	*mock.PatchMonitorCalls = append(*mock.PatchMonitorCalls, p)
	return &mock.PatchMonitorResponse.Result, mock.PatchMonitorResponse.Response, mock.PatchMonitorResponse.Error
}

type PreviewMonitorMockResponse struct {
	Result   MonitorPreviewResult
	Response *http.Response
	Error    error
}

type PreviewMonitorCall struct {
	PmonitorIdOrUrn string
	PmonitorPreview *MonitorPreview
}

func (mock MonitorApiMock) PreviewMonitor(ctx context.Context, monitorIdOrUrn string) ApiPreviewMonitorRequest {
	return ApiPreviewMonitorRequest{
		ApiService:     mock,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

func (mock MonitorApiMock) PreviewMonitorExecute(r ApiPreviewMonitorRequest) (*MonitorPreviewResult, *http.Response, error) {
	p := PreviewMonitorCall{
		PmonitorIdOrUrn: r.monitorIdOrUrn,
		PmonitorPreview: r.monitorPreview,
	}
	*mock.PreviewMonitorCalls = append(*mock.PreviewMonitorCalls, p)
	return &mock.PreviewMonitorResponse.Result, mock.PreviewMonitorResponse.Response, mock.PreviewMonitorResponse.Error
}

type PreviewMonitorCheckStatesMockResponse struct {
	Result   MonitorCheckStates
	Response *http.Response
	Error    error
}

type PreviewMonitorCheckStatesCall struct {
	PmonitorIdOrUrn string
	PmonitorPreview *MonitorPreview
	PhealthState    *HealthStateValue
	Plimit          *int32
}

func (mock MonitorApiMock) PreviewMonitorCheckStates(ctx context.Context, monitorIdOrUrn string) ApiPreviewMonitorCheckStatesRequest {
	return ApiPreviewMonitorCheckStatesRequest{
		ApiService:     mock,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

func (mock MonitorApiMock) PreviewMonitorCheckStatesExecute(r ApiPreviewMonitorCheckStatesRequest) (*MonitorCheckStates, *http.Response, error) {
	p := PreviewMonitorCheckStatesCall{
		PmonitorIdOrUrn: r.monitorIdOrUrn,
		PmonitorPreview: r.monitorPreview,
		PhealthState:    r.healthState,
		Plimit:          r.limit,
	}
	*mock.PreviewMonitorCheckStatesCalls = append(*mock.PreviewMonitorCheckStatesCalls, p)
	return &mock.PreviewMonitorCheckStatesResponse.Result, mock.PreviewMonitorCheckStatesResponse.Response, mock.PreviewMonitorCheckStatesResponse.Error
}

type PublishHealthStatesMockResponse struct {
	Response *http.Response
	Error    error
}

type PublishHealthStatesCall struct {
	PmonitorIdOrUrn  string
	PmonitorSnapshot *MonitorSnapshot
}

func (mock MonitorApiMock) PublishHealthStates(ctx context.Context, monitorIdOrUrn string) ApiPublishHealthStatesRequest {
	return ApiPublishHealthStatesRequest{
		ApiService:     mock,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

func (mock MonitorApiMock) PublishHealthStatesExecute(r ApiPublishHealthStatesRequest) (*http.Response, error) {
	p := PublishHealthStatesCall{
		PmonitorIdOrUrn:  r.monitorIdOrUrn,
		PmonitorSnapshot: r.monitorSnapshot,
	}
	*mock.PublishHealthStatesCalls = append(*mock.PublishHealthStatesCalls, p)
	return mock.PublishHealthStatesResponse.Response, mock.PublishHealthStatesResponse.Error
}

type RunMonitorMockResponse struct {
	Result   MonitorRunResult
	Response *http.Response
	Error    error
}

type RunMonitorCall struct {
	PmonitorIdOrUrn string
	PdryRun         *bool
}

func (mock MonitorApiMock) RunMonitor(ctx context.Context, monitorIdOrUrn string) ApiRunMonitorRequest {
	return ApiRunMonitorRequest{
		ApiService:     mock,
		ctx:            ctx,
		monitorIdOrUrn: monitorIdOrUrn,
	}
}

func (mock MonitorApiMock) RunMonitorExecute(r ApiRunMonitorRequest) (*MonitorRunResult, *http.Response, error) {
	p := RunMonitorCall{
		PmonitorIdOrUrn: r.monitorIdOrUrn,
		PdryRun:         r.dryRun,
	}
	*mock.RunMonitorCalls = append(*mock.RunMonitorCalls, p)
	return &mock.RunMonitorResponse.Result, mock.RunMonitorResponse.Response, mock.RunMonitorResponse.Error
}

type TestMonitorFunctionMockResponse struct {
	Result   MonitorPreviewResult
	Response *http.Response
	Error    error
}

type TestMonitorFunctionCall struct {
	PmonitorFunctionIdOrUrn string
	PmonitorFunctionTest    *MonitorFunctionTest
}

func (mock MonitorApiMock) TestMonitorFunction(ctx context.Context, monitorFunctionIdOrUrn string) ApiTestMonitorFunctionRequest {
	return ApiTestMonitorFunctionRequest{
		ApiService:             mock,
		ctx:                    ctx,
		monitorFunctionIdOrUrn: monitorFunctionIdOrUrn,
	}
}

func (mock MonitorApiMock) TestMonitorFunctionExecute(r ApiTestMonitorFunctionRequest) (*MonitorPreviewResult, *http.Response, error) {
	p := TestMonitorFunctionCall{
		PmonitorFunctionIdOrUrn: r.monitorFunctionIdOrUrn,
		PmonitorFunctionTest:    r.monitorFunctionTest,
	}
	*mock.TestMonitorFunctionCalls = append(*mock.TestMonitorFunctionCalls, p)
	return &mock.TestMonitorFunctionResponse.Result, mock.TestMonitorFunctionResponse.Response, mock.TestMonitorFunctionResponse.Error
}

type TestMonitorFunctionCheckStatesMockResponse struct {
	Result   MonitorCheckStates
	Response *http.Response
	Error    error
}

type TestMonitorFunctionCheckStatesCall struct {
	PmonitorFunctionIdOrUrn string
	PmonitorFunctionTest    *MonitorFunctionTest
	PhealthState            *HealthStateValue
	Plimit                  *int32
}

func (mock MonitorApiMock) TestMonitorFunctionCheckStates(ctx context.Context, monitorFunctionIdOrUrn string) ApiTestMonitorFunctionCheckStatesRequest {
	return ApiTestMonitorFunctionCheckStatesRequest{
		ApiService:             mock,
		ctx:                    ctx,
		monitorFunctionIdOrUrn: monitorFunctionIdOrUrn,
	}
}

func (mock MonitorApiMock) TestMonitorFunctionCheckStatesExecute(r ApiTestMonitorFunctionCheckStatesRequest) (*MonitorCheckStates, *http.Response, error) {
	p := TestMonitorFunctionCheckStatesCall{
		PmonitorFunctionIdOrUrn: r.monitorFunctionIdOrUrn,
		PmonitorFunctionTest:    r.monitorFunctionTest,
		PhealthState:            r.healthState,
		Plimit:                  r.limit,
	}
	*mock.TestMonitorFunctionCheckStatesCalls = append(*mock.TestMonitorFunctionCheckStatesCalls, p)
	return &mock.TestMonitorFunctionCheckStatesResponse.Result, mock.TestMonitorFunctionCheckStatesResponse.Response, mock.TestMonitorFunctionCheckStatesResponse.Error
}
