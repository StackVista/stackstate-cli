/*
StackState API

This API documentation page describes the StackState server API. The StackState UI and CLI use the StackState server API to configure and query StackState.  You can use the API for similar purposes.  Each request sent to the StackState server API must be authenticated using one of the available authentication methods.   *Note that the StackState receiver API, used to send topology, telemetry and traces to StackState, is not described on this page and requires a different authentication method.*  For more information on StackState, refer to the [StackState documentation](https://docs.stackstate.com).

API version: 5.2.0
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackstate_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

type NotificationChannelsAPI interface {

	/*
		CreateOpsgenieNotificationChannel Create a Opsgenie Notification channel

		Create a Opsgenie Notification channel

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateOpsgenieNotificationChannelRequest
	*/
	CreateOpsgenieNotificationChannel(ctx context.Context) ApiCreateOpsgenieNotificationChannelRequest

	// CreateOpsgenieNotificationChannelExecute executes the request
	//  @return OpsgenieNotificationChannel
	CreateOpsgenieNotificationChannelExecute(r ApiCreateOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error)

	/*
		CreateWebhookNotificationChannel Create a Webhook Notification channel

		Create a Webhook Notification channel

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateWebhookNotificationChannelRequest
	*/
	CreateWebhookNotificationChannel(ctx context.Context) ApiCreateWebhookNotificationChannelRequest

	// CreateWebhookNotificationChannelExecute executes the request
	//  @return WebhookNotificationChannel
	CreateWebhookNotificationChannelExecute(r ApiCreateWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error)

	/*
		DeleteOpsgenieNotificationChannel Delete the Opsgenie Notification channel by id

		Delete the opsgenie notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiDeleteOpsgenieNotificationChannelRequest
	*/
	DeleteOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiDeleteOpsgenieNotificationChannelRequest

	// DeleteOpsgenieNotificationChannelExecute executes the request
	DeleteOpsgenieNotificationChannelExecute(r ApiDeleteOpsgenieNotificationChannelRequest) (*http.Response, error)

	/*
		DeleteSlackNotificationChannel Delete the Slack Notification channel by id

		Delete the slack notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiDeleteSlackNotificationChannelRequest
	*/
	DeleteSlackNotificationChannel(ctx context.Context, channelId int64) ApiDeleteSlackNotificationChannelRequest

	// DeleteSlackNotificationChannelExecute executes the request
	DeleteSlackNotificationChannelExecute(r ApiDeleteSlackNotificationChannelRequest) (*http.Response, error)

	/*
		DeleteWebhookNotificationChannel Delete the Webhook Notification channel by id

		Delete the webhook notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiDeleteWebhookNotificationChannelRequest
	*/
	DeleteWebhookNotificationChannel(ctx context.Context, channelId int64) ApiDeleteWebhookNotificationChannelRequest

	// DeleteWebhookNotificationChannelExecute executes the request
	DeleteWebhookNotificationChannelExecute(r ApiDeleteWebhookNotificationChannelRequest) (*http.Response, error)

	/*
		GetOpsgenieNotificationChannel Get the Opsgenie Notification channel by id

		Get the opsgenie notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiGetOpsgenieNotificationChannelRequest
	*/
	GetOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiGetOpsgenieNotificationChannelRequest

	// GetOpsgenieNotificationChannelExecute executes the request
	//  @return OpsgenieNotificationChannel
	GetOpsgenieNotificationChannelExecute(r ApiGetOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error)

	/*
		GetSlackNotificationChannel Get the Slack Notification channel by id

		Get the slack notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiGetSlackNotificationChannelRequest
	*/
	GetSlackNotificationChannel(ctx context.Context, channelId int64) ApiGetSlackNotificationChannelRequest

	// GetSlackNotificationChannelExecute executes the request
	//  @return SlackNotificationChannel
	GetSlackNotificationChannelExecute(r ApiGetSlackNotificationChannelRequest) (*SlackNotificationChannel, *http.Response, error)

	/*
		GetWebhookNotificationChannel Get the Webhook Notification channel by id

		Get the webhook notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiGetWebhookNotificationChannelRequest
	*/
	GetWebhookNotificationChannel(ctx context.Context, channelId int64) ApiGetWebhookNotificationChannelRequest

	// GetWebhookNotificationChannelExecute executes the request
	//  @return WebhookNotificationChannel
	GetWebhookNotificationChannelExecute(r ApiGetWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error)

	/*
		JoinSlackChannel Join the specified Slack channel to send notifications

		Join the specified Slack channel and configure this notifiation channel to post notifications to the specified slack channel.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiJoinSlackChannelRequest
	*/
	JoinSlackChannel(ctx context.Context, channelId int64) ApiJoinSlackChannelRequest

	// JoinSlackChannelExecute executes the request
	//  @return SlackNotificationChannel
	JoinSlackChannelExecute(r ApiJoinSlackChannelRequest) (*SlackNotificationChannel, *http.Response, error)

	/*
		ListOpsgenieResponders List Opsgenie responders

		List Opsgenie responders

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListOpsgenieRespondersRequest
	*/
	ListOpsgenieResponders(ctx context.Context) ApiListOpsgenieRespondersRequest

	// ListOpsgenieRespondersExecute executes the request
	//  @return []OpsgenieResponder
	ListOpsgenieRespondersExecute(r ApiListOpsgenieRespondersRequest) ([]OpsgenieResponder, *http.Response, error)

	/*
		ListSlackChannels List all public Slack channels

		List all public Slack channels, used for selecting a channel for the notifications

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiListSlackChannelsRequest
	*/
	ListSlackChannels(ctx context.Context, channelId int64) ApiListSlackChannelsRequest

	// ListSlackChannelsExecute executes the request
	//  @return []SlackChannel
	ListSlackChannelsExecute(r ApiListSlackChannelsRequest) ([]SlackChannel, *http.Response, error)

	/*
		SlackOAuthCallback The OAuth callback for Slack

		The OAuth callback for Slack, which is used to obtain the access token for the Slack channel.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiSlackOAuthCallbackRequest
	*/
	SlackOAuthCallback(ctx context.Context) ApiSlackOAuthCallbackRequest

	// SlackOAuthCallbackExecute executes the request
	SlackOAuthCallbackExecute(r ApiSlackOAuthCallbackRequest) (*http.Response, error)

	/*
		SlackOauthRedirect Starts Slack OAuth2 flow

		Redirects to Slack to start an OAuth2 flow.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiSlackOauthRedirectRequest
	*/
	SlackOauthRedirect(ctx context.Context) ApiSlackOauthRedirectRequest

	// SlackOauthRedirectExecute executes the request
	SlackOauthRedirectExecute(r ApiSlackOauthRedirectRequest) (*http.Response, error)

	/*
		TestOpsgenieChannel Test the Opsgenie notification channel

		Test the opsgenie notification channel by sending a test message to the notification channel.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiTestOpsgenieChannelRequest
	*/
	TestOpsgenieChannel(ctx context.Context, channelId int64) ApiTestOpsgenieChannelRequest

	// TestOpsgenieChannelExecute executes the request
	TestOpsgenieChannelExecute(r ApiTestOpsgenieChannelRequest) (*http.Response, error)

	/*
		TestSlackChannel Test the Notification channel

		Test the Notification channel by sending a test message to the notification channel.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiTestSlackChannelRequest
	*/
	TestSlackChannel(ctx context.Context, channelId int64) ApiTestSlackChannelRequest

	// TestSlackChannelExecute executes the request
	TestSlackChannelExecute(r ApiTestSlackChannelRequest) (*http.Response, error)

	/*
		TestWebhookChannel Test the Webhook notification channel

		Test the webhook notification channel by sending a test message to the notification channel.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiTestWebhookChannelRequest
	*/
	TestWebhookChannel(ctx context.Context, channelId int64) ApiTestWebhookChannelRequest

	// TestWebhookChannelExecute executes the request
	TestWebhookChannelExecute(r ApiTestWebhookChannelRequest) (*http.Response, error)

	/*
		UpdateOpsgenieNotificationChannel Update the Opsgenie Notification channel by id

		Update the opsgenie notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiUpdateOpsgenieNotificationChannelRequest
	*/
	UpdateOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiUpdateOpsgenieNotificationChannelRequest

	// UpdateOpsgenieNotificationChannelExecute executes the request
	//  @return OpsgenieNotificationChannel
	UpdateOpsgenieNotificationChannelExecute(r ApiUpdateOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error)

	/*
		UpdateWebhookNotificationChannel Update the Webhook Notification channel by id

		Update the webhook notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiUpdateWebhookNotificationChannelRequest
	*/
	UpdateWebhookNotificationChannel(ctx context.Context, channelId int64) ApiUpdateWebhookNotificationChannelRequest

	// UpdateWebhookNotificationChannelExecute executes the request
	//  @return WebhookNotificationChannel
	UpdateWebhookNotificationChannelExecute(r ApiUpdateWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error)
}

// NotificationChannelsAPIService NotificationChannelsAPI service
type NotificationChannelsAPIService service

type ApiCreateOpsgenieNotificationChannelRequest struct {
	ctx                        context.Context
	ApiService                 NotificationChannelsAPI
	opsgenieChannelWriteSchema *OpsgenieChannelWriteSchema
}

// Create or update a opsgenie channel
func (r ApiCreateOpsgenieNotificationChannelRequest) OpsgenieChannelWriteSchema(opsgenieChannelWriteSchema OpsgenieChannelWriteSchema) ApiCreateOpsgenieNotificationChannelRequest {
	r.opsgenieChannelWriteSchema = &opsgenieChannelWriteSchema
	return r
}

func (r ApiCreateOpsgenieNotificationChannelRequest) Execute() (*OpsgenieNotificationChannel, *http.Response, error) {
	return r.ApiService.CreateOpsgenieNotificationChannelExecute(r)
}

/*
CreateOpsgenieNotificationChannel Create a Opsgenie Notification channel

Create a Opsgenie Notification channel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateOpsgenieNotificationChannelRequest
*/
func (a *NotificationChannelsAPIService) CreateOpsgenieNotificationChannel(ctx context.Context) ApiCreateOpsgenieNotificationChannelRequest {
	return ApiCreateOpsgenieNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return OpsgenieNotificationChannel
func (a *NotificationChannelsAPIService) CreateOpsgenieNotificationChannelExecute(r ApiCreateOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OpsgenieNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.CreateOpsgenieNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/opsgenie"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.opsgenieChannelWriteSchema == nil {
		return localVarReturnValue, nil, reportError("opsgenieChannelWriteSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opsgenieChannelWriteSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateWebhookNotificationChannelRequest struct {
	ctx                       context.Context
	ApiService                NotificationChannelsAPI
	webhookChannelWriteSchema *WebhookChannelWriteSchema
}

// Create or update a webhook channel
func (r ApiCreateWebhookNotificationChannelRequest) WebhookChannelWriteSchema(webhookChannelWriteSchema WebhookChannelWriteSchema) ApiCreateWebhookNotificationChannelRequest {
	r.webhookChannelWriteSchema = &webhookChannelWriteSchema
	return r
}

func (r ApiCreateWebhookNotificationChannelRequest) Execute() (*WebhookNotificationChannel, *http.Response, error) {
	return r.ApiService.CreateWebhookNotificationChannelExecute(r)
}

/*
CreateWebhookNotificationChannel Create a Webhook Notification channel

Create a Webhook Notification channel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateWebhookNotificationChannelRequest
*/
func (a *NotificationChannelsAPIService) CreateWebhookNotificationChannel(ctx context.Context) ApiCreateWebhookNotificationChannelRequest {
	return ApiCreateWebhookNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WebhookNotificationChannel
func (a *NotificationChannelsAPIService) CreateWebhookNotificationChannelExecute(r ApiCreateWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebhookNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.CreateWebhookNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/webhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.webhookChannelWriteSchema == nil {
		return localVarReturnValue, nil, reportError("webhookChannelWriteSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookChannelWriteSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOpsgenieNotificationChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsAPI
	channelId  int64
}

func (r ApiDeleteOpsgenieNotificationChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteOpsgenieNotificationChannelExecute(r)
}

/*
DeleteOpsgenieNotificationChannel Delete the Opsgenie Notification channel by id

Delete the opsgenie notification channel by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId Channel identifier
	@return ApiDeleteOpsgenieNotificationChannelRequest
*/
func (a *NotificationChannelsAPIService) DeleteOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiDeleteOpsgenieNotificationChannelRequest {
	return ApiDeleteOpsgenieNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *NotificationChannelsAPIService) DeleteOpsgenieNotificationChannelExecute(r ApiDeleteOpsgenieNotificationChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.DeleteOpsgenieNotificationChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/opsgenie/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSlackNotificationChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsAPI
	channelId  int64
}

func (r ApiDeleteSlackNotificationChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSlackNotificationChannelExecute(r)
}

/*
DeleteSlackNotificationChannel Delete the Slack Notification channel by id

Delete the slack notification channel by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId Channel identifier
	@return ApiDeleteSlackNotificationChannelRequest
*/
func (a *NotificationChannelsAPIService) DeleteSlackNotificationChannel(ctx context.Context, channelId int64) ApiDeleteSlackNotificationChannelRequest {
	return ApiDeleteSlackNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *NotificationChannelsAPIService) DeleteSlackNotificationChannelExecute(r ApiDeleteSlackNotificationChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.DeleteSlackNotificationChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/slack/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteWebhookNotificationChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsAPI
	channelId  int64
}

func (r ApiDeleteWebhookNotificationChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteWebhookNotificationChannelExecute(r)
}

/*
DeleteWebhookNotificationChannel Delete the Webhook Notification channel by id

Delete the webhook notification channel by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId Channel identifier
	@return ApiDeleteWebhookNotificationChannelRequest
*/
func (a *NotificationChannelsAPIService) DeleteWebhookNotificationChannel(ctx context.Context, channelId int64) ApiDeleteWebhookNotificationChannelRequest {
	return ApiDeleteWebhookNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *NotificationChannelsAPIService) DeleteWebhookNotificationChannelExecute(r ApiDeleteWebhookNotificationChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.DeleteWebhookNotificationChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/webhook/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetOpsgenieNotificationChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsAPI
	channelId  int64
}

func (r ApiGetOpsgenieNotificationChannelRequest) Execute() (*OpsgenieNotificationChannel, *http.Response, error) {
	return r.ApiService.GetOpsgenieNotificationChannelExecute(r)
}

/*
GetOpsgenieNotificationChannel Get the Opsgenie Notification channel by id

Get the opsgenie notification channel by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId Channel identifier
	@return ApiGetOpsgenieNotificationChannelRequest
*/
func (a *NotificationChannelsAPIService) GetOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiGetOpsgenieNotificationChannelRequest {
	return ApiGetOpsgenieNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return OpsgenieNotificationChannel
func (a *NotificationChannelsAPIService) GetOpsgenieNotificationChannelExecute(r ApiGetOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OpsgenieNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.GetOpsgenieNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/opsgenie/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSlackNotificationChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsAPI
	channelId  int64
}

func (r ApiGetSlackNotificationChannelRequest) Execute() (*SlackNotificationChannel, *http.Response, error) {
	return r.ApiService.GetSlackNotificationChannelExecute(r)
}

/*
GetSlackNotificationChannel Get the Slack Notification channel by id

Get the slack notification channel by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId Channel identifier
	@return ApiGetSlackNotificationChannelRequest
*/
func (a *NotificationChannelsAPIService) GetSlackNotificationChannel(ctx context.Context, channelId int64) ApiGetSlackNotificationChannelRequest {
	return ApiGetSlackNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return SlackNotificationChannel
func (a *NotificationChannelsAPIService) GetSlackNotificationChannelExecute(r ApiGetSlackNotificationChannelRequest) (*SlackNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SlackNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.GetSlackNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/slack/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWebhookNotificationChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsAPI
	channelId  int64
}

func (r ApiGetWebhookNotificationChannelRequest) Execute() (*WebhookNotificationChannel, *http.Response, error) {
	return r.ApiService.GetWebhookNotificationChannelExecute(r)
}

/*
GetWebhookNotificationChannel Get the Webhook Notification channel by id

Get the webhook notification channel by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId Channel identifier
	@return ApiGetWebhookNotificationChannelRequest
*/
func (a *NotificationChannelsAPIService) GetWebhookNotificationChannel(ctx context.Context, channelId int64) ApiGetWebhookNotificationChannelRequest {
	return ApiGetWebhookNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return WebhookNotificationChannel
func (a *NotificationChannelsAPIService) GetWebhookNotificationChannelExecute(r ApiGetWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebhookNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.GetWebhookNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/webhook/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJoinSlackChannelRequest struct {
	ctx            context.Context
	ApiService     NotificationChannelsAPI
	channelId      int64
	slackChannelId *SlackChannelId
}

// Provide a Slack channel id to join the specified Slack channel
func (r ApiJoinSlackChannelRequest) SlackChannelId(slackChannelId SlackChannelId) ApiJoinSlackChannelRequest {
	r.slackChannelId = &slackChannelId
	return r
}

func (r ApiJoinSlackChannelRequest) Execute() (*SlackNotificationChannel, *http.Response, error) {
	return r.ApiService.JoinSlackChannelExecute(r)
}

/*
JoinSlackChannel Join the specified Slack channel to send notifications

Join the specified Slack channel and configure this notifiation channel to post notifications to the specified slack channel.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId Channel identifier
	@return ApiJoinSlackChannelRequest
*/
func (a *NotificationChannelsAPIService) JoinSlackChannel(ctx context.Context, channelId int64) ApiJoinSlackChannelRequest {
	return ApiJoinSlackChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return SlackNotificationChannel
func (a *NotificationChannelsAPIService) JoinSlackChannelExecute(r ApiJoinSlackChannelRequest) (*SlackNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SlackNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.JoinSlackChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/slack/{channelId}/joinSlackChannel"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.slackChannelId == nil {
		return localVarReturnValue, nil, reportError("slackChannelId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.slackChannelId
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOpsgenieRespondersRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsAPI
	genieKey   *string
	region     *string
}

// OpsGenie API key
func (r ApiListOpsgenieRespondersRequest) GenieKey(genieKey string) ApiListOpsgenieRespondersRequest {
	r.genieKey = &genieKey
	return r
}

// OpsGenie region
func (r ApiListOpsgenieRespondersRequest) Region(region string) ApiListOpsgenieRespondersRequest {
	r.region = &region
	return r
}

func (r ApiListOpsgenieRespondersRequest) Execute() ([]OpsgenieResponder, *http.Response, error) {
	return r.ApiService.ListOpsgenieRespondersExecute(r)
}

/*
ListOpsgenieResponders List Opsgenie responders

List Opsgenie responders

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListOpsgenieRespondersRequest
*/
func (a *NotificationChannelsAPIService) ListOpsgenieResponders(ctx context.Context) ApiListOpsgenieRespondersRequest {
	return ApiListOpsgenieRespondersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []OpsgenieResponder
func (a *NotificationChannelsAPIService) ListOpsgenieRespondersExecute(r ApiListOpsgenieRespondersRequest) ([]OpsgenieResponder, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []OpsgenieResponder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.ListOpsgenieResponders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/opsgenie/responders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.genieKey == nil {
		return localVarReturnValue, nil, reportError("genieKey is required and must be specified")
	}
	if r.region == nil {
		return localVarReturnValue, nil, reportError("region is required and must be specified")
	}

	localVarQueryParams.Add("genieKey", parameterToString(*r.genieKey, ""))
	localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSlackChannelsRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsAPI
	channelId  int64
}

func (r ApiListSlackChannelsRequest) Execute() ([]SlackChannel, *http.Response, error) {
	return r.ApiService.ListSlackChannelsExecute(r)
}

/*
ListSlackChannels List all public Slack channels

List all public Slack channels, used for selecting a channel for the notifications

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId Channel identifier
	@return ApiListSlackChannelsRequest
*/
func (a *NotificationChannelsAPIService) ListSlackChannels(ctx context.Context, channelId int64) ApiListSlackChannelsRequest {
	return ApiListSlackChannelsRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return []SlackChannel
func (a *NotificationChannelsAPIService) ListSlackChannelsExecute(r ApiListSlackChannelsRequest) ([]SlackChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []SlackChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.ListSlackChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/slack/{channelId}/listSlackChannels"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlackOAuthCallbackRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsAPI
	state      *string
	code       *string
	error_     *string
}

// State parameter that was passed to Slack, should have the same value as the one passed to Slack.
func (r ApiSlackOAuthCallbackRequest) State(state string) ApiSlackOAuthCallbackRequest {
	r.state = &state
	return r
}

// OAuth code from Slack. Either the code is present for the success case or the error parameter is present for the error case.
func (r ApiSlackOAuthCallbackRequest) Code(code string) ApiSlackOAuthCallbackRequest {
	r.code = &code
	return r
}

// Error parameter. Either the code is present for the success case or the error parameter is present for the error case.
func (r ApiSlackOAuthCallbackRequest) Error_(error_ string) ApiSlackOAuthCallbackRequest {
	r.error_ = &error_
	return r
}

func (r ApiSlackOAuthCallbackRequest) Execute() (*http.Response, error) {
	return r.ApiService.SlackOAuthCallbackExecute(r)
}

/*
SlackOAuthCallback The OAuth callback for Slack

The OAuth callback for Slack, which is used to obtain the access token for the Slack channel.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSlackOAuthCallbackRequest
*/
func (a *NotificationChannelsAPIService) SlackOAuthCallback(ctx context.Context) ApiSlackOAuthCallbackRequest {
	return ApiSlackOAuthCallbackRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *NotificationChannelsAPIService) SlackOAuthCallbackExecute(r ApiSlackOAuthCallbackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.SlackOAuthCallback")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/slack/oauth-callback"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.state == nil {
		return nil, reportError("state is required and must be specified")
	}

	if r.code != nil {
		localVarQueryParams.Add("code", parameterToString(*r.code, ""))
	}
	localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	if r.error_ != nil {
		localVarQueryParams.Add("error", parameterToString(*r.error_, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSlackOauthRedirectRequest struct {
	ctx          context.Context
	ApiService   NotificationChannelsAPI
	redirectPath *string
}

// After completing the oauth flow the user will be redirected back to this path, in the UI, on StackState, to continue further setup of the Slack notification channel.
func (r ApiSlackOauthRedirectRequest) RedirectPath(redirectPath string) ApiSlackOauthRedirectRequest {
	r.redirectPath = &redirectPath
	return r
}

func (r ApiSlackOauthRedirectRequest) Execute() (*http.Response, error) {
	return r.ApiService.SlackOauthRedirectExecute(r)
}

/*
SlackOauthRedirect Starts Slack OAuth2 flow

Redirects to Slack to start an OAuth2 flow.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSlackOauthRedirectRequest
*/
func (a *NotificationChannelsAPIService) SlackOauthRedirect(ctx context.Context) ApiSlackOauthRedirectRequest {
	return ApiSlackOauthRedirectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *NotificationChannelsAPIService) SlackOauthRedirectExecute(r ApiSlackOauthRedirectRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.SlackOauthRedirect")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/slack/oauth-redirect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.redirectPath == nil {
		return nil, reportError("redirectPath is required and must be specified")
	}

	localVarQueryParams.Add("redirectPath", parameterToString(*r.redirectPath, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestOpsgenieChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsAPI
	channelId  int64
}

func (r ApiTestOpsgenieChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.TestOpsgenieChannelExecute(r)
}

/*
TestOpsgenieChannel Test the Opsgenie notification channel

Test the opsgenie notification channel by sending a test message to the notification channel.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId Channel identifier
	@return ApiTestOpsgenieChannelRequest
*/
func (a *NotificationChannelsAPIService) TestOpsgenieChannel(ctx context.Context, channelId int64) ApiTestOpsgenieChannelRequest {
	return ApiTestOpsgenieChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *NotificationChannelsAPIService) TestOpsgenieChannelExecute(r ApiTestOpsgenieChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.TestOpsgenieChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/opsgenie/{channelId}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestSlackChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsAPI
	channelId  int64
}

func (r ApiTestSlackChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.TestSlackChannelExecute(r)
}

/*
TestSlackChannel Test the Notification channel

Test the Notification channel by sending a test message to the notification channel.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId Channel identifier
	@return ApiTestSlackChannelRequest
*/
func (a *NotificationChannelsAPIService) TestSlackChannel(ctx context.Context, channelId int64) ApiTestSlackChannelRequest {
	return ApiTestSlackChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *NotificationChannelsAPIService) TestSlackChannelExecute(r ApiTestSlackChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.TestSlackChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/slack/{channelId}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestWebhookChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsAPI
	channelId  int64
}

func (r ApiTestWebhookChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.TestWebhookChannelExecute(r)
}

/*
TestWebhookChannel Test the Webhook notification channel

Test the webhook notification channel by sending a test message to the notification channel.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId Channel identifier
	@return ApiTestWebhookChannelRequest
*/
func (a *NotificationChannelsAPIService) TestWebhookChannel(ctx context.Context, channelId int64) ApiTestWebhookChannelRequest {
	return ApiTestWebhookChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *NotificationChannelsAPIService) TestWebhookChannelExecute(r ApiTestWebhookChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.TestWebhookChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/webhook/{channelId}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateOpsgenieNotificationChannelRequest struct {
	ctx                        context.Context
	ApiService                 NotificationChannelsAPI
	channelId                  int64
	opsgenieChannelWriteSchema *OpsgenieChannelWriteSchema
}

// Create or update a opsgenie channel
func (r ApiUpdateOpsgenieNotificationChannelRequest) OpsgenieChannelWriteSchema(opsgenieChannelWriteSchema OpsgenieChannelWriteSchema) ApiUpdateOpsgenieNotificationChannelRequest {
	r.opsgenieChannelWriteSchema = &opsgenieChannelWriteSchema
	return r
}

func (r ApiUpdateOpsgenieNotificationChannelRequest) Execute() (*OpsgenieNotificationChannel, *http.Response, error) {
	return r.ApiService.UpdateOpsgenieNotificationChannelExecute(r)
}

/*
UpdateOpsgenieNotificationChannel Update the Opsgenie Notification channel by id

Update the opsgenie notification channel by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId Channel identifier
	@return ApiUpdateOpsgenieNotificationChannelRequest
*/
func (a *NotificationChannelsAPIService) UpdateOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiUpdateOpsgenieNotificationChannelRequest {
	return ApiUpdateOpsgenieNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return OpsgenieNotificationChannel
func (a *NotificationChannelsAPIService) UpdateOpsgenieNotificationChannelExecute(r ApiUpdateOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OpsgenieNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.UpdateOpsgenieNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/opsgenie/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.opsgenieChannelWriteSchema == nil {
		return localVarReturnValue, nil, reportError("opsgenieChannelWriteSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opsgenieChannelWriteSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWebhookNotificationChannelRequest struct {
	ctx                       context.Context
	ApiService                NotificationChannelsAPI
	channelId                 int64
	webhookChannelWriteSchema *WebhookChannelWriteSchema
}

// Create or update a webhook channel
func (r ApiUpdateWebhookNotificationChannelRequest) WebhookChannelWriteSchema(webhookChannelWriteSchema WebhookChannelWriteSchema) ApiUpdateWebhookNotificationChannelRequest {
	r.webhookChannelWriteSchema = &webhookChannelWriteSchema
	return r
}

func (r ApiUpdateWebhookNotificationChannelRequest) Execute() (*WebhookNotificationChannel, *http.Response, error) {
	return r.ApiService.UpdateWebhookNotificationChannelExecute(r)
}

/*
UpdateWebhookNotificationChannel Update the Webhook Notification channel by id

Update the webhook notification channel by id

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId Channel identifier
	@return ApiUpdateWebhookNotificationChannelRequest
*/
func (a *NotificationChannelsAPIService) UpdateWebhookNotificationChannel(ctx context.Context, channelId int64) ApiUpdateWebhookNotificationChannelRequest {
	return ApiUpdateWebhookNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//
//	@return WebhookNotificationChannel
func (a *NotificationChannelsAPIService) UpdateWebhookNotificationChannelExecute(r ApiUpdateWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebhookNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsAPIService.UpdateWebhookNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/webhook/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.webhookChannelWriteSchema == nil {
		return localVarReturnValue, nil, reportError("webhookChannelWriteSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookChannelWriteSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ---------------------------------------------
// ------------------ MOCKS --------------------
// ---------------------------------------------

type NotificationChannelsAPIMock struct {
	CreateOpsgenieNotificationChannelCalls    *[]CreateOpsgenieNotificationChannelCall
	CreateOpsgenieNotificationChannelResponse CreateOpsgenieNotificationChannelMockResponse
	CreateWebhookNotificationChannelCalls     *[]CreateWebhookNotificationChannelCall
	CreateWebhookNotificationChannelResponse  CreateWebhookNotificationChannelMockResponse
	DeleteOpsgenieNotificationChannelCalls    *[]DeleteOpsgenieNotificationChannelCall
	DeleteOpsgenieNotificationChannelResponse DeleteOpsgenieNotificationChannelMockResponse
	DeleteSlackNotificationChannelCalls       *[]DeleteSlackNotificationChannelCall
	DeleteSlackNotificationChannelResponse    DeleteSlackNotificationChannelMockResponse
	DeleteWebhookNotificationChannelCalls     *[]DeleteWebhookNotificationChannelCall
	DeleteWebhookNotificationChannelResponse  DeleteWebhookNotificationChannelMockResponse
	GetOpsgenieNotificationChannelCalls       *[]GetOpsgenieNotificationChannelCall
	GetOpsgenieNotificationChannelResponse    GetOpsgenieNotificationChannelMockResponse
	GetSlackNotificationChannelCalls          *[]GetSlackNotificationChannelCall
	GetSlackNotificationChannelResponse       GetSlackNotificationChannelMockResponse
	GetWebhookNotificationChannelCalls        *[]GetWebhookNotificationChannelCall
	GetWebhookNotificationChannelResponse     GetWebhookNotificationChannelMockResponse
	JoinSlackChannelCalls                     *[]JoinSlackChannelCall
	JoinSlackChannelResponse                  JoinSlackChannelMockResponse
	ListOpsgenieRespondersCalls               *[]ListOpsgenieRespondersCall
	ListOpsgenieRespondersResponse            ListOpsgenieRespondersMockResponse
	ListSlackChannelsCalls                    *[]ListSlackChannelsCall
	ListSlackChannelsResponse                 ListSlackChannelsMockResponse
	SlackOAuthCallbackCalls                   *[]SlackOAuthCallbackCall
	SlackOAuthCallbackResponse                SlackOAuthCallbackMockResponse
	SlackOauthRedirectCalls                   *[]SlackOauthRedirectCall
	SlackOauthRedirectResponse                SlackOauthRedirectMockResponse
	TestOpsgenieChannelCalls                  *[]TestOpsgenieChannelCall
	TestOpsgenieChannelResponse               TestOpsgenieChannelMockResponse
	TestSlackChannelCalls                     *[]TestSlackChannelCall
	TestSlackChannelResponse                  TestSlackChannelMockResponse
	TestWebhookChannelCalls                   *[]TestWebhookChannelCall
	TestWebhookChannelResponse                TestWebhookChannelMockResponse
	UpdateOpsgenieNotificationChannelCalls    *[]UpdateOpsgenieNotificationChannelCall
	UpdateOpsgenieNotificationChannelResponse UpdateOpsgenieNotificationChannelMockResponse
	UpdateWebhookNotificationChannelCalls     *[]UpdateWebhookNotificationChannelCall
	UpdateWebhookNotificationChannelResponse  UpdateWebhookNotificationChannelMockResponse
}

func NewNotificationChannelsAPIMock() NotificationChannelsAPIMock {
	xCreateOpsgenieNotificationChannelCalls := make([]CreateOpsgenieNotificationChannelCall, 0)
	xCreateWebhookNotificationChannelCalls := make([]CreateWebhookNotificationChannelCall, 0)
	xDeleteOpsgenieNotificationChannelCalls := make([]DeleteOpsgenieNotificationChannelCall, 0)
	xDeleteSlackNotificationChannelCalls := make([]DeleteSlackNotificationChannelCall, 0)
	xDeleteWebhookNotificationChannelCalls := make([]DeleteWebhookNotificationChannelCall, 0)
	xGetOpsgenieNotificationChannelCalls := make([]GetOpsgenieNotificationChannelCall, 0)
	xGetSlackNotificationChannelCalls := make([]GetSlackNotificationChannelCall, 0)
	xGetWebhookNotificationChannelCalls := make([]GetWebhookNotificationChannelCall, 0)
	xJoinSlackChannelCalls := make([]JoinSlackChannelCall, 0)
	xListOpsgenieRespondersCalls := make([]ListOpsgenieRespondersCall, 0)
	xListSlackChannelsCalls := make([]ListSlackChannelsCall, 0)
	xSlackOAuthCallbackCalls := make([]SlackOAuthCallbackCall, 0)
	xSlackOauthRedirectCalls := make([]SlackOauthRedirectCall, 0)
	xTestOpsgenieChannelCalls := make([]TestOpsgenieChannelCall, 0)
	xTestSlackChannelCalls := make([]TestSlackChannelCall, 0)
	xTestWebhookChannelCalls := make([]TestWebhookChannelCall, 0)
	xUpdateOpsgenieNotificationChannelCalls := make([]UpdateOpsgenieNotificationChannelCall, 0)
	xUpdateWebhookNotificationChannelCalls := make([]UpdateWebhookNotificationChannelCall, 0)
	return NotificationChannelsAPIMock{
		CreateOpsgenieNotificationChannelCalls: &xCreateOpsgenieNotificationChannelCalls,
		CreateWebhookNotificationChannelCalls:  &xCreateWebhookNotificationChannelCalls,
		DeleteOpsgenieNotificationChannelCalls: &xDeleteOpsgenieNotificationChannelCalls,
		DeleteSlackNotificationChannelCalls:    &xDeleteSlackNotificationChannelCalls,
		DeleteWebhookNotificationChannelCalls:  &xDeleteWebhookNotificationChannelCalls,
		GetOpsgenieNotificationChannelCalls:    &xGetOpsgenieNotificationChannelCalls,
		GetSlackNotificationChannelCalls:       &xGetSlackNotificationChannelCalls,
		GetWebhookNotificationChannelCalls:     &xGetWebhookNotificationChannelCalls,
		JoinSlackChannelCalls:                  &xJoinSlackChannelCalls,
		ListOpsgenieRespondersCalls:            &xListOpsgenieRespondersCalls,
		ListSlackChannelsCalls:                 &xListSlackChannelsCalls,
		SlackOAuthCallbackCalls:                &xSlackOAuthCallbackCalls,
		SlackOauthRedirectCalls:                &xSlackOauthRedirectCalls,
		TestOpsgenieChannelCalls:               &xTestOpsgenieChannelCalls,
		TestSlackChannelCalls:                  &xTestSlackChannelCalls,
		TestWebhookChannelCalls:                &xTestWebhookChannelCalls,
		UpdateOpsgenieNotificationChannelCalls: &xUpdateOpsgenieNotificationChannelCalls,
		UpdateWebhookNotificationChannelCalls:  &xUpdateWebhookNotificationChannelCalls,
	}
}

type CreateOpsgenieNotificationChannelMockResponse struct {
	Result   OpsgenieNotificationChannel
	Response *http.Response
	Error    error
}

type CreateOpsgenieNotificationChannelCall struct {
	PopsgenieChannelWriteSchema *OpsgenieChannelWriteSchema
}

func (mock NotificationChannelsAPIMock) CreateOpsgenieNotificationChannel(ctx context.Context) ApiCreateOpsgenieNotificationChannelRequest {
	return ApiCreateOpsgenieNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock NotificationChannelsAPIMock) CreateOpsgenieNotificationChannelExecute(r ApiCreateOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error) {
	p := CreateOpsgenieNotificationChannelCall{
		PopsgenieChannelWriteSchema: r.opsgenieChannelWriteSchema,
	}
	*mock.CreateOpsgenieNotificationChannelCalls = append(*mock.CreateOpsgenieNotificationChannelCalls, p)
	return &mock.CreateOpsgenieNotificationChannelResponse.Result, mock.CreateOpsgenieNotificationChannelResponse.Response, mock.CreateOpsgenieNotificationChannelResponse.Error
}

type CreateWebhookNotificationChannelMockResponse struct {
	Result   WebhookNotificationChannel
	Response *http.Response
	Error    error
}

type CreateWebhookNotificationChannelCall struct {
	PwebhookChannelWriteSchema *WebhookChannelWriteSchema
}

func (mock NotificationChannelsAPIMock) CreateWebhookNotificationChannel(ctx context.Context) ApiCreateWebhookNotificationChannelRequest {
	return ApiCreateWebhookNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock NotificationChannelsAPIMock) CreateWebhookNotificationChannelExecute(r ApiCreateWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error) {
	p := CreateWebhookNotificationChannelCall{
		PwebhookChannelWriteSchema: r.webhookChannelWriteSchema,
	}
	*mock.CreateWebhookNotificationChannelCalls = append(*mock.CreateWebhookNotificationChannelCalls, p)
	return &mock.CreateWebhookNotificationChannelResponse.Result, mock.CreateWebhookNotificationChannelResponse.Response, mock.CreateWebhookNotificationChannelResponse.Error
}

type DeleteOpsgenieNotificationChannelMockResponse struct {
	Response *http.Response
	Error    error
}

type DeleteOpsgenieNotificationChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsAPIMock) DeleteOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiDeleteOpsgenieNotificationChannelRequest {
	return ApiDeleteOpsgenieNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsAPIMock) DeleteOpsgenieNotificationChannelExecute(r ApiDeleteOpsgenieNotificationChannelRequest) (*http.Response, error) {
	p := DeleteOpsgenieNotificationChannelCall{
		PchannelId: r.channelId,
	}
	*mock.DeleteOpsgenieNotificationChannelCalls = append(*mock.DeleteOpsgenieNotificationChannelCalls, p)
	return mock.DeleteOpsgenieNotificationChannelResponse.Response, mock.DeleteOpsgenieNotificationChannelResponse.Error
}

type DeleteSlackNotificationChannelMockResponse struct {
	Response *http.Response
	Error    error
}

type DeleteSlackNotificationChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsAPIMock) DeleteSlackNotificationChannel(ctx context.Context, channelId int64) ApiDeleteSlackNotificationChannelRequest {
	return ApiDeleteSlackNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsAPIMock) DeleteSlackNotificationChannelExecute(r ApiDeleteSlackNotificationChannelRequest) (*http.Response, error) {
	p := DeleteSlackNotificationChannelCall{
		PchannelId: r.channelId,
	}
	*mock.DeleteSlackNotificationChannelCalls = append(*mock.DeleteSlackNotificationChannelCalls, p)
	return mock.DeleteSlackNotificationChannelResponse.Response, mock.DeleteSlackNotificationChannelResponse.Error
}

type DeleteWebhookNotificationChannelMockResponse struct {
	Response *http.Response
	Error    error
}

type DeleteWebhookNotificationChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsAPIMock) DeleteWebhookNotificationChannel(ctx context.Context, channelId int64) ApiDeleteWebhookNotificationChannelRequest {
	return ApiDeleteWebhookNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsAPIMock) DeleteWebhookNotificationChannelExecute(r ApiDeleteWebhookNotificationChannelRequest) (*http.Response, error) {
	p := DeleteWebhookNotificationChannelCall{
		PchannelId: r.channelId,
	}
	*mock.DeleteWebhookNotificationChannelCalls = append(*mock.DeleteWebhookNotificationChannelCalls, p)
	return mock.DeleteWebhookNotificationChannelResponse.Response, mock.DeleteWebhookNotificationChannelResponse.Error
}

type GetOpsgenieNotificationChannelMockResponse struct {
	Result   OpsgenieNotificationChannel
	Response *http.Response
	Error    error
}

type GetOpsgenieNotificationChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsAPIMock) GetOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiGetOpsgenieNotificationChannelRequest {
	return ApiGetOpsgenieNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsAPIMock) GetOpsgenieNotificationChannelExecute(r ApiGetOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error) {
	p := GetOpsgenieNotificationChannelCall{
		PchannelId: r.channelId,
	}
	*mock.GetOpsgenieNotificationChannelCalls = append(*mock.GetOpsgenieNotificationChannelCalls, p)
	return &mock.GetOpsgenieNotificationChannelResponse.Result, mock.GetOpsgenieNotificationChannelResponse.Response, mock.GetOpsgenieNotificationChannelResponse.Error
}

type GetSlackNotificationChannelMockResponse struct {
	Result   SlackNotificationChannel
	Response *http.Response
	Error    error
}

type GetSlackNotificationChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsAPIMock) GetSlackNotificationChannel(ctx context.Context, channelId int64) ApiGetSlackNotificationChannelRequest {
	return ApiGetSlackNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsAPIMock) GetSlackNotificationChannelExecute(r ApiGetSlackNotificationChannelRequest) (*SlackNotificationChannel, *http.Response, error) {
	p := GetSlackNotificationChannelCall{
		PchannelId: r.channelId,
	}
	*mock.GetSlackNotificationChannelCalls = append(*mock.GetSlackNotificationChannelCalls, p)
	return &mock.GetSlackNotificationChannelResponse.Result, mock.GetSlackNotificationChannelResponse.Response, mock.GetSlackNotificationChannelResponse.Error
}

type GetWebhookNotificationChannelMockResponse struct {
	Result   WebhookNotificationChannel
	Response *http.Response
	Error    error
}

type GetWebhookNotificationChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsAPIMock) GetWebhookNotificationChannel(ctx context.Context, channelId int64) ApiGetWebhookNotificationChannelRequest {
	return ApiGetWebhookNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsAPIMock) GetWebhookNotificationChannelExecute(r ApiGetWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error) {
	p := GetWebhookNotificationChannelCall{
		PchannelId: r.channelId,
	}
	*mock.GetWebhookNotificationChannelCalls = append(*mock.GetWebhookNotificationChannelCalls, p)
	return &mock.GetWebhookNotificationChannelResponse.Result, mock.GetWebhookNotificationChannelResponse.Response, mock.GetWebhookNotificationChannelResponse.Error
}

type JoinSlackChannelMockResponse struct {
	Result   SlackNotificationChannel
	Response *http.Response
	Error    error
}

type JoinSlackChannelCall struct {
	PchannelId      int64
	PslackChannelId *SlackChannelId
}

func (mock NotificationChannelsAPIMock) JoinSlackChannel(ctx context.Context, channelId int64) ApiJoinSlackChannelRequest {
	return ApiJoinSlackChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsAPIMock) JoinSlackChannelExecute(r ApiJoinSlackChannelRequest) (*SlackNotificationChannel, *http.Response, error) {
	p := JoinSlackChannelCall{
		PchannelId:      r.channelId,
		PslackChannelId: r.slackChannelId,
	}
	*mock.JoinSlackChannelCalls = append(*mock.JoinSlackChannelCalls, p)
	return &mock.JoinSlackChannelResponse.Result, mock.JoinSlackChannelResponse.Response, mock.JoinSlackChannelResponse.Error
}

type ListOpsgenieRespondersMockResponse struct {
	Result   []OpsgenieResponder
	Response *http.Response
	Error    error
}

type ListOpsgenieRespondersCall struct {
	PgenieKey *string
	Pregion   *string
}

func (mock NotificationChannelsAPIMock) ListOpsgenieResponders(ctx context.Context) ApiListOpsgenieRespondersRequest {
	return ApiListOpsgenieRespondersRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock NotificationChannelsAPIMock) ListOpsgenieRespondersExecute(r ApiListOpsgenieRespondersRequest) ([]OpsgenieResponder, *http.Response, error) {
	p := ListOpsgenieRespondersCall{
		PgenieKey: r.genieKey,
		Pregion:   r.region,
	}
	*mock.ListOpsgenieRespondersCalls = append(*mock.ListOpsgenieRespondersCalls, p)
	return mock.ListOpsgenieRespondersResponse.Result, mock.ListOpsgenieRespondersResponse.Response, mock.ListOpsgenieRespondersResponse.Error
}

type ListSlackChannelsMockResponse struct {
	Result   []SlackChannel
	Response *http.Response
	Error    error
}

type ListSlackChannelsCall struct {
	PchannelId int64
}

func (mock NotificationChannelsAPIMock) ListSlackChannels(ctx context.Context, channelId int64) ApiListSlackChannelsRequest {
	return ApiListSlackChannelsRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsAPIMock) ListSlackChannelsExecute(r ApiListSlackChannelsRequest) ([]SlackChannel, *http.Response, error) {
	p := ListSlackChannelsCall{
		PchannelId: r.channelId,
	}
	*mock.ListSlackChannelsCalls = append(*mock.ListSlackChannelsCalls, p)
	return mock.ListSlackChannelsResponse.Result, mock.ListSlackChannelsResponse.Response, mock.ListSlackChannelsResponse.Error
}

type SlackOAuthCallbackMockResponse struct {
	Response *http.Response
	Error    error
}

type SlackOAuthCallbackCall struct {
	Pstate  *string
	Pcode   *string
	Perror_ *string
}

func (mock NotificationChannelsAPIMock) SlackOAuthCallback(ctx context.Context) ApiSlackOAuthCallbackRequest {
	return ApiSlackOAuthCallbackRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock NotificationChannelsAPIMock) SlackOAuthCallbackExecute(r ApiSlackOAuthCallbackRequest) (*http.Response, error) {
	p := SlackOAuthCallbackCall{
		Pstate:  r.state,
		Pcode:   r.code,
		Perror_: r.error_,
	}
	*mock.SlackOAuthCallbackCalls = append(*mock.SlackOAuthCallbackCalls, p)
	return mock.SlackOAuthCallbackResponse.Response, mock.SlackOAuthCallbackResponse.Error
}

type SlackOauthRedirectMockResponse struct {
	Response *http.Response
	Error    error
}

type SlackOauthRedirectCall struct {
	PredirectPath *string
}

func (mock NotificationChannelsAPIMock) SlackOauthRedirect(ctx context.Context) ApiSlackOauthRedirectRequest {
	return ApiSlackOauthRedirectRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock NotificationChannelsAPIMock) SlackOauthRedirectExecute(r ApiSlackOauthRedirectRequest) (*http.Response, error) {
	p := SlackOauthRedirectCall{
		PredirectPath: r.redirectPath,
	}
	*mock.SlackOauthRedirectCalls = append(*mock.SlackOauthRedirectCalls, p)
	return mock.SlackOauthRedirectResponse.Response, mock.SlackOauthRedirectResponse.Error
}

type TestOpsgenieChannelMockResponse struct {
	Response *http.Response
	Error    error
}

type TestOpsgenieChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsAPIMock) TestOpsgenieChannel(ctx context.Context, channelId int64) ApiTestOpsgenieChannelRequest {
	return ApiTestOpsgenieChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsAPIMock) TestOpsgenieChannelExecute(r ApiTestOpsgenieChannelRequest) (*http.Response, error) {
	p := TestOpsgenieChannelCall{
		PchannelId: r.channelId,
	}
	*mock.TestOpsgenieChannelCalls = append(*mock.TestOpsgenieChannelCalls, p)
	return mock.TestOpsgenieChannelResponse.Response, mock.TestOpsgenieChannelResponse.Error
}

type TestSlackChannelMockResponse struct {
	Response *http.Response
	Error    error
}

type TestSlackChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsAPIMock) TestSlackChannel(ctx context.Context, channelId int64) ApiTestSlackChannelRequest {
	return ApiTestSlackChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsAPIMock) TestSlackChannelExecute(r ApiTestSlackChannelRequest) (*http.Response, error) {
	p := TestSlackChannelCall{
		PchannelId: r.channelId,
	}
	*mock.TestSlackChannelCalls = append(*mock.TestSlackChannelCalls, p)
	return mock.TestSlackChannelResponse.Response, mock.TestSlackChannelResponse.Error
}

type TestWebhookChannelMockResponse struct {
	Response *http.Response
	Error    error
}

type TestWebhookChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsAPIMock) TestWebhookChannel(ctx context.Context, channelId int64) ApiTestWebhookChannelRequest {
	return ApiTestWebhookChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsAPIMock) TestWebhookChannelExecute(r ApiTestWebhookChannelRequest) (*http.Response, error) {
	p := TestWebhookChannelCall{
		PchannelId: r.channelId,
	}
	*mock.TestWebhookChannelCalls = append(*mock.TestWebhookChannelCalls, p)
	return mock.TestWebhookChannelResponse.Response, mock.TestWebhookChannelResponse.Error
}

type UpdateOpsgenieNotificationChannelMockResponse struct {
	Result   OpsgenieNotificationChannel
	Response *http.Response
	Error    error
}

type UpdateOpsgenieNotificationChannelCall struct {
	PchannelId                  int64
	PopsgenieChannelWriteSchema *OpsgenieChannelWriteSchema
}

func (mock NotificationChannelsAPIMock) UpdateOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiUpdateOpsgenieNotificationChannelRequest {
	return ApiUpdateOpsgenieNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsAPIMock) UpdateOpsgenieNotificationChannelExecute(r ApiUpdateOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error) {
	p := UpdateOpsgenieNotificationChannelCall{
		PchannelId:                  r.channelId,
		PopsgenieChannelWriteSchema: r.opsgenieChannelWriteSchema,
	}
	*mock.UpdateOpsgenieNotificationChannelCalls = append(*mock.UpdateOpsgenieNotificationChannelCalls, p)
	return &mock.UpdateOpsgenieNotificationChannelResponse.Result, mock.UpdateOpsgenieNotificationChannelResponse.Response, mock.UpdateOpsgenieNotificationChannelResponse.Error
}

type UpdateWebhookNotificationChannelMockResponse struct {
	Result   WebhookNotificationChannel
	Response *http.Response
	Error    error
}

type UpdateWebhookNotificationChannelCall struct {
	PchannelId                 int64
	PwebhookChannelWriteSchema *WebhookChannelWriteSchema
}

func (mock NotificationChannelsAPIMock) UpdateWebhookNotificationChannel(ctx context.Context, channelId int64) ApiUpdateWebhookNotificationChannelRequest {
	return ApiUpdateWebhookNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsAPIMock) UpdateWebhookNotificationChannelExecute(r ApiUpdateWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error) {
	p := UpdateWebhookNotificationChannelCall{
		PchannelId:                 r.channelId,
		PwebhookChannelWriteSchema: r.webhookChannelWriteSchema,
	}
	*mock.UpdateWebhookNotificationChannelCalls = append(*mock.UpdateWebhookNotificationChannelCalls, p)
	return &mock.UpdateWebhookNotificationChannelResponse.Result, mock.UpdateWebhookNotificationChannelResponse.Response, mock.UpdateWebhookNotificationChannelResponse.Error
}
