/*
StackState API

This API documentation page describes the StackState server API. The StackState UI and CLI use the StackState server API to configure and query StackState.  You can use the API for similar purposes.  Each request sent to the StackState server API must be authenticated using one of the available authentication methods.   *Note that the StackState receiver API, used to send topology, telemetry and traces to StackState, is not described on this page and requires a different authentication method.*  For more information on StackState, refer to the [StackState documentation](https://docs.stackstate.com).

API version: 5.2.0
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackstate_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

type NotificationChannelsApi interface {

	/*
		CreateEmailNotificationChannel Create a Email Notification channel

		Create Email Notification channel

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateEmailNotificationChannelRequest
	*/
	CreateEmailNotificationChannel(ctx context.Context) ApiCreateEmailNotificationChannelRequest

	// CreateEmailNotificationChannelExecute executes the request
	//  @return EmailNotificationChannel
	CreateEmailNotificationChannelExecute(r ApiCreateEmailNotificationChannelRequest) (*EmailNotificationChannel, *http.Response, error)

	/*
		CreateOpsgenieNotificationChannel Create a Opsgenie Notification channel

		Create a Opsgenie Notification channel

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateOpsgenieNotificationChannelRequest
	*/
	CreateOpsgenieNotificationChannel(ctx context.Context) ApiCreateOpsgenieNotificationChannelRequest

	// CreateOpsgenieNotificationChannelExecute executes the request
	//  @return OpsgenieNotificationChannel
	CreateOpsgenieNotificationChannelExecute(r ApiCreateOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error)

	/*
		CreateTeamsNotificationChannel Create a Teams Notification channel

		Create a Teams Notification channel

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateTeamsNotificationChannelRequest
	*/
	CreateTeamsNotificationChannel(ctx context.Context) ApiCreateTeamsNotificationChannelRequest

	// CreateTeamsNotificationChannelExecute executes the request
	//  @return TeamsNotificationChannel
	CreateTeamsNotificationChannelExecute(r ApiCreateTeamsNotificationChannelRequest) (*TeamsNotificationChannel, *http.Response, error)

	/*
		CreateWebhookNotificationChannel Create a Webhook Notification channel

		Create a Webhook Notification channel

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateWebhookNotificationChannelRequest
	*/
	CreateWebhookNotificationChannel(ctx context.Context) ApiCreateWebhookNotificationChannelRequest

	// CreateWebhookNotificationChannelExecute executes the request
	//  @return WebhookNotificationChannel
	CreateWebhookNotificationChannelExecute(r ApiCreateWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error)

	/*
		DeleteEmailNotificationChannel Delete the Email Notification channel by id

		Delete the email notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiDeleteEmailNotificationChannelRequest
	*/
	DeleteEmailNotificationChannel(ctx context.Context, channelId int64) ApiDeleteEmailNotificationChannelRequest

	// DeleteEmailNotificationChannelExecute executes the request
	DeleteEmailNotificationChannelExecute(r ApiDeleteEmailNotificationChannelRequest) (*http.Response, error)

	/*
		DeleteOpsgenieNotificationChannel Delete the Opsgenie Notification channel by id

		Delete the opsgenie notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiDeleteOpsgenieNotificationChannelRequest
	*/
	DeleteOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiDeleteOpsgenieNotificationChannelRequest

	// DeleteOpsgenieNotificationChannelExecute executes the request
	DeleteOpsgenieNotificationChannelExecute(r ApiDeleteOpsgenieNotificationChannelRequest) (*http.Response, error)

	/*
		DeleteSlackNotificationChannel Delete the Slack Notification channel by id

		Delete the slack notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiDeleteSlackNotificationChannelRequest
	*/
	DeleteSlackNotificationChannel(ctx context.Context, channelId int64) ApiDeleteSlackNotificationChannelRequest

	// DeleteSlackNotificationChannelExecute executes the request
	DeleteSlackNotificationChannelExecute(r ApiDeleteSlackNotificationChannelRequest) (*http.Response, error)

	/*
		DeleteTeamsNotificationChannel Delete the Teams Notification channel by id

		Delete the teams notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiDeleteTeamsNotificationChannelRequest
	*/
	DeleteTeamsNotificationChannel(ctx context.Context, channelId int64) ApiDeleteTeamsNotificationChannelRequest

	// DeleteTeamsNotificationChannelExecute executes the request
	DeleteTeamsNotificationChannelExecute(r ApiDeleteTeamsNotificationChannelRequest) (*http.Response, error)

	/*
		DeleteWebhookNotificationChannel Delete the Webhook Notification channel by id

		Delete the webhook notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiDeleteWebhookNotificationChannelRequest
	*/
	DeleteWebhookNotificationChannel(ctx context.Context, channelId int64) ApiDeleteWebhookNotificationChannelRequest

	// DeleteWebhookNotificationChannelExecute executes the request
	DeleteWebhookNotificationChannelExecute(r ApiDeleteWebhookNotificationChannelRequest) (*http.Response, error)

	/*
		GetEmailNotificationChannel Get the Email Notification channel by id

		Get the email notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiGetEmailNotificationChannelRequest
	*/
	GetEmailNotificationChannel(ctx context.Context, channelId int64) ApiGetEmailNotificationChannelRequest

	// GetEmailNotificationChannelExecute executes the request
	//  @return EmailNotificationChannel
	GetEmailNotificationChannelExecute(r ApiGetEmailNotificationChannelRequest) (*EmailNotificationChannel, *http.Response, error)

	/*
		GetEmailNotificationStatus Email Notification channel status

		Email Notification channel status, test whether it can be used

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetEmailNotificationStatusRequest
	*/
	GetEmailNotificationStatus(ctx context.Context) ApiGetEmailNotificationStatusRequest

	// GetEmailNotificationStatusExecute executes the request
	//  @return EmailNotificationStatus
	GetEmailNotificationStatusExecute(r ApiGetEmailNotificationStatusRequest) (*EmailNotificationStatus, *http.Response, error)

	/*
		GetOpsgenieNotificationChannel Get the Opsgenie Notification channel by id

		Get the opsgenie notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiGetOpsgenieNotificationChannelRequest
	*/
	GetOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiGetOpsgenieNotificationChannelRequest

	// GetOpsgenieNotificationChannelExecute executes the request
	//  @return OpsgenieNotificationChannel
	GetOpsgenieNotificationChannelExecute(r ApiGetOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error)

	/*
		GetSlackNotificationChannel Get the Slack Notification channel by id

		Get the slack notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiGetSlackNotificationChannelRequest
	*/
	GetSlackNotificationChannel(ctx context.Context, channelId int64) ApiGetSlackNotificationChannelRequest

	// GetSlackNotificationChannelExecute executes the request
	//  @return SlackNotificationChannel
	GetSlackNotificationChannelExecute(r ApiGetSlackNotificationChannelRequest) (*SlackNotificationChannel, *http.Response, error)

	/*
		GetTeamsNotificationChannel Get the Teams Notification channel by id

		Get the teams notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiGetTeamsNotificationChannelRequest
	*/
	GetTeamsNotificationChannel(ctx context.Context, channelId int64) ApiGetTeamsNotificationChannelRequest

	// GetTeamsNotificationChannelExecute executes the request
	//  @return TeamsNotificationChannel
	GetTeamsNotificationChannelExecute(r ApiGetTeamsNotificationChannelRequest) (*TeamsNotificationChannel, *http.Response, error)

	/*
		GetWebhookNotificationChannel Get the Webhook Notification channel by id

		Get the webhook notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiGetWebhookNotificationChannelRequest
	*/
	GetWebhookNotificationChannel(ctx context.Context, channelId int64) ApiGetWebhookNotificationChannelRequest

	// GetWebhookNotificationChannelExecute executes the request
	//  @return WebhookNotificationChannel
	GetWebhookNotificationChannelExecute(r ApiGetWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error)

	/*
		JoinSlackChannel Join the specified Slack channel to send notifications

		Join the specified Slack channel and configure this notifiation channel to post notifications to the specified slack channel.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiJoinSlackChannelRequest
	*/
	JoinSlackChannel(ctx context.Context, channelId int64) ApiJoinSlackChannelRequest

	// JoinSlackChannelExecute executes the request
	//  @return SlackNotificationChannel
	JoinSlackChannelExecute(r ApiJoinSlackChannelRequest) (*SlackNotificationChannel, *http.Response, error)

	/*
		ListOpsgenieResponders List Opsgenie responders

		List Opsgenie responders

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListOpsgenieRespondersRequest
	*/
	ListOpsgenieResponders(ctx context.Context) ApiListOpsgenieRespondersRequest

	// ListOpsgenieRespondersExecute executes the request
	//  @return []OpsgenieResponder
	ListOpsgenieRespondersExecute(r ApiListOpsgenieRespondersRequest) ([]OpsgenieResponder, *http.Response, error)

	/*
		ListSlackChannels List all public Slack channels

		List all public Slack channels, used for selecting a channel for the notifications

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiListSlackChannelsRequest
	*/
	ListSlackChannels(ctx context.Context, channelId int64) ApiListSlackChannelsRequest

	// ListSlackChannelsExecute executes the request
	//  @return []SlackChannel
	ListSlackChannelsExecute(r ApiListSlackChannelsRequest) ([]SlackChannel, *http.Response, error)

	/*
		SlackOAuthCallback The OAuth callback for Slack

		The OAuth callback for Slack, which is used to obtain the access token for the Slack channel.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiSlackOAuthCallbackRequest
	*/
	SlackOAuthCallback(ctx context.Context) ApiSlackOAuthCallbackRequest

	// SlackOAuthCallbackExecute executes the request
	SlackOAuthCallbackExecute(r ApiSlackOAuthCallbackRequest) (*http.Response, error)

	/*
		SlackOauthRedirect Starts Slack OAuth2 flow

		Redirects to Slack to start an OAuth2 flow.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiSlackOauthRedirectRequest
	*/
	SlackOauthRedirect(ctx context.Context) ApiSlackOauthRedirectRequest

	// SlackOauthRedirectExecute executes the request
	SlackOauthRedirectExecute(r ApiSlackOauthRedirectRequest) (*http.Response, error)

	/*
		TestEmailChannel Test the Email notification channel

		Test the email notification channel by sending a test message to the notification channel.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiTestEmailChannelRequest
	*/
	TestEmailChannel(ctx context.Context, channelId int64) ApiTestEmailChannelRequest

	// TestEmailChannelExecute executes the request
	TestEmailChannelExecute(r ApiTestEmailChannelRequest) (*http.Response, error)

	/*
		TestOpsgenieChannel Test the Opsgenie notification channel

		Test the opsgenie notification channel by sending a test message to the notification channel.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiTestOpsgenieChannelRequest
	*/
	TestOpsgenieChannel(ctx context.Context, channelId int64) ApiTestOpsgenieChannelRequest

	// TestOpsgenieChannelExecute executes the request
	TestOpsgenieChannelExecute(r ApiTestOpsgenieChannelRequest) (*http.Response, error)

	/*
		TestSlackChannel Test the Notification channel

		Test the Notification channel by sending a test message to the notification channel.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiTestSlackChannelRequest
	*/
	TestSlackChannel(ctx context.Context, channelId int64) ApiTestSlackChannelRequest

	// TestSlackChannelExecute executes the request
	TestSlackChannelExecute(r ApiTestSlackChannelRequest) (*http.Response, error)

	/*
		TestTeamsChannel Test the Teams notification channel

		Test the teams notification channel by sending a test message to the notification channel.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiTestTeamsChannelRequest
	*/
	TestTeamsChannel(ctx context.Context, channelId int64) ApiTestTeamsChannelRequest

	// TestTeamsChannelExecute executes the request
	TestTeamsChannelExecute(r ApiTestTeamsChannelRequest) (*http.Response, error)

	/*
		TestWebhookChannel Test the Webhook notification channel

		Test the webhook notification channel by sending a test message to the notification channel.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiTestWebhookChannelRequest
	*/
	TestWebhookChannel(ctx context.Context, channelId int64) ApiTestWebhookChannelRequest

	// TestWebhookChannelExecute executes the request
	TestWebhookChannelExecute(r ApiTestWebhookChannelRequest) (*http.Response, error)

	/*
		UpdateEmailNotificationChannel Update the Email Notification channel by id

		Update the email notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiUpdateEmailNotificationChannelRequest
	*/
	UpdateEmailNotificationChannel(ctx context.Context, channelId int64) ApiUpdateEmailNotificationChannelRequest

	// UpdateEmailNotificationChannelExecute executes the request
	//  @return EmailNotificationChannel
	UpdateEmailNotificationChannelExecute(r ApiUpdateEmailNotificationChannelRequest) (*EmailNotificationChannel, *http.Response, error)

	/*
		UpdateOpsgenieNotificationChannel Update the Opsgenie Notification channel by id

		Update the opsgenie notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiUpdateOpsgenieNotificationChannelRequest
	*/
	UpdateOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiUpdateOpsgenieNotificationChannelRequest

	// UpdateOpsgenieNotificationChannelExecute executes the request
	//  @return OpsgenieNotificationChannel
	UpdateOpsgenieNotificationChannelExecute(r ApiUpdateOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error)

	/*
		UpdateTeamsNotificationChannel Update the Teams Notification channel by id

		Update the teams notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiUpdateTeamsNotificationChannelRequest
	*/
	UpdateTeamsNotificationChannel(ctx context.Context, channelId int64) ApiUpdateTeamsNotificationChannelRequest

	// UpdateTeamsNotificationChannelExecute executes the request
	//  @return TeamsNotificationChannel
	UpdateTeamsNotificationChannelExecute(r ApiUpdateTeamsNotificationChannelRequest) (*TeamsNotificationChannel, *http.Response, error)

	/*
		UpdateWebhookNotificationChannel Update the Webhook Notification channel by id

		Update the webhook notification channel by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param channelId Channel identifier
		@return ApiUpdateWebhookNotificationChannelRequest
	*/
	UpdateWebhookNotificationChannel(ctx context.Context, channelId int64) ApiUpdateWebhookNotificationChannelRequest

	// UpdateWebhookNotificationChannelExecute executes the request
	//  @return WebhookNotificationChannel
	UpdateWebhookNotificationChannelExecute(r ApiUpdateWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error)
}

// NotificationChannelsApiService NotificationChannelsApi service
type NotificationChannelsApiService service

type ApiCreateEmailNotificationChannelRequest struct {
	ctx                     context.Context
	ApiService              NotificationChannelsApi
	emailChannelWriteSchema *EmailChannelWriteSchema
}

// Create or update a email channel
func (r ApiCreateEmailNotificationChannelRequest) EmailChannelWriteSchema(emailChannelWriteSchema EmailChannelWriteSchema) ApiCreateEmailNotificationChannelRequest {
	r.emailChannelWriteSchema = &emailChannelWriteSchema
	return r
}

func (r ApiCreateEmailNotificationChannelRequest) Execute() (*EmailNotificationChannel, *http.Response, error) {
	return r.ApiService.CreateEmailNotificationChannelExecute(r)
}

/*
CreateEmailNotificationChannel Create a Email Notification channel

Create Email Notification channel

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateEmailNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) CreateEmailNotificationChannel(ctx context.Context) ApiCreateEmailNotificationChannelRequest {
	return ApiCreateEmailNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return EmailNotificationChannel
func (a *NotificationChannelsApiService) CreateEmailNotificationChannelExecute(r ApiCreateEmailNotificationChannelRequest) (*EmailNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EmailNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.CreateEmailNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/email"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.emailChannelWriteSchema == nil {
		return localVarReturnValue, nil, reportError("emailChannelWriteSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.emailChannelWriteSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOpsgenieNotificationChannelRequest struct {
	ctx                        context.Context
	ApiService                 NotificationChannelsApi
	opsgenieChannelWriteSchema *OpsgenieChannelWriteSchema
}

// Create or update a opsgenie channel
func (r ApiCreateOpsgenieNotificationChannelRequest) OpsgenieChannelWriteSchema(opsgenieChannelWriteSchema OpsgenieChannelWriteSchema) ApiCreateOpsgenieNotificationChannelRequest {
	r.opsgenieChannelWriteSchema = &opsgenieChannelWriteSchema
	return r
}

func (r ApiCreateOpsgenieNotificationChannelRequest) Execute() (*OpsgenieNotificationChannel, *http.Response, error) {
	return r.ApiService.CreateOpsgenieNotificationChannelExecute(r)
}

/*
CreateOpsgenieNotificationChannel Create a Opsgenie Notification channel

Create a Opsgenie Notification channel

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOpsgenieNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) CreateOpsgenieNotificationChannel(ctx context.Context) ApiCreateOpsgenieNotificationChannelRequest {
	return ApiCreateOpsgenieNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OpsgenieNotificationChannel
func (a *NotificationChannelsApiService) CreateOpsgenieNotificationChannelExecute(r ApiCreateOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OpsgenieNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.CreateOpsgenieNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/opsgenie"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.opsgenieChannelWriteSchema == nil {
		return localVarReturnValue, nil, reportError("opsgenieChannelWriteSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opsgenieChannelWriteSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTeamsNotificationChannelRequest struct {
	ctx                     context.Context
	ApiService              NotificationChannelsApi
	teamsChannelWriteSchema *TeamsChannelWriteSchema
}

// Create or update a teams channel
func (r ApiCreateTeamsNotificationChannelRequest) TeamsChannelWriteSchema(teamsChannelWriteSchema TeamsChannelWriteSchema) ApiCreateTeamsNotificationChannelRequest {
	r.teamsChannelWriteSchema = &teamsChannelWriteSchema
	return r
}

func (r ApiCreateTeamsNotificationChannelRequest) Execute() (*TeamsNotificationChannel, *http.Response, error) {
	return r.ApiService.CreateTeamsNotificationChannelExecute(r)
}

/*
CreateTeamsNotificationChannel Create a Teams Notification channel

Create a Teams Notification channel

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTeamsNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) CreateTeamsNotificationChannel(ctx context.Context) ApiCreateTeamsNotificationChannelRequest {
	return ApiCreateTeamsNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return TeamsNotificationChannel
func (a *NotificationChannelsApiService) CreateTeamsNotificationChannelExecute(r ApiCreateTeamsNotificationChannelRequest) (*TeamsNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TeamsNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.CreateTeamsNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/teams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.teamsChannelWriteSchema == nil {
		return localVarReturnValue, nil, reportError("teamsChannelWriteSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsChannelWriteSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateWebhookNotificationChannelRequest struct {
	ctx                       context.Context
	ApiService                NotificationChannelsApi
	webhookChannelWriteSchema *WebhookChannelWriteSchema
}

// Create or update a webhook channel
func (r ApiCreateWebhookNotificationChannelRequest) WebhookChannelWriteSchema(webhookChannelWriteSchema WebhookChannelWriteSchema) ApiCreateWebhookNotificationChannelRequest {
	r.webhookChannelWriteSchema = &webhookChannelWriteSchema
	return r
}

func (r ApiCreateWebhookNotificationChannelRequest) Execute() (*WebhookNotificationChannel, *http.Response, error) {
	return r.ApiService.CreateWebhookNotificationChannelExecute(r)
}

/*
CreateWebhookNotificationChannel Create a Webhook Notification channel

Create a Webhook Notification channel

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateWebhookNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) CreateWebhookNotificationChannel(ctx context.Context) ApiCreateWebhookNotificationChannelRequest {
	return ApiCreateWebhookNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return WebhookNotificationChannel
func (a *NotificationChannelsApiService) CreateWebhookNotificationChannelExecute(r ApiCreateWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebhookNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.CreateWebhookNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/webhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.webhookChannelWriteSchema == nil {
		return localVarReturnValue, nil, reportError("webhookChannelWriteSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookChannelWriteSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteEmailNotificationChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	channelId  int64
}

func (r ApiDeleteEmailNotificationChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEmailNotificationChannelExecute(r)
}

/*
DeleteEmailNotificationChannel Delete the Email Notification channel by id

Delete the email notification channel by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiDeleteEmailNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) DeleteEmailNotificationChannel(ctx context.Context, channelId int64) ApiDeleteEmailNotificationChannelRequest {
	return ApiDeleteEmailNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *NotificationChannelsApiService) DeleteEmailNotificationChannelExecute(r ApiDeleteEmailNotificationChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.DeleteEmailNotificationChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/email/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteOpsgenieNotificationChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	channelId  int64
}

func (r ApiDeleteOpsgenieNotificationChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteOpsgenieNotificationChannelExecute(r)
}

/*
DeleteOpsgenieNotificationChannel Delete the Opsgenie Notification channel by id

Delete the opsgenie notification channel by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiDeleteOpsgenieNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) DeleteOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiDeleteOpsgenieNotificationChannelRequest {
	return ApiDeleteOpsgenieNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *NotificationChannelsApiService) DeleteOpsgenieNotificationChannelExecute(r ApiDeleteOpsgenieNotificationChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.DeleteOpsgenieNotificationChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/opsgenie/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSlackNotificationChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	channelId  int64
}

func (r ApiDeleteSlackNotificationChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSlackNotificationChannelExecute(r)
}

/*
DeleteSlackNotificationChannel Delete the Slack Notification channel by id

Delete the slack notification channel by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiDeleteSlackNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) DeleteSlackNotificationChannel(ctx context.Context, channelId int64) ApiDeleteSlackNotificationChannelRequest {
	return ApiDeleteSlackNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *NotificationChannelsApiService) DeleteSlackNotificationChannelExecute(r ApiDeleteSlackNotificationChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.DeleteSlackNotificationChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/slack/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTeamsNotificationChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	channelId  int64
}

func (r ApiDeleteTeamsNotificationChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTeamsNotificationChannelExecute(r)
}

/*
DeleteTeamsNotificationChannel Delete the Teams Notification channel by id

Delete the teams notification channel by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiDeleteTeamsNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) DeleteTeamsNotificationChannel(ctx context.Context, channelId int64) ApiDeleteTeamsNotificationChannelRequest {
	return ApiDeleteTeamsNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *NotificationChannelsApiService) DeleteTeamsNotificationChannelExecute(r ApiDeleteTeamsNotificationChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.DeleteTeamsNotificationChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/teams/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteWebhookNotificationChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	channelId  int64
}

func (r ApiDeleteWebhookNotificationChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteWebhookNotificationChannelExecute(r)
}

/*
DeleteWebhookNotificationChannel Delete the Webhook Notification channel by id

Delete the webhook notification channel by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiDeleteWebhookNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) DeleteWebhookNotificationChannel(ctx context.Context, channelId int64) ApiDeleteWebhookNotificationChannelRequest {
	return ApiDeleteWebhookNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *NotificationChannelsApiService) DeleteWebhookNotificationChannelExecute(r ApiDeleteWebhookNotificationChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.DeleteWebhookNotificationChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/webhook/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEmailNotificationChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	channelId  int64
}

func (r ApiGetEmailNotificationChannelRequest) Execute() (*EmailNotificationChannel, *http.Response, error) {
	return r.ApiService.GetEmailNotificationChannelExecute(r)
}

/*
GetEmailNotificationChannel Get the Email Notification channel by id

Get the email notification channel by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiGetEmailNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) GetEmailNotificationChannel(ctx context.Context, channelId int64) ApiGetEmailNotificationChannelRequest {
	return ApiGetEmailNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//  @return EmailNotificationChannel
func (a *NotificationChannelsApiService) GetEmailNotificationChannelExecute(r ApiGetEmailNotificationChannelRequest) (*EmailNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EmailNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.GetEmailNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/email/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEmailNotificationStatusRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
}

func (r ApiGetEmailNotificationStatusRequest) Execute() (*EmailNotificationStatus, *http.Response, error) {
	return r.ApiService.GetEmailNotificationStatusExecute(r)
}

/*
GetEmailNotificationStatus Email Notification channel status

Email Notification channel status, test whether it can be used

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEmailNotificationStatusRequest
*/
func (a *NotificationChannelsApiService) GetEmailNotificationStatus(ctx context.Context) ApiGetEmailNotificationStatusRequest {
	return ApiGetEmailNotificationStatusRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return EmailNotificationStatus
func (a *NotificationChannelsApiService) GetEmailNotificationStatusExecute(r ApiGetEmailNotificationStatusRequest) (*EmailNotificationStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EmailNotificationStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.GetEmailNotificationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/email/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOpsgenieNotificationChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	channelId  int64
}

func (r ApiGetOpsgenieNotificationChannelRequest) Execute() (*OpsgenieNotificationChannel, *http.Response, error) {
	return r.ApiService.GetOpsgenieNotificationChannelExecute(r)
}

/*
GetOpsgenieNotificationChannel Get the Opsgenie Notification channel by id

Get the opsgenie notification channel by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiGetOpsgenieNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) GetOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiGetOpsgenieNotificationChannelRequest {
	return ApiGetOpsgenieNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//  @return OpsgenieNotificationChannel
func (a *NotificationChannelsApiService) GetOpsgenieNotificationChannelExecute(r ApiGetOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OpsgenieNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.GetOpsgenieNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/opsgenie/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSlackNotificationChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	channelId  int64
}

func (r ApiGetSlackNotificationChannelRequest) Execute() (*SlackNotificationChannel, *http.Response, error) {
	return r.ApiService.GetSlackNotificationChannelExecute(r)
}

/*
GetSlackNotificationChannel Get the Slack Notification channel by id

Get the slack notification channel by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiGetSlackNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) GetSlackNotificationChannel(ctx context.Context, channelId int64) ApiGetSlackNotificationChannelRequest {
	return ApiGetSlackNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//  @return SlackNotificationChannel
func (a *NotificationChannelsApiService) GetSlackNotificationChannelExecute(r ApiGetSlackNotificationChannelRequest) (*SlackNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SlackNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.GetSlackNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/slack/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTeamsNotificationChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	channelId  int64
}

func (r ApiGetTeamsNotificationChannelRequest) Execute() (*TeamsNotificationChannel, *http.Response, error) {
	return r.ApiService.GetTeamsNotificationChannelExecute(r)
}

/*
GetTeamsNotificationChannel Get the Teams Notification channel by id

Get the teams notification channel by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiGetTeamsNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) GetTeamsNotificationChannel(ctx context.Context, channelId int64) ApiGetTeamsNotificationChannelRequest {
	return ApiGetTeamsNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//  @return TeamsNotificationChannel
func (a *NotificationChannelsApiService) GetTeamsNotificationChannelExecute(r ApiGetTeamsNotificationChannelRequest) (*TeamsNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TeamsNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.GetTeamsNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/teams/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetWebhookNotificationChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	channelId  int64
}

func (r ApiGetWebhookNotificationChannelRequest) Execute() (*WebhookNotificationChannel, *http.Response, error) {
	return r.ApiService.GetWebhookNotificationChannelExecute(r)
}

/*
GetWebhookNotificationChannel Get the Webhook Notification channel by id

Get the webhook notification channel by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiGetWebhookNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) GetWebhookNotificationChannel(ctx context.Context, channelId int64) ApiGetWebhookNotificationChannelRequest {
	return ApiGetWebhookNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//  @return WebhookNotificationChannel
func (a *NotificationChannelsApiService) GetWebhookNotificationChannelExecute(r ApiGetWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebhookNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.GetWebhookNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/webhook/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJoinSlackChannelRequest struct {
	ctx            context.Context
	ApiService     NotificationChannelsApi
	channelId      int64
	slackChannelId *SlackChannelId
}

// Provide a Slack channel id to join the specified Slack channel
func (r ApiJoinSlackChannelRequest) SlackChannelId(slackChannelId SlackChannelId) ApiJoinSlackChannelRequest {
	r.slackChannelId = &slackChannelId
	return r
}

func (r ApiJoinSlackChannelRequest) Execute() (*SlackNotificationChannel, *http.Response, error) {
	return r.ApiService.JoinSlackChannelExecute(r)
}

/*
JoinSlackChannel Join the specified Slack channel to send notifications

Join the specified Slack channel and configure this notifiation channel to post notifications to the specified slack channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiJoinSlackChannelRequest
*/
func (a *NotificationChannelsApiService) JoinSlackChannel(ctx context.Context, channelId int64) ApiJoinSlackChannelRequest {
	return ApiJoinSlackChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//  @return SlackNotificationChannel
func (a *NotificationChannelsApiService) JoinSlackChannelExecute(r ApiJoinSlackChannelRequest) (*SlackNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SlackNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.JoinSlackChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/slack/{channelId}/joinSlackChannel"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.slackChannelId == nil {
		return localVarReturnValue, nil, reportError("slackChannelId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.slackChannelId
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOpsgenieRespondersRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	genieKey   *string
	region     *OpsgenieRegion
}

// OpsGenie API key
func (r ApiListOpsgenieRespondersRequest) GenieKey(genieKey string) ApiListOpsgenieRespondersRequest {
	r.genieKey = &genieKey
	return r
}

// OpsGenie region
func (r ApiListOpsgenieRespondersRequest) Region(region OpsgenieRegion) ApiListOpsgenieRespondersRequest {
	r.region = &region
	return r
}

func (r ApiListOpsgenieRespondersRequest) Execute() ([]OpsgenieResponder, *http.Response, error) {
	return r.ApiService.ListOpsgenieRespondersExecute(r)
}

/*
ListOpsgenieResponders List Opsgenie responders

List Opsgenie responders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOpsgenieRespondersRequest
*/
func (a *NotificationChannelsApiService) ListOpsgenieResponders(ctx context.Context) ApiListOpsgenieRespondersRequest {
	return ApiListOpsgenieRespondersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []OpsgenieResponder
func (a *NotificationChannelsApiService) ListOpsgenieRespondersExecute(r ApiListOpsgenieRespondersRequest) ([]OpsgenieResponder, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []OpsgenieResponder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.ListOpsgenieResponders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/opsgenie/responders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.genieKey == nil {
		return localVarReturnValue, nil, reportError("genieKey is required and must be specified")
	}
	if r.region == nil {
		return localVarReturnValue, nil, reportError("region is required and must be specified")
	}

	localVarQueryParams.Add("genieKey", parameterToString(*r.genieKey, ""))
	localVarQueryParams.Add("region", parameterToString(*r.region, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSlackChannelsRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	channelId  int64
}

func (r ApiListSlackChannelsRequest) Execute() ([]SlackChannel, *http.Response, error) {
	return r.ApiService.ListSlackChannelsExecute(r)
}

/*
ListSlackChannels List all public Slack channels

List all public Slack channels, used for selecting a channel for the notifications

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiListSlackChannelsRequest
*/
func (a *NotificationChannelsApiService) ListSlackChannels(ctx context.Context, channelId int64) ApiListSlackChannelsRequest {
	return ApiListSlackChannelsRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//  @return []SlackChannel
func (a *NotificationChannelsApiService) ListSlackChannelsExecute(r ApiListSlackChannelsRequest) ([]SlackChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []SlackChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.ListSlackChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/slack/{channelId}/listSlackChannels"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSlackOAuthCallbackRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	state      *string
	code       *string
	error_     *string
}

// State parameter that was passed to Slack, should have the same value as the one passed to Slack.
func (r ApiSlackOAuthCallbackRequest) State(state string) ApiSlackOAuthCallbackRequest {
	r.state = &state
	return r
}

// OAuth code from Slack. Either the code is present for the success case or the error parameter is present for the error case.
func (r ApiSlackOAuthCallbackRequest) Code(code string) ApiSlackOAuthCallbackRequest {
	r.code = &code
	return r
}

// Error parameter. Either the code is present for the success case or the error parameter is present for the error case.
func (r ApiSlackOAuthCallbackRequest) Error_(error_ string) ApiSlackOAuthCallbackRequest {
	r.error_ = &error_
	return r
}

func (r ApiSlackOAuthCallbackRequest) Execute() (*http.Response, error) {
	return r.ApiService.SlackOAuthCallbackExecute(r)
}

/*
SlackOAuthCallback The OAuth callback for Slack

The OAuth callback for Slack, which is used to obtain the access token for the Slack channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlackOAuthCallbackRequest
*/
func (a *NotificationChannelsApiService) SlackOAuthCallback(ctx context.Context) ApiSlackOAuthCallbackRequest {
	return ApiSlackOAuthCallbackRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *NotificationChannelsApiService) SlackOAuthCallbackExecute(r ApiSlackOAuthCallbackRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.SlackOAuthCallback")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/slack/oauth-callback"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.state == nil {
		return nil, reportError("state is required and must be specified")
	}

	if r.code != nil {
		localVarQueryParams.Add("code", parameterToString(*r.code, ""))
	}
	localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	if r.error_ != nil {
		localVarQueryParams.Add("error", parameterToString(*r.error_, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSlackOauthRedirectRequest struct {
	ctx          context.Context
	ApiService   NotificationChannelsApi
	redirectPath *string
}

// After completing the oauth flow the user will be redirected back to this path, in the UI, on StackState, to continue further setup of the Slack notification channel.
func (r ApiSlackOauthRedirectRequest) RedirectPath(redirectPath string) ApiSlackOauthRedirectRequest {
	r.redirectPath = &redirectPath
	return r
}

func (r ApiSlackOauthRedirectRequest) Execute() (*http.Response, error) {
	return r.ApiService.SlackOauthRedirectExecute(r)
}

/*
SlackOauthRedirect Starts Slack OAuth2 flow

Redirects to Slack to start an OAuth2 flow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSlackOauthRedirectRequest
*/
func (a *NotificationChannelsApiService) SlackOauthRedirect(ctx context.Context) ApiSlackOauthRedirectRequest {
	return ApiSlackOauthRedirectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *NotificationChannelsApiService) SlackOauthRedirectExecute(r ApiSlackOauthRedirectRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.SlackOauthRedirect")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/slack/oauth-redirect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.redirectPath == nil {
		return nil, reportError("redirectPath is required and must be specified")
	}

	localVarQueryParams.Add("redirectPath", parameterToString(*r.redirectPath, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestEmailChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	channelId  int64
}

func (r ApiTestEmailChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.TestEmailChannelExecute(r)
}

/*
TestEmailChannel Test the Email notification channel

Test the email notification channel by sending a test message to the notification channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiTestEmailChannelRequest
*/
func (a *NotificationChannelsApiService) TestEmailChannel(ctx context.Context, channelId int64) ApiTestEmailChannelRequest {
	return ApiTestEmailChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *NotificationChannelsApiService) TestEmailChannelExecute(r ApiTestEmailChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.TestEmailChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/email/{channelId}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestOpsgenieChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	channelId  int64
}

func (r ApiTestOpsgenieChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.TestOpsgenieChannelExecute(r)
}

/*
TestOpsgenieChannel Test the Opsgenie notification channel

Test the opsgenie notification channel by sending a test message to the notification channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiTestOpsgenieChannelRequest
*/
func (a *NotificationChannelsApiService) TestOpsgenieChannel(ctx context.Context, channelId int64) ApiTestOpsgenieChannelRequest {
	return ApiTestOpsgenieChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *NotificationChannelsApiService) TestOpsgenieChannelExecute(r ApiTestOpsgenieChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.TestOpsgenieChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/opsgenie/{channelId}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestSlackChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	channelId  int64
}

func (r ApiTestSlackChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.TestSlackChannelExecute(r)
}

/*
TestSlackChannel Test the Notification channel

Test the Notification channel by sending a test message to the notification channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiTestSlackChannelRequest
*/
func (a *NotificationChannelsApiService) TestSlackChannel(ctx context.Context, channelId int64) ApiTestSlackChannelRequest {
	return ApiTestSlackChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *NotificationChannelsApiService) TestSlackChannelExecute(r ApiTestSlackChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.TestSlackChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/slack/{channelId}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestTeamsChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	channelId  int64
}

func (r ApiTestTeamsChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.TestTeamsChannelExecute(r)
}

/*
TestTeamsChannel Test the Teams notification channel

Test the teams notification channel by sending a test message to the notification channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiTestTeamsChannelRequest
*/
func (a *NotificationChannelsApiService) TestTeamsChannel(ctx context.Context, channelId int64) ApiTestTeamsChannelRequest {
	return ApiTestTeamsChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *NotificationChannelsApiService) TestTeamsChannelExecute(r ApiTestTeamsChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.TestTeamsChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/teams/{channelId}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestWebhookChannelRequest struct {
	ctx        context.Context
	ApiService NotificationChannelsApi
	channelId  int64
}

func (r ApiTestWebhookChannelRequest) Execute() (*http.Response, error) {
	return r.ApiService.TestWebhookChannelExecute(r)
}

/*
TestWebhookChannel Test the Webhook notification channel

Test the webhook notification channel by sending a test message to the notification channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiTestWebhookChannelRequest
*/
func (a *NotificationChannelsApiService) TestWebhookChannel(ctx context.Context, channelId int64) ApiTestWebhookChannelRequest {
	return ApiTestWebhookChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
func (a *NotificationChannelsApiService) TestWebhookChannelExecute(r ApiTestWebhookChannelRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.TestWebhookChannel")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/webhook/{channelId}/test"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateEmailNotificationChannelRequest struct {
	ctx                     context.Context
	ApiService              NotificationChannelsApi
	channelId               int64
	emailChannelWriteSchema *EmailChannelWriteSchema
}

// Create or update a email channel
func (r ApiUpdateEmailNotificationChannelRequest) EmailChannelWriteSchema(emailChannelWriteSchema EmailChannelWriteSchema) ApiUpdateEmailNotificationChannelRequest {
	r.emailChannelWriteSchema = &emailChannelWriteSchema
	return r
}

func (r ApiUpdateEmailNotificationChannelRequest) Execute() (*EmailNotificationChannel, *http.Response, error) {
	return r.ApiService.UpdateEmailNotificationChannelExecute(r)
}

/*
UpdateEmailNotificationChannel Update the Email Notification channel by id

Update the email notification channel by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiUpdateEmailNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) UpdateEmailNotificationChannel(ctx context.Context, channelId int64) ApiUpdateEmailNotificationChannelRequest {
	return ApiUpdateEmailNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//  @return EmailNotificationChannel
func (a *NotificationChannelsApiService) UpdateEmailNotificationChannelExecute(r ApiUpdateEmailNotificationChannelRequest) (*EmailNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EmailNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.UpdateEmailNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/email/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.emailChannelWriteSchema == nil {
		return localVarReturnValue, nil, reportError("emailChannelWriteSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.emailChannelWriteSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOpsgenieNotificationChannelRequest struct {
	ctx                        context.Context
	ApiService                 NotificationChannelsApi
	channelId                  int64
	opsgenieChannelWriteSchema *OpsgenieChannelWriteSchema
}

// Create or update a opsgenie channel
func (r ApiUpdateOpsgenieNotificationChannelRequest) OpsgenieChannelWriteSchema(opsgenieChannelWriteSchema OpsgenieChannelWriteSchema) ApiUpdateOpsgenieNotificationChannelRequest {
	r.opsgenieChannelWriteSchema = &opsgenieChannelWriteSchema
	return r
}

func (r ApiUpdateOpsgenieNotificationChannelRequest) Execute() (*OpsgenieNotificationChannel, *http.Response, error) {
	return r.ApiService.UpdateOpsgenieNotificationChannelExecute(r)
}

/*
UpdateOpsgenieNotificationChannel Update the Opsgenie Notification channel by id

Update the opsgenie notification channel by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiUpdateOpsgenieNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) UpdateOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiUpdateOpsgenieNotificationChannelRequest {
	return ApiUpdateOpsgenieNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//  @return OpsgenieNotificationChannel
func (a *NotificationChannelsApiService) UpdateOpsgenieNotificationChannelExecute(r ApiUpdateOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OpsgenieNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.UpdateOpsgenieNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/opsgenie/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.opsgenieChannelWriteSchema == nil {
		return localVarReturnValue, nil, reportError("opsgenieChannelWriteSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opsgenieChannelWriteSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTeamsNotificationChannelRequest struct {
	ctx                     context.Context
	ApiService              NotificationChannelsApi
	channelId               int64
	teamsChannelWriteSchema *TeamsChannelWriteSchema
}

// Create or update a teams channel
func (r ApiUpdateTeamsNotificationChannelRequest) TeamsChannelWriteSchema(teamsChannelWriteSchema TeamsChannelWriteSchema) ApiUpdateTeamsNotificationChannelRequest {
	r.teamsChannelWriteSchema = &teamsChannelWriteSchema
	return r
}

func (r ApiUpdateTeamsNotificationChannelRequest) Execute() (*TeamsNotificationChannel, *http.Response, error) {
	return r.ApiService.UpdateTeamsNotificationChannelExecute(r)
}

/*
UpdateTeamsNotificationChannel Update the Teams Notification channel by id

Update the teams notification channel by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiUpdateTeamsNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) UpdateTeamsNotificationChannel(ctx context.Context, channelId int64) ApiUpdateTeamsNotificationChannelRequest {
	return ApiUpdateTeamsNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//  @return TeamsNotificationChannel
func (a *NotificationChannelsApiService) UpdateTeamsNotificationChannelExecute(r ApiUpdateTeamsNotificationChannelRequest) (*TeamsNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TeamsNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.UpdateTeamsNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/teams/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.teamsChannelWriteSchema == nil {
		return localVarReturnValue, nil, reportError("teamsChannelWriteSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.teamsChannelWriteSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateWebhookNotificationChannelRequest struct {
	ctx                       context.Context
	ApiService                NotificationChannelsApi
	channelId                 int64
	webhookChannelWriteSchema *WebhookChannelWriteSchema
}

// Create or update a webhook channel
func (r ApiUpdateWebhookNotificationChannelRequest) WebhookChannelWriteSchema(webhookChannelWriteSchema WebhookChannelWriteSchema) ApiUpdateWebhookNotificationChannelRequest {
	r.webhookChannelWriteSchema = &webhookChannelWriteSchema
	return r
}

func (r ApiUpdateWebhookNotificationChannelRequest) Execute() (*WebhookNotificationChannel, *http.Response, error) {
	return r.ApiService.UpdateWebhookNotificationChannelExecute(r)
}

/*
UpdateWebhookNotificationChannel Update the Webhook Notification channel by id

Update the webhook notification channel by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel identifier
 @return ApiUpdateWebhookNotificationChannelRequest
*/
func (a *NotificationChannelsApiService) UpdateWebhookNotificationChannel(ctx context.Context, channelId int64) ApiUpdateWebhookNotificationChannelRequest {
	return ApiUpdateWebhookNotificationChannelRequest{
		ApiService: a,
		ctx:        ctx,
		channelId:  channelId,
	}
}

// Execute executes the request
//  @return WebhookNotificationChannel
func (a *NotificationChannelsApiService) UpdateWebhookNotificationChannelExecute(r ApiUpdateWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WebhookNotificationChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationChannelsApiService.UpdateWebhookNotificationChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/notifications/channels/webhook/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterToString(r.channelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.webhookChannelWriteSchema == nil {
		return localVarReturnValue, nil, reportError("webhookChannelWriteSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.webhookChannelWriteSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotificationChannelNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v NotificationChannelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ---------------------------------------------
// ------------------ MOCKS --------------------
// ---------------------------------------------

type NotificationChannelsApiMock struct {
	CreateEmailNotificationChannelCalls       *[]CreateEmailNotificationChannelCall
	CreateEmailNotificationChannelResponse    CreateEmailNotificationChannelMockResponse
	CreateOpsgenieNotificationChannelCalls    *[]CreateOpsgenieNotificationChannelCall
	CreateOpsgenieNotificationChannelResponse CreateOpsgenieNotificationChannelMockResponse
	CreateTeamsNotificationChannelCalls       *[]CreateTeamsNotificationChannelCall
	CreateTeamsNotificationChannelResponse    CreateTeamsNotificationChannelMockResponse
	CreateWebhookNotificationChannelCalls     *[]CreateWebhookNotificationChannelCall
	CreateWebhookNotificationChannelResponse  CreateWebhookNotificationChannelMockResponse
	DeleteEmailNotificationChannelCalls       *[]DeleteEmailNotificationChannelCall
	DeleteEmailNotificationChannelResponse    DeleteEmailNotificationChannelMockResponse
	DeleteOpsgenieNotificationChannelCalls    *[]DeleteOpsgenieNotificationChannelCall
	DeleteOpsgenieNotificationChannelResponse DeleteOpsgenieNotificationChannelMockResponse
	DeleteSlackNotificationChannelCalls       *[]DeleteSlackNotificationChannelCall
	DeleteSlackNotificationChannelResponse    DeleteSlackNotificationChannelMockResponse
	DeleteTeamsNotificationChannelCalls       *[]DeleteTeamsNotificationChannelCall
	DeleteTeamsNotificationChannelResponse    DeleteTeamsNotificationChannelMockResponse
	DeleteWebhookNotificationChannelCalls     *[]DeleteWebhookNotificationChannelCall
	DeleteWebhookNotificationChannelResponse  DeleteWebhookNotificationChannelMockResponse
	GetEmailNotificationChannelCalls          *[]GetEmailNotificationChannelCall
	GetEmailNotificationChannelResponse       GetEmailNotificationChannelMockResponse
	GetEmailNotificationStatusCalls           *[]GetEmailNotificationStatusCall
	GetEmailNotificationStatusResponse        GetEmailNotificationStatusMockResponse
	GetOpsgenieNotificationChannelCalls       *[]GetOpsgenieNotificationChannelCall
	GetOpsgenieNotificationChannelResponse    GetOpsgenieNotificationChannelMockResponse
	GetSlackNotificationChannelCalls          *[]GetSlackNotificationChannelCall
	GetSlackNotificationChannelResponse       GetSlackNotificationChannelMockResponse
	GetTeamsNotificationChannelCalls          *[]GetTeamsNotificationChannelCall
	GetTeamsNotificationChannelResponse       GetTeamsNotificationChannelMockResponse
	GetWebhookNotificationChannelCalls        *[]GetWebhookNotificationChannelCall
	GetWebhookNotificationChannelResponse     GetWebhookNotificationChannelMockResponse
	JoinSlackChannelCalls                     *[]JoinSlackChannelCall
	JoinSlackChannelResponse                  JoinSlackChannelMockResponse
	ListOpsgenieRespondersCalls               *[]ListOpsgenieRespondersCall
	ListOpsgenieRespondersResponse            ListOpsgenieRespondersMockResponse
	ListSlackChannelsCalls                    *[]ListSlackChannelsCall
	ListSlackChannelsResponse                 ListSlackChannelsMockResponse
	SlackOAuthCallbackCalls                   *[]SlackOAuthCallbackCall
	SlackOAuthCallbackResponse                SlackOAuthCallbackMockResponse
	SlackOauthRedirectCalls                   *[]SlackOauthRedirectCall
	SlackOauthRedirectResponse                SlackOauthRedirectMockResponse
	TestEmailChannelCalls                     *[]TestEmailChannelCall
	TestEmailChannelResponse                  TestEmailChannelMockResponse
	TestOpsgenieChannelCalls                  *[]TestOpsgenieChannelCall
	TestOpsgenieChannelResponse               TestOpsgenieChannelMockResponse
	TestSlackChannelCalls                     *[]TestSlackChannelCall
	TestSlackChannelResponse                  TestSlackChannelMockResponse
	TestTeamsChannelCalls                     *[]TestTeamsChannelCall
	TestTeamsChannelResponse                  TestTeamsChannelMockResponse
	TestWebhookChannelCalls                   *[]TestWebhookChannelCall
	TestWebhookChannelResponse                TestWebhookChannelMockResponse
	UpdateEmailNotificationChannelCalls       *[]UpdateEmailNotificationChannelCall
	UpdateEmailNotificationChannelResponse    UpdateEmailNotificationChannelMockResponse
	UpdateOpsgenieNotificationChannelCalls    *[]UpdateOpsgenieNotificationChannelCall
	UpdateOpsgenieNotificationChannelResponse UpdateOpsgenieNotificationChannelMockResponse
	UpdateTeamsNotificationChannelCalls       *[]UpdateTeamsNotificationChannelCall
	UpdateTeamsNotificationChannelResponse    UpdateTeamsNotificationChannelMockResponse
	UpdateWebhookNotificationChannelCalls     *[]UpdateWebhookNotificationChannelCall
	UpdateWebhookNotificationChannelResponse  UpdateWebhookNotificationChannelMockResponse
}

func NewNotificationChannelsApiMock() NotificationChannelsApiMock {
	xCreateEmailNotificationChannelCalls := make([]CreateEmailNotificationChannelCall, 0)
	xCreateOpsgenieNotificationChannelCalls := make([]CreateOpsgenieNotificationChannelCall, 0)
	xCreateTeamsNotificationChannelCalls := make([]CreateTeamsNotificationChannelCall, 0)
	xCreateWebhookNotificationChannelCalls := make([]CreateWebhookNotificationChannelCall, 0)
	xDeleteEmailNotificationChannelCalls := make([]DeleteEmailNotificationChannelCall, 0)
	xDeleteOpsgenieNotificationChannelCalls := make([]DeleteOpsgenieNotificationChannelCall, 0)
	xDeleteSlackNotificationChannelCalls := make([]DeleteSlackNotificationChannelCall, 0)
	xDeleteTeamsNotificationChannelCalls := make([]DeleteTeamsNotificationChannelCall, 0)
	xDeleteWebhookNotificationChannelCalls := make([]DeleteWebhookNotificationChannelCall, 0)
	xGetEmailNotificationChannelCalls := make([]GetEmailNotificationChannelCall, 0)
	xGetEmailNotificationStatusCalls := make([]GetEmailNotificationStatusCall, 0)
	xGetOpsgenieNotificationChannelCalls := make([]GetOpsgenieNotificationChannelCall, 0)
	xGetSlackNotificationChannelCalls := make([]GetSlackNotificationChannelCall, 0)
	xGetTeamsNotificationChannelCalls := make([]GetTeamsNotificationChannelCall, 0)
	xGetWebhookNotificationChannelCalls := make([]GetWebhookNotificationChannelCall, 0)
	xJoinSlackChannelCalls := make([]JoinSlackChannelCall, 0)
	xListOpsgenieRespondersCalls := make([]ListOpsgenieRespondersCall, 0)
	xListSlackChannelsCalls := make([]ListSlackChannelsCall, 0)
	xSlackOAuthCallbackCalls := make([]SlackOAuthCallbackCall, 0)
	xSlackOauthRedirectCalls := make([]SlackOauthRedirectCall, 0)
	xTestEmailChannelCalls := make([]TestEmailChannelCall, 0)
	xTestOpsgenieChannelCalls := make([]TestOpsgenieChannelCall, 0)
	xTestSlackChannelCalls := make([]TestSlackChannelCall, 0)
	xTestTeamsChannelCalls := make([]TestTeamsChannelCall, 0)
	xTestWebhookChannelCalls := make([]TestWebhookChannelCall, 0)
	xUpdateEmailNotificationChannelCalls := make([]UpdateEmailNotificationChannelCall, 0)
	xUpdateOpsgenieNotificationChannelCalls := make([]UpdateOpsgenieNotificationChannelCall, 0)
	xUpdateTeamsNotificationChannelCalls := make([]UpdateTeamsNotificationChannelCall, 0)
	xUpdateWebhookNotificationChannelCalls := make([]UpdateWebhookNotificationChannelCall, 0)
	return NotificationChannelsApiMock{
		CreateEmailNotificationChannelCalls:    &xCreateEmailNotificationChannelCalls,
		CreateOpsgenieNotificationChannelCalls: &xCreateOpsgenieNotificationChannelCalls,
		CreateTeamsNotificationChannelCalls:    &xCreateTeamsNotificationChannelCalls,
		CreateWebhookNotificationChannelCalls:  &xCreateWebhookNotificationChannelCalls,
		DeleteEmailNotificationChannelCalls:    &xDeleteEmailNotificationChannelCalls,
		DeleteOpsgenieNotificationChannelCalls: &xDeleteOpsgenieNotificationChannelCalls,
		DeleteSlackNotificationChannelCalls:    &xDeleteSlackNotificationChannelCalls,
		DeleteTeamsNotificationChannelCalls:    &xDeleteTeamsNotificationChannelCalls,
		DeleteWebhookNotificationChannelCalls:  &xDeleteWebhookNotificationChannelCalls,
		GetEmailNotificationChannelCalls:       &xGetEmailNotificationChannelCalls,
		GetEmailNotificationStatusCalls:        &xGetEmailNotificationStatusCalls,
		GetOpsgenieNotificationChannelCalls:    &xGetOpsgenieNotificationChannelCalls,
		GetSlackNotificationChannelCalls:       &xGetSlackNotificationChannelCalls,
		GetTeamsNotificationChannelCalls:       &xGetTeamsNotificationChannelCalls,
		GetWebhookNotificationChannelCalls:     &xGetWebhookNotificationChannelCalls,
		JoinSlackChannelCalls:                  &xJoinSlackChannelCalls,
		ListOpsgenieRespondersCalls:            &xListOpsgenieRespondersCalls,
		ListSlackChannelsCalls:                 &xListSlackChannelsCalls,
		SlackOAuthCallbackCalls:                &xSlackOAuthCallbackCalls,
		SlackOauthRedirectCalls:                &xSlackOauthRedirectCalls,
		TestEmailChannelCalls:                  &xTestEmailChannelCalls,
		TestOpsgenieChannelCalls:               &xTestOpsgenieChannelCalls,
		TestSlackChannelCalls:                  &xTestSlackChannelCalls,
		TestTeamsChannelCalls:                  &xTestTeamsChannelCalls,
		TestWebhookChannelCalls:                &xTestWebhookChannelCalls,
		UpdateEmailNotificationChannelCalls:    &xUpdateEmailNotificationChannelCalls,
		UpdateOpsgenieNotificationChannelCalls: &xUpdateOpsgenieNotificationChannelCalls,
		UpdateTeamsNotificationChannelCalls:    &xUpdateTeamsNotificationChannelCalls,
		UpdateWebhookNotificationChannelCalls:  &xUpdateWebhookNotificationChannelCalls,
	}
}

type CreateEmailNotificationChannelMockResponse struct {
	Result   EmailNotificationChannel
	Response *http.Response
	Error    error
}

type CreateEmailNotificationChannelCall struct {
	PemailChannelWriteSchema *EmailChannelWriteSchema
}

func (mock NotificationChannelsApiMock) CreateEmailNotificationChannel(ctx context.Context) ApiCreateEmailNotificationChannelRequest {
	return ApiCreateEmailNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock NotificationChannelsApiMock) CreateEmailNotificationChannelExecute(r ApiCreateEmailNotificationChannelRequest) (*EmailNotificationChannel, *http.Response, error) {
	p := CreateEmailNotificationChannelCall{
		PemailChannelWriteSchema: r.emailChannelWriteSchema,
	}
	*mock.CreateEmailNotificationChannelCalls = append(*mock.CreateEmailNotificationChannelCalls, p)
	return &mock.CreateEmailNotificationChannelResponse.Result, mock.CreateEmailNotificationChannelResponse.Response, mock.CreateEmailNotificationChannelResponse.Error
}

type CreateOpsgenieNotificationChannelMockResponse struct {
	Result   OpsgenieNotificationChannel
	Response *http.Response
	Error    error
}

type CreateOpsgenieNotificationChannelCall struct {
	PopsgenieChannelWriteSchema *OpsgenieChannelWriteSchema
}

func (mock NotificationChannelsApiMock) CreateOpsgenieNotificationChannel(ctx context.Context) ApiCreateOpsgenieNotificationChannelRequest {
	return ApiCreateOpsgenieNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock NotificationChannelsApiMock) CreateOpsgenieNotificationChannelExecute(r ApiCreateOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error) {
	p := CreateOpsgenieNotificationChannelCall{
		PopsgenieChannelWriteSchema: r.opsgenieChannelWriteSchema,
	}
	*mock.CreateOpsgenieNotificationChannelCalls = append(*mock.CreateOpsgenieNotificationChannelCalls, p)
	return &mock.CreateOpsgenieNotificationChannelResponse.Result, mock.CreateOpsgenieNotificationChannelResponse.Response, mock.CreateOpsgenieNotificationChannelResponse.Error
}

type CreateTeamsNotificationChannelMockResponse struct {
	Result   TeamsNotificationChannel
	Response *http.Response
	Error    error
}

type CreateTeamsNotificationChannelCall struct {
	PteamsChannelWriteSchema *TeamsChannelWriteSchema
}

func (mock NotificationChannelsApiMock) CreateTeamsNotificationChannel(ctx context.Context) ApiCreateTeamsNotificationChannelRequest {
	return ApiCreateTeamsNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock NotificationChannelsApiMock) CreateTeamsNotificationChannelExecute(r ApiCreateTeamsNotificationChannelRequest) (*TeamsNotificationChannel, *http.Response, error) {
	p := CreateTeamsNotificationChannelCall{
		PteamsChannelWriteSchema: r.teamsChannelWriteSchema,
	}
	*mock.CreateTeamsNotificationChannelCalls = append(*mock.CreateTeamsNotificationChannelCalls, p)
	return &mock.CreateTeamsNotificationChannelResponse.Result, mock.CreateTeamsNotificationChannelResponse.Response, mock.CreateTeamsNotificationChannelResponse.Error
}

type CreateWebhookNotificationChannelMockResponse struct {
	Result   WebhookNotificationChannel
	Response *http.Response
	Error    error
}

type CreateWebhookNotificationChannelCall struct {
	PwebhookChannelWriteSchema *WebhookChannelWriteSchema
}

func (mock NotificationChannelsApiMock) CreateWebhookNotificationChannel(ctx context.Context) ApiCreateWebhookNotificationChannelRequest {
	return ApiCreateWebhookNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock NotificationChannelsApiMock) CreateWebhookNotificationChannelExecute(r ApiCreateWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error) {
	p := CreateWebhookNotificationChannelCall{
		PwebhookChannelWriteSchema: r.webhookChannelWriteSchema,
	}
	*mock.CreateWebhookNotificationChannelCalls = append(*mock.CreateWebhookNotificationChannelCalls, p)
	return &mock.CreateWebhookNotificationChannelResponse.Result, mock.CreateWebhookNotificationChannelResponse.Response, mock.CreateWebhookNotificationChannelResponse.Error
}

type DeleteEmailNotificationChannelMockResponse struct {
	Response *http.Response
	Error    error
}

type DeleteEmailNotificationChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsApiMock) DeleteEmailNotificationChannel(ctx context.Context, channelId int64) ApiDeleteEmailNotificationChannelRequest {
	return ApiDeleteEmailNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) DeleteEmailNotificationChannelExecute(r ApiDeleteEmailNotificationChannelRequest) (*http.Response, error) {
	p := DeleteEmailNotificationChannelCall{
		PchannelId: r.channelId,
	}
	*mock.DeleteEmailNotificationChannelCalls = append(*mock.DeleteEmailNotificationChannelCalls, p)
	return mock.DeleteEmailNotificationChannelResponse.Response, mock.DeleteEmailNotificationChannelResponse.Error
}

type DeleteOpsgenieNotificationChannelMockResponse struct {
	Response *http.Response
	Error    error
}

type DeleteOpsgenieNotificationChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsApiMock) DeleteOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiDeleteOpsgenieNotificationChannelRequest {
	return ApiDeleteOpsgenieNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) DeleteOpsgenieNotificationChannelExecute(r ApiDeleteOpsgenieNotificationChannelRequest) (*http.Response, error) {
	p := DeleteOpsgenieNotificationChannelCall{
		PchannelId: r.channelId,
	}
	*mock.DeleteOpsgenieNotificationChannelCalls = append(*mock.DeleteOpsgenieNotificationChannelCalls, p)
	return mock.DeleteOpsgenieNotificationChannelResponse.Response, mock.DeleteOpsgenieNotificationChannelResponse.Error
}

type DeleteSlackNotificationChannelMockResponse struct {
	Response *http.Response
	Error    error
}

type DeleteSlackNotificationChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsApiMock) DeleteSlackNotificationChannel(ctx context.Context, channelId int64) ApiDeleteSlackNotificationChannelRequest {
	return ApiDeleteSlackNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) DeleteSlackNotificationChannelExecute(r ApiDeleteSlackNotificationChannelRequest) (*http.Response, error) {
	p := DeleteSlackNotificationChannelCall{
		PchannelId: r.channelId,
	}
	*mock.DeleteSlackNotificationChannelCalls = append(*mock.DeleteSlackNotificationChannelCalls, p)
	return mock.DeleteSlackNotificationChannelResponse.Response, mock.DeleteSlackNotificationChannelResponse.Error
}

type DeleteTeamsNotificationChannelMockResponse struct {
	Response *http.Response
	Error    error
}

type DeleteTeamsNotificationChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsApiMock) DeleteTeamsNotificationChannel(ctx context.Context, channelId int64) ApiDeleteTeamsNotificationChannelRequest {
	return ApiDeleteTeamsNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) DeleteTeamsNotificationChannelExecute(r ApiDeleteTeamsNotificationChannelRequest) (*http.Response, error) {
	p := DeleteTeamsNotificationChannelCall{
		PchannelId: r.channelId,
	}
	*mock.DeleteTeamsNotificationChannelCalls = append(*mock.DeleteTeamsNotificationChannelCalls, p)
	return mock.DeleteTeamsNotificationChannelResponse.Response, mock.DeleteTeamsNotificationChannelResponse.Error
}

type DeleteWebhookNotificationChannelMockResponse struct {
	Response *http.Response
	Error    error
}

type DeleteWebhookNotificationChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsApiMock) DeleteWebhookNotificationChannel(ctx context.Context, channelId int64) ApiDeleteWebhookNotificationChannelRequest {
	return ApiDeleteWebhookNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) DeleteWebhookNotificationChannelExecute(r ApiDeleteWebhookNotificationChannelRequest) (*http.Response, error) {
	p := DeleteWebhookNotificationChannelCall{
		PchannelId: r.channelId,
	}
	*mock.DeleteWebhookNotificationChannelCalls = append(*mock.DeleteWebhookNotificationChannelCalls, p)
	return mock.DeleteWebhookNotificationChannelResponse.Response, mock.DeleteWebhookNotificationChannelResponse.Error
}

type GetEmailNotificationChannelMockResponse struct {
	Result   EmailNotificationChannel
	Response *http.Response
	Error    error
}

type GetEmailNotificationChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsApiMock) GetEmailNotificationChannel(ctx context.Context, channelId int64) ApiGetEmailNotificationChannelRequest {
	return ApiGetEmailNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) GetEmailNotificationChannelExecute(r ApiGetEmailNotificationChannelRequest) (*EmailNotificationChannel, *http.Response, error) {
	p := GetEmailNotificationChannelCall{
		PchannelId: r.channelId,
	}
	*mock.GetEmailNotificationChannelCalls = append(*mock.GetEmailNotificationChannelCalls, p)
	return &mock.GetEmailNotificationChannelResponse.Result, mock.GetEmailNotificationChannelResponse.Response, mock.GetEmailNotificationChannelResponse.Error
}

type GetEmailNotificationStatusMockResponse struct {
	Result   EmailNotificationStatus
	Response *http.Response
	Error    error
}

type GetEmailNotificationStatusCall struct {
}

func (mock NotificationChannelsApiMock) GetEmailNotificationStatus(ctx context.Context) ApiGetEmailNotificationStatusRequest {
	return ApiGetEmailNotificationStatusRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock NotificationChannelsApiMock) GetEmailNotificationStatusExecute(r ApiGetEmailNotificationStatusRequest) (*EmailNotificationStatus, *http.Response, error) {
	p := GetEmailNotificationStatusCall{}
	*mock.GetEmailNotificationStatusCalls = append(*mock.GetEmailNotificationStatusCalls, p)
	return &mock.GetEmailNotificationStatusResponse.Result, mock.GetEmailNotificationStatusResponse.Response, mock.GetEmailNotificationStatusResponse.Error
}

type GetOpsgenieNotificationChannelMockResponse struct {
	Result   OpsgenieNotificationChannel
	Response *http.Response
	Error    error
}

type GetOpsgenieNotificationChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsApiMock) GetOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiGetOpsgenieNotificationChannelRequest {
	return ApiGetOpsgenieNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) GetOpsgenieNotificationChannelExecute(r ApiGetOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error) {
	p := GetOpsgenieNotificationChannelCall{
		PchannelId: r.channelId,
	}
	*mock.GetOpsgenieNotificationChannelCalls = append(*mock.GetOpsgenieNotificationChannelCalls, p)
	return &mock.GetOpsgenieNotificationChannelResponse.Result, mock.GetOpsgenieNotificationChannelResponse.Response, mock.GetOpsgenieNotificationChannelResponse.Error
}

type GetSlackNotificationChannelMockResponse struct {
	Result   SlackNotificationChannel
	Response *http.Response
	Error    error
}

type GetSlackNotificationChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsApiMock) GetSlackNotificationChannel(ctx context.Context, channelId int64) ApiGetSlackNotificationChannelRequest {
	return ApiGetSlackNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) GetSlackNotificationChannelExecute(r ApiGetSlackNotificationChannelRequest) (*SlackNotificationChannel, *http.Response, error) {
	p := GetSlackNotificationChannelCall{
		PchannelId: r.channelId,
	}
	*mock.GetSlackNotificationChannelCalls = append(*mock.GetSlackNotificationChannelCalls, p)
	return &mock.GetSlackNotificationChannelResponse.Result, mock.GetSlackNotificationChannelResponse.Response, mock.GetSlackNotificationChannelResponse.Error
}

type GetTeamsNotificationChannelMockResponse struct {
	Result   TeamsNotificationChannel
	Response *http.Response
	Error    error
}

type GetTeamsNotificationChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsApiMock) GetTeamsNotificationChannel(ctx context.Context, channelId int64) ApiGetTeamsNotificationChannelRequest {
	return ApiGetTeamsNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) GetTeamsNotificationChannelExecute(r ApiGetTeamsNotificationChannelRequest) (*TeamsNotificationChannel, *http.Response, error) {
	p := GetTeamsNotificationChannelCall{
		PchannelId: r.channelId,
	}
	*mock.GetTeamsNotificationChannelCalls = append(*mock.GetTeamsNotificationChannelCalls, p)
	return &mock.GetTeamsNotificationChannelResponse.Result, mock.GetTeamsNotificationChannelResponse.Response, mock.GetTeamsNotificationChannelResponse.Error
}

type GetWebhookNotificationChannelMockResponse struct {
	Result   WebhookNotificationChannel
	Response *http.Response
	Error    error
}

type GetWebhookNotificationChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsApiMock) GetWebhookNotificationChannel(ctx context.Context, channelId int64) ApiGetWebhookNotificationChannelRequest {
	return ApiGetWebhookNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) GetWebhookNotificationChannelExecute(r ApiGetWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error) {
	p := GetWebhookNotificationChannelCall{
		PchannelId: r.channelId,
	}
	*mock.GetWebhookNotificationChannelCalls = append(*mock.GetWebhookNotificationChannelCalls, p)
	return &mock.GetWebhookNotificationChannelResponse.Result, mock.GetWebhookNotificationChannelResponse.Response, mock.GetWebhookNotificationChannelResponse.Error
}

type JoinSlackChannelMockResponse struct {
	Result   SlackNotificationChannel
	Response *http.Response
	Error    error
}

type JoinSlackChannelCall struct {
	PchannelId      int64
	PslackChannelId *SlackChannelId
}

func (mock NotificationChannelsApiMock) JoinSlackChannel(ctx context.Context, channelId int64) ApiJoinSlackChannelRequest {
	return ApiJoinSlackChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) JoinSlackChannelExecute(r ApiJoinSlackChannelRequest) (*SlackNotificationChannel, *http.Response, error) {
	p := JoinSlackChannelCall{
		PchannelId:      r.channelId,
		PslackChannelId: r.slackChannelId,
	}
	*mock.JoinSlackChannelCalls = append(*mock.JoinSlackChannelCalls, p)
	return &mock.JoinSlackChannelResponse.Result, mock.JoinSlackChannelResponse.Response, mock.JoinSlackChannelResponse.Error
}

type ListOpsgenieRespondersMockResponse struct {
	Result   []OpsgenieResponder
	Response *http.Response
	Error    error
}

type ListOpsgenieRespondersCall struct {
	PgenieKey *string
	Pregion   *OpsgenieRegion
}

func (mock NotificationChannelsApiMock) ListOpsgenieResponders(ctx context.Context) ApiListOpsgenieRespondersRequest {
	return ApiListOpsgenieRespondersRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock NotificationChannelsApiMock) ListOpsgenieRespondersExecute(r ApiListOpsgenieRespondersRequest) ([]OpsgenieResponder, *http.Response, error) {
	p := ListOpsgenieRespondersCall{
		PgenieKey: r.genieKey,
		Pregion:   r.region,
	}
	*mock.ListOpsgenieRespondersCalls = append(*mock.ListOpsgenieRespondersCalls, p)
	return mock.ListOpsgenieRespondersResponse.Result, mock.ListOpsgenieRespondersResponse.Response, mock.ListOpsgenieRespondersResponse.Error
}

type ListSlackChannelsMockResponse struct {
	Result   []SlackChannel
	Response *http.Response
	Error    error
}

type ListSlackChannelsCall struct {
	PchannelId int64
}

func (mock NotificationChannelsApiMock) ListSlackChannels(ctx context.Context, channelId int64) ApiListSlackChannelsRequest {
	return ApiListSlackChannelsRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) ListSlackChannelsExecute(r ApiListSlackChannelsRequest) ([]SlackChannel, *http.Response, error) {
	p := ListSlackChannelsCall{
		PchannelId: r.channelId,
	}
	*mock.ListSlackChannelsCalls = append(*mock.ListSlackChannelsCalls, p)
	return mock.ListSlackChannelsResponse.Result, mock.ListSlackChannelsResponse.Response, mock.ListSlackChannelsResponse.Error
}

type SlackOAuthCallbackMockResponse struct {
	Response *http.Response
	Error    error
}

type SlackOAuthCallbackCall struct {
	Pstate  *string
	Pcode   *string
	Perror_ *string
}

func (mock NotificationChannelsApiMock) SlackOAuthCallback(ctx context.Context) ApiSlackOAuthCallbackRequest {
	return ApiSlackOAuthCallbackRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock NotificationChannelsApiMock) SlackOAuthCallbackExecute(r ApiSlackOAuthCallbackRequest) (*http.Response, error) {
	p := SlackOAuthCallbackCall{
		Pstate:  r.state,
		Pcode:   r.code,
		Perror_: r.error_,
	}
	*mock.SlackOAuthCallbackCalls = append(*mock.SlackOAuthCallbackCalls, p)
	return mock.SlackOAuthCallbackResponse.Response, mock.SlackOAuthCallbackResponse.Error
}

type SlackOauthRedirectMockResponse struct {
	Response *http.Response
	Error    error
}

type SlackOauthRedirectCall struct {
	PredirectPath *string
}

func (mock NotificationChannelsApiMock) SlackOauthRedirect(ctx context.Context) ApiSlackOauthRedirectRequest {
	return ApiSlackOauthRedirectRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock NotificationChannelsApiMock) SlackOauthRedirectExecute(r ApiSlackOauthRedirectRequest) (*http.Response, error) {
	p := SlackOauthRedirectCall{
		PredirectPath: r.redirectPath,
	}
	*mock.SlackOauthRedirectCalls = append(*mock.SlackOauthRedirectCalls, p)
	return mock.SlackOauthRedirectResponse.Response, mock.SlackOauthRedirectResponse.Error
}

type TestEmailChannelMockResponse struct {
	Response *http.Response
	Error    error
}

type TestEmailChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsApiMock) TestEmailChannel(ctx context.Context, channelId int64) ApiTestEmailChannelRequest {
	return ApiTestEmailChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) TestEmailChannelExecute(r ApiTestEmailChannelRequest) (*http.Response, error) {
	p := TestEmailChannelCall{
		PchannelId: r.channelId,
	}
	*mock.TestEmailChannelCalls = append(*mock.TestEmailChannelCalls, p)
	return mock.TestEmailChannelResponse.Response, mock.TestEmailChannelResponse.Error
}

type TestOpsgenieChannelMockResponse struct {
	Response *http.Response
	Error    error
}

type TestOpsgenieChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsApiMock) TestOpsgenieChannel(ctx context.Context, channelId int64) ApiTestOpsgenieChannelRequest {
	return ApiTestOpsgenieChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) TestOpsgenieChannelExecute(r ApiTestOpsgenieChannelRequest) (*http.Response, error) {
	p := TestOpsgenieChannelCall{
		PchannelId: r.channelId,
	}
	*mock.TestOpsgenieChannelCalls = append(*mock.TestOpsgenieChannelCalls, p)
	return mock.TestOpsgenieChannelResponse.Response, mock.TestOpsgenieChannelResponse.Error
}

type TestSlackChannelMockResponse struct {
	Response *http.Response
	Error    error
}

type TestSlackChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsApiMock) TestSlackChannel(ctx context.Context, channelId int64) ApiTestSlackChannelRequest {
	return ApiTestSlackChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) TestSlackChannelExecute(r ApiTestSlackChannelRequest) (*http.Response, error) {
	p := TestSlackChannelCall{
		PchannelId: r.channelId,
	}
	*mock.TestSlackChannelCalls = append(*mock.TestSlackChannelCalls, p)
	return mock.TestSlackChannelResponse.Response, mock.TestSlackChannelResponse.Error
}

type TestTeamsChannelMockResponse struct {
	Response *http.Response
	Error    error
}

type TestTeamsChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsApiMock) TestTeamsChannel(ctx context.Context, channelId int64) ApiTestTeamsChannelRequest {
	return ApiTestTeamsChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) TestTeamsChannelExecute(r ApiTestTeamsChannelRequest) (*http.Response, error) {
	p := TestTeamsChannelCall{
		PchannelId: r.channelId,
	}
	*mock.TestTeamsChannelCalls = append(*mock.TestTeamsChannelCalls, p)
	return mock.TestTeamsChannelResponse.Response, mock.TestTeamsChannelResponse.Error
}

type TestWebhookChannelMockResponse struct {
	Response *http.Response
	Error    error
}

type TestWebhookChannelCall struct {
	PchannelId int64
}

func (mock NotificationChannelsApiMock) TestWebhookChannel(ctx context.Context, channelId int64) ApiTestWebhookChannelRequest {
	return ApiTestWebhookChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) TestWebhookChannelExecute(r ApiTestWebhookChannelRequest) (*http.Response, error) {
	p := TestWebhookChannelCall{
		PchannelId: r.channelId,
	}
	*mock.TestWebhookChannelCalls = append(*mock.TestWebhookChannelCalls, p)
	return mock.TestWebhookChannelResponse.Response, mock.TestWebhookChannelResponse.Error
}

type UpdateEmailNotificationChannelMockResponse struct {
	Result   EmailNotificationChannel
	Response *http.Response
	Error    error
}

type UpdateEmailNotificationChannelCall struct {
	PchannelId               int64
	PemailChannelWriteSchema *EmailChannelWriteSchema
}

func (mock NotificationChannelsApiMock) UpdateEmailNotificationChannel(ctx context.Context, channelId int64) ApiUpdateEmailNotificationChannelRequest {
	return ApiUpdateEmailNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) UpdateEmailNotificationChannelExecute(r ApiUpdateEmailNotificationChannelRequest) (*EmailNotificationChannel, *http.Response, error) {
	p := UpdateEmailNotificationChannelCall{
		PchannelId:               r.channelId,
		PemailChannelWriteSchema: r.emailChannelWriteSchema,
	}
	*mock.UpdateEmailNotificationChannelCalls = append(*mock.UpdateEmailNotificationChannelCalls, p)
	return &mock.UpdateEmailNotificationChannelResponse.Result, mock.UpdateEmailNotificationChannelResponse.Response, mock.UpdateEmailNotificationChannelResponse.Error
}

type UpdateOpsgenieNotificationChannelMockResponse struct {
	Result   OpsgenieNotificationChannel
	Response *http.Response
	Error    error
}

type UpdateOpsgenieNotificationChannelCall struct {
	PchannelId                  int64
	PopsgenieChannelWriteSchema *OpsgenieChannelWriteSchema
}

func (mock NotificationChannelsApiMock) UpdateOpsgenieNotificationChannel(ctx context.Context, channelId int64) ApiUpdateOpsgenieNotificationChannelRequest {
	return ApiUpdateOpsgenieNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) UpdateOpsgenieNotificationChannelExecute(r ApiUpdateOpsgenieNotificationChannelRequest) (*OpsgenieNotificationChannel, *http.Response, error) {
	p := UpdateOpsgenieNotificationChannelCall{
		PchannelId:                  r.channelId,
		PopsgenieChannelWriteSchema: r.opsgenieChannelWriteSchema,
	}
	*mock.UpdateOpsgenieNotificationChannelCalls = append(*mock.UpdateOpsgenieNotificationChannelCalls, p)
	return &mock.UpdateOpsgenieNotificationChannelResponse.Result, mock.UpdateOpsgenieNotificationChannelResponse.Response, mock.UpdateOpsgenieNotificationChannelResponse.Error
}

type UpdateTeamsNotificationChannelMockResponse struct {
	Result   TeamsNotificationChannel
	Response *http.Response
	Error    error
}

type UpdateTeamsNotificationChannelCall struct {
	PchannelId               int64
	PteamsChannelWriteSchema *TeamsChannelWriteSchema
}

func (mock NotificationChannelsApiMock) UpdateTeamsNotificationChannel(ctx context.Context, channelId int64) ApiUpdateTeamsNotificationChannelRequest {
	return ApiUpdateTeamsNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) UpdateTeamsNotificationChannelExecute(r ApiUpdateTeamsNotificationChannelRequest) (*TeamsNotificationChannel, *http.Response, error) {
	p := UpdateTeamsNotificationChannelCall{
		PchannelId:               r.channelId,
		PteamsChannelWriteSchema: r.teamsChannelWriteSchema,
	}
	*mock.UpdateTeamsNotificationChannelCalls = append(*mock.UpdateTeamsNotificationChannelCalls, p)
	return &mock.UpdateTeamsNotificationChannelResponse.Result, mock.UpdateTeamsNotificationChannelResponse.Response, mock.UpdateTeamsNotificationChannelResponse.Error
}

type UpdateWebhookNotificationChannelMockResponse struct {
	Result   WebhookNotificationChannel
	Response *http.Response
	Error    error
}

type UpdateWebhookNotificationChannelCall struct {
	PchannelId                 int64
	PwebhookChannelWriteSchema *WebhookChannelWriteSchema
}

func (mock NotificationChannelsApiMock) UpdateWebhookNotificationChannel(ctx context.Context, channelId int64) ApiUpdateWebhookNotificationChannelRequest {
	return ApiUpdateWebhookNotificationChannelRequest{
		ApiService: mock,
		ctx:        ctx,
		channelId:  channelId,
	}
}

func (mock NotificationChannelsApiMock) UpdateWebhookNotificationChannelExecute(r ApiUpdateWebhookNotificationChannelRequest) (*WebhookNotificationChannel, *http.Response, error) {
	p := UpdateWebhookNotificationChannelCall{
		PchannelId:                 r.channelId,
		PwebhookChannelWriteSchema: r.webhookChannelWriteSchema,
	}
	*mock.UpdateWebhookNotificationChannelCalls = append(*mock.UpdateWebhookNotificationChannelCalls, p)
	return &mock.UpdateWebhookNotificationChannelResponse.Result, mock.UpdateWebhookNotificationChannelResponse.Response, mock.UpdateWebhookNotificationChannelResponse.Error
}
