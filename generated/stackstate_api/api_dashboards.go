/*
StackState API

This API documentation page describes the StackState server API. The StackState UI and CLI use the StackState server API to configure and query StackState.  You can use the API for similar purposes.  Each request sent to the StackState server API must be authenticated using one of the available authentication methods.   *Note that the StackState receiver API, used to send topology, telemetry and traces to StackState, is not described on this page and requires a different authentication method.*  For more information on StackState, refer to the [StackState documentation](https://docs.stackstate.com).

API version: 5.2.0
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackstate_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

type DashboardsApi interface {

	/*
		CloneDashboard Clone a dashboard

		Clone a dashboard by its identifier.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param dashboardIdOrUrn The identifier of a dashboard
		@return ApiCloneDashboardRequest
	*/
	CloneDashboard(ctx context.Context, dashboardIdOrUrn string) ApiCloneDashboardRequest

	// CloneDashboardExecute executes the request
	//  @return DashboardReadFullSchema
	CloneDashboardExecute(r ApiCloneDashboardRequest) (*DashboardReadFullSchema, *http.Response, error)

	/*
		CreateDashboard Create a new dashboard

		Create a new dashboard. The dashboard can be private or public based on the scope parameter.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateDashboardRequest
	*/
	CreateDashboard(ctx context.Context) ApiCreateDashboardRequest

	// CreateDashboardExecute executes the request
	//  @return DashboardReadFullSchema
	CreateDashboardExecute(r ApiCreateDashboardRequest) (*DashboardReadFullSchema, *http.Response, error)

	/*
		DeleteDashboard Delete a dashboard

		Delete a dashboard by its identifier. Only user-owned dashboards can be deleted.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param dashboardIdOrUrn The identifier of a dashboard
		@return ApiDeleteDashboardRequest
	*/
	DeleteDashboard(ctx context.Context, dashboardIdOrUrn string) ApiDeleteDashboardRequest

	// DeleteDashboardExecute executes the request
	DeleteDashboardExecute(r ApiDeleteDashboardRequest) (*http.Response, error)

	/*
		GetDashboard Get a single dashboard

		Get a dashboard by its identifier.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param dashboardIdOrUrn The identifier of a dashboard
		@return ApiGetDashboardRequest
	*/
	GetDashboard(ctx context.Context, dashboardIdOrUrn string) ApiGetDashboardRequest

	// GetDashboardExecute executes the request
	//  @return DashboardReadSchema
	GetDashboardExecute(r ApiGetDashboardRequest) (*DashboardReadSchema, *http.Response, error)

	/*
		GetDashboards Get a list of dashboards

		Get a list of dashboards, optionally filtered by name.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetDashboardsRequest
	*/
	GetDashboards(ctx context.Context) ApiGetDashboardsRequest

	// GetDashboardsExecute executes the request
	//  @return DashboardList
	GetDashboardsExecute(r ApiGetDashboardsRequest) (*DashboardList, *http.Response, error)

	/*
		PatchDashboard Patch a dashboard

		Patch an existing dashboard by its identifier. Only user-owned dashboard can be patched.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param dashboardIdOrUrn The identifier of a dashboard
		@return ApiPatchDashboardRequest
	*/
	PatchDashboard(ctx context.Context, dashboardIdOrUrn string) ApiPatchDashboardRequest

	// PatchDashboardExecute executes the request
	//  @return DashboardReadFullSchema
	PatchDashboardExecute(r ApiPatchDashboardRequest) (*DashboardReadFullSchema, *http.Response, error)
}

// DashboardsApiService DashboardsApi service
type DashboardsApiService service

type ApiCloneDashboardRequest struct {
	ctx                  context.Context
	ApiService           DashboardsApi
	dashboardIdOrUrn     string
	dashboardCloneSchema *DashboardCloneSchema
}

func (r ApiCloneDashboardRequest) DashboardCloneSchema(dashboardCloneSchema DashboardCloneSchema) ApiCloneDashboardRequest {
	r.dashboardCloneSchema = &dashboardCloneSchema
	return r
}

func (r ApiCloneDashboardRequest) Execute() (*DashboardReadFullSchema, *http.Response, error) {
	return r.ApiService.CloneDashboardExecute(r)
}

/*
CloneDashboard Clone a dashboard

Clone a dashboard by its identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardIdOrUrn The identifier of a dashboard
 @return ApiCloneDashboardRequest
*/
func (a *DashboardsApiService) CloneDashboard(ctx context.Context, dashboardIdOrUrn string) ApiCloneDashboardRequest {
	return ApiCloneDashboardRequest{
		ApiService:       a,
		ctx:              ctx,
		dashboardIdOrUrn: dashboardIdOrUrn,
	}
}

// Execute executes the request
//  @return DashboardReadFullSchema
func (a *DashboardsApiService) CloneDashboardExecute(r ApiCloneDashboardRequest) (*DashboardReadFullSchema, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DashboardReadFullSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DashboardsApiService.CloneDashboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{dashboardIdOrUrn}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboardIdOrUrn"+"}", url.PathEscape(parameterToString(r.dashboardIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dashboardCloneSchema == nil {
		return localVarReturnValue, nil, reportError("dashboardCloneSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboardCloneSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DashboardClientErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v DashboardAuthorizationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v DashboardNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDashboardRequest struct {
	ctx                  context.Context
	ApiService           DashboardsApi
	dashboardWriteSchema *DashboardWriteSchema
}

func (r ApiCreateDashboardRequest) DashboardWriteSchema(dashboardWriteSchema DashboardWriteSchema) ApiCreateDashboardRequest {
	r.dashboardWriteSchema = &dashboardWriteSchema
	return r
}

func (r ApiCreateDashboardRequest) Execute() (*DashboardReadFullSchema, *http.Response, error) {
	return r.ApiService.CreateDashboardExecute(r)
}

/*
CreateDashboard Create a new dashboard

Create a new dashboard. The dashboard can be private or public based on the scope parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDashboardRequest
*/
func (a *DashboardsApiService) CreateDashboard(ctx context.Context) ApiCreateDashboardRequest {
	return ApiCreateDashboardRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return DashboardReadFullSchema
func (a *DashboardsApiService) CreateDashboardExecute(r ApiCreateDashboardRequest) (*DashboardReadFullSchema, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DashboardReadFullSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DashboardsApiService.CreateDashboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dashboardWriteSchema == nil {
		return localVarReturnValue, nil, reportError("dashboardWriteSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboardWriteSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DashboardClientErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDashboardRequest struct {
	ctx              context.Context
	ApiService       DashboardsApi
	dashboardIdOrUrn string
}

func (r ApiDeleteDashboardRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDashboardExecute(r)
}

/*
DeleteDashboard Delete a dashboard

Delete a dashboard by its identifier. Only user-owned dashboards can be deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardIdOrUrn The identifier of a dashboard
 @return ApiDeleteDashboardRequest
*/
func (a *DashboardsApiService) DeleteDashboard(ctx context.Context, dashboardIdOrUrn string) ApiDeleteDashboardRequest {
	return ApiDeleteDashboardRequest{
		ApiService:       a,
		ctx:              ctx,
		dashboardIdOrUrn: dashboardIdOrUrn,
	}
}

// Execute executes the request
func (a *DashboardsApiService) DeleteDashboardExecute(r ApiDeleteDashboardRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DashboardsApiService.DeleteDashboard")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{dashboardIdOrUrn}"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboardIdOrUrn"+"}", url.PathEscape(parameterToString(r.dashboardIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DashboardClientErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v DashboardAuthorizationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v DashboardNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDashboardRequest struct {
	ctx               context.Context
	ApiService        DashboardsApi
	dashboardIdOrUrn  string
	loadFullDashboard *bool
}

// If true, includes the full dashboard content in the response. Defaults to false (only metadata is returned) for retrieval endpoints. Defaults to true for create/update operations.
func (r ApiGetDashboardRequest) LoadFullDashboard(loadFullDashboard bool) ApiGetDashboardRequest {
	r.loadFullDashboard = &loadFullDashboard
	return r
}

func (r ApiGetDashboardRequest) Execute() (*DashboardReadSchema, *http.Response, error) {
	return r.ApiService.GetDashboardExecute(r)
}

/*
GetDashboard Get a single dashboard

Get a dashboard by its identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardIdOrUrn The identifier of a dashboard
 @return ApiGetDashboardRequest
*/
func (a *DashboardsApiService) GetDashboard(ctx context.Context, dashboardIdOrUrn string) ApiGetDashboardRequest {
	return ApiGetDashboardRequest{
		ApiService:       a,
		ctx:              ctx,
		dashboardIdOrUrn: dashboardIdOrUrn,
	}
}

// Execute executes the request
//  @return DashboardReadSchema
func (a *DashboardsApiService) GetDashboardExecute(r ApiGetDashboardRequest) (*DashboardReadSchema, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DashboardReadSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DashboardsApiService.GetDashboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{dashboardIdOrUrn}"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboardIdOrUrn"+"}", url.PathEscape(parameterToString(r.dashboardIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.loadFullDashboard != nil {
		localVarQueryParams.Add("loadFullDashboard", parameterToString(*r.loadFullDashboard, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DashboardClientErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v DashboardNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDashboardsRequest struct {
	ctx               context.Context
	ApiService        DashboardsApi
	loadFullDashboard *bool
}

// If true, includes the full dashboard content in the response. Defaults to false (only metadata is returned) for retrieval endpoints. Defaults to true for create/update operations.
func (r ApiGetDashboardsRequest) LoadFullDashboard(loadFullDashboard bool) ApiGetDashboardsRequest {
	r.loadFullDashboard = &loadFullDashboard
	return r
}

func (r ApiGetDashboardsRequest) Execute() (*DashboardList, *http.Response, error) {
	return r.ApiService.GetDashboardsExecute(r)
}

/*
GetDashboards Get a list of dashboards

Get a list of dashboards, optionally filtered by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDashboardsRequest
*/
func (a *DashboardsApiService) GetDashboards(ctx context.Context) ApiGetDashboardsRequest {
	return ApiGetDashboardsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return DashboardList
func (a *DashboardsApiService) GetDashboardsExecute(r ApiGetDashboardsRequest) (*DashboardList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DashboardList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DashboardsApiService.GetDashboards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.loadFullDashboard != nil {
		localVarQueryParams.Add("loadFullDashboard", parameterToString(*r.loadFullDashboard, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchDashboardRequest struct {
	ctx                  context.Context
	ApiService           DashboardsApi
	dashboardIdOrUrn     string
	dashboardPatchSchema *DashboardPatchSchema
}

func (r ApiPatchDashboardRequest) DashboardPatchSchema(dashboardPatchSchema DashboardPatchSchema) ApiPatchDashboardRequest {
	r.dashboardPatchSchema = &dashboardPatchSchema
	return r
}

func (r ApiPatchDashboardRequest) Execute() (*DashboardReadFullSchema, *http.Response, error) {
	return r.ApiService.PatchDashboardExecute(r)
}

/*
PatchDashboard Patch a dashboard

Patch an existing dashboard by its identifier. Only user-owned dashboard can be patched.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardIdOrUrn The identifier of a dashboard
 @return ApiPatchDashboardRequest
*/
func (a *DashboardsApiService) PatchDashboard(ctx context.Context, dashboardIdOrUrn string) ApiPatchDashboardRequest {
	return ApiPatchDashboardRequest{
		ApiService:       a,
		ctx:              ctx,
		dashboardIdOrUrn: dashboardIdOrUrn,
	}
}

// Execute executes the request
//  @return DashboardReadFullSchema
func (a *DashboardsApiService) PatchDashboardExecute(r ApiPatchDashboardRequest) (*DashboardReadFullSchema, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DashboardReadFullSchema
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DashboardsApiService.PatchDashboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dashboards/{dashboardIdOrUrn}"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboardIdOrUrn"+"}", url.PathEscape(parameterToString(r.dashboardIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dashboardPatchSchema == nil {
		return localVarReturnValue, nil, reportError("dashboardPatchSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboardPatchSchema
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DashboardClientErrors
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v DashboardAuthorizationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v DashboardNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ---------------------------------------------
// ------------------ MOCKS --------------------
// ---------------------------------------------

type DashboardsApiMock struct {
	CloneDashboardCalls     *[]CloneDashboardCall
	CloneDashboardResponse  CloneDashboardMockResponse
	CreateDashboardCalls    *[]CreateDashboardCall
	CreateDashboardResponse CreateDashboardMockResponse
	DeleteDashboardCalls    *[]DeleteDashboardCall
	DeleteDashboardResponse DeleteDashboardMockResponse
	GetDashboardCalls       *[]GetDashboardCall
	GetDashboardResponse    GetDashboardMockResponse
	GetDashboardsCalls      *[]GetDashboardsCall
	GetDashboardsResponse   GetDashboardsMockResponse
	PatchDashboardCalls     *[]PatchDashboardCall
	PatchDashboardResponse  PatchDashboardMockResponse
}

func NewDashboardsApiMock() DashboardsApiMock {
	xCloneDashboardCalls := make([]CloneDashboardCall, 0)
	xCreateDashboardCalls := make([]CreateDashboardCall, 0)
	xDeleteDashboardCalls := make([]DeleteDashboardCall, 0)
	xGetDashboardCalls := make([]GetDashboardCall, 0)
	xGetDashboardsCalls := make([]GetDashboardsCall, 0)
	xPatchDashboardCalls := make([]PatchDashboardCall, 0)
	return DashboardsApiMock{
		CloneDashboardCalls:  &xCloneDashboardCalls,
		CreateDashboardCalls: &xCreateDashboardCalls,
		DeleteDashboardCalls: &xDeleteDashboardCalls,
		GetDashboardCalls:    &xGetDashboardCalls,
		GetDashboardsCalls:   &xGetDashboardsCalls,
		PatchDashboardCalls:  &xPatchDashboardCalls,
	}
}

type CloneDashboardMockResponse struct {
	Result   DashboardReadFullSchema
	Response *http.Response
	Error    error
}

type CloneDashboardCall struct {
	PdashboardIdOrUrn     string
	PdashboardCloneSchema *DashboardCloneSchema
}

func (mock DashboardsApiMock) CloneDashboard(ctx context.Context, dashboardIdOrUrn string) ApiCloneDashboardRequest {
	return ApiCloneDashboardRequest{
		ApiService:       mock,
		ctx:              ctx,
		dashboardIdOrUrn: dashboardIdOrUrn,
	}
}

func (mock DashboardsApiMock) CloneDashboardExecute(r ApiCloneDashboardRequest) (*DashboardReadFullSchema, *http.Response, error) {
	p := CloneDashboardCall{
		PdashboardIdOrUrn:     r.dashboardIdOrUrn,
		PdashboardCloneSchema: r.dashboardCloneSchema,
	}
	*mock.CloneDashboardCalls = append(*mock.CloneDashboardCalls, p)
	return &mock.CloneDashboardResponse.Result, mock.CloneDashboardResponse.Response, mock.CloneDashboardResponse.Error
}

type CreateDashboardMockResponse struct {
	Result   DashboardReadFullSchema
	Response *http.Response
	Error    error
}

type CreateDashboardCall struct {
	PdashboardWriteSchema *DashboardWriteSchema
}

func (mock DashboardsApiMock) CreateDashboard(ctx context.Context) ApiCreateDashboardRequest {
	return ApiCreateDashboardRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock DashboardsApiMock) CreateDashboardExecute(r ApiCreateDashboardRequest) (*DashboardReadFullSchema, *http.Response, error) {
	p := CreateDashboardCall{
		PdashboardWriteSchema: r.dashboardWriteSchema,
	}
	*mock.CreateDashboardCalls = append(*mock.CreateDashboardCalls, p)
	return &mock.CreateDashboardResponse.Result, mock.CreateDashboardResponse.Response, mock.CreateDashboardResponse.Error
}

type DeleteDashboardMockResponse struct {
	Response *http.Response
	Error    error
}

type DeleteDashboardCall struct {
	PdashboardIdOrUrn string
}

func (mock DashboardsApiMock) DeleteDashboard(ctx context.Context, dashboardIdOrUrn string) ApiDeleteDashboardRequest {
	return ApiDeleteDashboardRequest{
		ApiService:       mock,
		ctx:              ctx,
		dashboardIdOrUrn: dashboardIdOrUrn,
	}
}

func (mock DashboardsApiMock) DeleteDashboardExecute(r ApiDeleteDashboardRequest) (*http.Response, error) {
	p := DeleteDashboardCall{
		PdashboardIdOrUrn: r.dashboardIdOrUrn,
	}
	*mock.DeleteDashboardCalls = append(*mock.DeleteDashboardCalls, p)
	return mock.DeleteDashboardResponse.Response, mock.DeleteDashboardResponse.Error
}

type GetDashboardMockResponse struct {
	Result   DashboardReadSchema
	Response *http.Response
	Error    error
}

type GetDashboardCall struct {
	PdashboardIdOrUrn  string
	PloadFullDashboard *bool
}

func (mock DashboardsApiMock) GetDashboard(ctx context.Context, dashboardIdOrUrn string) ApiGetDashboardRequest {
	return ApiGetDashboardRequest{
		ApiService:       mock,
		ctx:              ctx,
		dashboardIdOrUrn: dashboardIdOrUrn,
	}
}

func (mock DashboardsApiMock) GetDashboardExecute(r ApiGetDashboardRequest) (*DashboardReadSchema, *http.Response, error) {
	p := GetDashboardCall{
		PdashboardIdOrUrn:  r.dashboardIdOrUrn,
		PloadFullDashboard: r.loadFullDashboard,
	}
	*mock.GetDashboardCalls = append(*mock.GetDashboardCalls, p)
	return &mock.GetDashboardResponse.Result, mock.GetDashboardResponse.Response, mock.GetDashboardResponse.Error
}

type GetDashboardsMockResponse struct {
	Result   DashboardList
	Response *http.Response
	Error    error
}

type GetDashboardsCall struct {
	PloadFullDashboard *bool
}

func (mock DashboardsApiMock) GetDashboards(ctx context.Context) ApiGetDashboardsRequest {
	return ApiGetDashboardsRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock DashboardsApiMock) GetDashboardsExecute(r ApiGetDashboardsRequest) (*DashboardList, *http.Response, error) {
	p := GetDashboardsCall{
		PloadFullDashboard: r.loadFullDashboard,
	}
	*mock.GetDashboardsCalls = append(*mock.GetDashboardsCalls, p)
	return &mock.GetDashboardsResponse.Result, mock.GetDashboardsResponse.Response, mock.GetDashboardsResponse.Error
}

type PatchDashboardMockResponse struct {
	Result   DashboardReadFullSchema
	Response *http.Response
	Error    error
}

type PatchDashboardCall struct {
	PdashboardIdOrUrn     string
	PdashboardPatchSchema *DashboardPatchSchema
}

func (mock DashboardsApiMock) PatchDashboard(ctx context.Context, dashboardIdOrUrn string) ApiPatchDashboardRequest {
	return ApiPatchDashboardRequest{
		ApiService:       mock,
		ctx:              ctx,
		dashboardIdOrUrn: dashboardIdOrUrn,
	}
}

func (mock DashboardsApiMock) PatchDashboardExecute(r ApiPatchDashboardRequest) (*DashboardReadFullSchema, *http.Response, error) {
	p := PatchDashboardCall{
		PdashboardIdOrUrn:     r.dashboardIdOrUrn,
		PdashboardPatchSchema: r.dashboardPatchSchema,
	}
	*mock.PatchDashboardCalls = append(*mock.PatchDashboardCalls, p)
	return &mock.PatchDashboardResponse.Result, mock.PatchDashboardResponse.Response, mock.PatchDashboardResponse.Error
}
