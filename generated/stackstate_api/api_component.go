/*
StackState API

This API documentation page describes the StackState server API. The StackState UI and CLI use the StackState server API to configure and query StackState.  You can use the API for similar purposes.  Each request sent to the StackState server API must be authenticated using one of the available authentication methods.   *Note that the StackState receiver API, used to send topology, telemetry and traces to StackState, is not described on this page and requires a different authentication method.*  For more information on StackState, refer to the [StackState documentation](https://docs.stackstate.com).

API version: 5.2.0
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackstate_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

type ComponentApi interface {

	/*
		GetComponentHealthHistory Get a component health history

		Get a component health history for a defined period of time by id

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param componentIdOrUrn The id or identifier (urn) of a component
		@return ApiGetComponentHealthHistoryRequest
	*/
	GetComponentHealthHistory(ctx context.Context, componentIdOrUrn string) ApiGetComponentHealthHistoryRequest

	// GetComponentHealthHistoryExecute executes the request
	//  @return ComponentHealthHistory
	GetComponentHealthHistoryExecute(r ApiGetComponentHealthHistoryRequest) (*ComponentHealthHistory, *http.Response, error)
}

// ComponentApiService ComponentApi service
type ComponentApiService service

type ApiGetComponentHealthHistoryRequest struct {
	ctx              context.Context
	ApiService       ComponentApi
	componentIdOrUrn string
	startTime        *int32
	endTime          *int32
	topologyTime     *int32
}

// The start time of a time range to query resources.
func (r ApiGetComponentHealthHistoryRequest) StartTime(startTime int32) ApiGetComponentHealthHistoryRequest {
	r.startTime = &startTime
	return r
}

// The end time of a time range to query resources. If not given the endTime is set to current time.
func (r ApiGetComponentHealthHistoryRequest) EndTime(endTime int32) ApiGetComponentHealthHistoryRequest {
	r.endTime = &endTime
	return r
}

// A timestamp at which resources will be queried. If not given the resources are queried at current time.
func (r ApiGetComponentHealthHistoryRequest) TopologyTime(topologyTime int32) ApiGetComponentHealthHistoryRequest {
	r.topologyTime = &topologyTime
	return r
}

func (r ApiGetComponentHealthHistoryRequest) Execute() (*ComponentHealthHistory, *http.Response, error) {
	return r.ApiService.GetComponentHealthHistoryExecute(r)
}

/*
GetComponentHealthHistory Get a component health history

Get a component health history for a defined period of time by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param componentIdOrUrn The id or identifier (urn) of a component
 @return ApiGetComponentHealthHistoryRequest
*/
func (a *ComponentApiService) GetComponentHealthHistory(ctx context.Context, componentIdOrUrn string) ApiGetComponentHealthHistoryRequest {
	return ApiGetComponentHealthHistoryRequest{
		ApiService:       a,
		ctx:              ctx,
		componentIdOrUrn: componentIdOrUrn,
	}
}

// Execute executes the request
//  @return ComponentHealthHistory
func (a *ComponentApiService) GetComponentHealthHistoryExecute(r ApiGetComponentHealthHistoryRequest) (*ComponentHealthHistory, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ComponentHealthHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComponentApiService.GetComponentHealthHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/components/{componentIdOrUrn}/healthHistory"
	localVarPath = strings.Replace(localVarPath, "{"+"componentIdOrUrn"+"}", url.PathEscape(parameterToString(r.componentIdOrUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTime == nil {
		return localVarReturnValue, nil, reportError("startTime is required and must be specified")
	}

	localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.topologyTime != nil {
		localVarQueryParams.Add("topologyTime", parameterToString(*r.topologyTime, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ComponentNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ---------------------------------------------
// ------------------ MOCKS --------------------
// ---------------------------------------------

type ComponentApiMock struct {
	GetComponentHealthHistoryCalls    *[]GetComponentHealthHistoryCall
	GetComponentHealthHistoryResponse GetComponentHealthHistoryMockResponse
}

func NewComponentApiMock() ComponentApiMock {
	xGetComponentHealthHistoryCalls := make([]GetComponentHealthHistoryCall, 0)
	return ComponentApiMock{
		GetComponentHealthHistoryCalls: &xGetComponentHealthHistoryCalls,
	}
}

type GetComponentHealthHistoryMockResponse struct {
	Result   ComponentHealthHistory
	Response *http.Response
	Error    error
}

type GetComponentHealthHistoryCall struct {
	PcomponentIdOrUrn string
	PstartTime        *int32
	PendTime          *int32
	PtopologyTime     *int32
}

func (mock ComponentApiMock) GetComponentHealthHistory(ctx context.Context, componentIdOrUrn string) ApiGetComponentHealthHistoryRequest {
	return ApiGetComponentHealthHistoryRequest{
		ApiService:       mock,
		ctx:              ctx,
		componentIdOrUrn: componentIdOrUrn,
	}
}

func (mock ComponentApiMock) GetComponentHealthHistoryExecute(r ApiGetComponentHealthHistoryRequest) (*ComponentHealthHistory, *http.Response, error) {
	p := GetComponentHealthHistoryCall{
		PcomponentIdOrUrn: r.componentIdOrUrn,
		PstartTime:        r.startTime,
		PendTime:          r.endTime,
		PtopologyTime:     r.topologyTime,
	}
	*mock.GetComponentHealthHistoryCalls = append(*mock.GetComponentHealthHistoryCalls, p)
	return &mock.GetComponentHealthHistoryResponse.Result, mock.GetComponentHealthHistoryResponse.Response, mock.GetComponentHealthHistoryResponse.Error
}
