/*
StackState API

This API documentation page describes the StackState server API. The StackState UI and CLI use the StackState server API to configure and query StackState.  You can use the API for similar purposes.  Each request sent to the StackState server API must be authenticated using one of the available authentication methods.   *Note that the StackState receiver API, used to send topology, telemetry and traces to StackState, is not described on this page and requires a different authentication method.*  For more information on StackState, refer to the [StackState documentation](https://docs.stackstate.com).

API version: 5.2.0
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackstate_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

type HealthSynchronizationAPI interface {

	/*
		DeleteHealthSynchronizationStream Delete health sync stream

		Delete a health synchronization stream. Deletion will not be immediate.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param healthStreamUrn Urn of the health stream.
		@return ApiDeleteHealthSynchronizationStreamRequest
	*/
	DeleteHealthSynchronizationStream(ctx context.Context, healthStreamUrn string) ApiDeleteHealthSynchronizationStreamRequest

	// DeleteHealthSynchronizationStreamExecute executes the request
	DeleteHealthSynchronizationStreamExecute(r ApiDeleteHealthSynchronizationStreamRequest) (*http.Response, error)

	/*
		GetHealthSynchronizationStreamStatus Get health sync stream status

		Status overview of a single health synchronization stream

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param healthStreamUrn Urn of the health stream.
		@return ApiGetHealthSynchronizationStreamStatusRequest
	*/
	GetHealthSynchronizationStreamStatus(ctx context.Context, healthStreamUrn string) ApiGetHealthSynchronizationStreamStatusRequest

	// GetHealthSynchronizationStreamStatusExecute executes the request
	//  @return HealthStreamStatus
	GetHealthSynchronizationStreamStatusExecute(r ApiGetHealthSynchronizationStreamStatusRequest) (*HealthStreamStatus, *http.Response, error)

	/*
		GetHealthSynchronizationStreamTopologyMatches List health sync stream check-states

		Overview of check-states matched to topology on the main stream.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param healthStreamUrn Urn of the health stream.
		@return ApiGetHealthSynchronizationStreamTopologyMatchesRequest
	*/
	GetHealthSynchronizationStreamTopologyMatches(ctx context.Context, healthStreamUrn string) ApiGetHealthSynchronizationStreamTopologyMatchesRequest

	// GetHealthSynchronizationStreamTopologyMatchesExecute executes the request
	//  @return TopologyMatchResult
	GetHealthSynchronizationStreamTopologyMatchesExecute(r ApiGetHealthSynchronizationStreamTopologyMatchesRequest) (*TopologyMatchResult, *http.Response, error)

	/*
		GetHealthSynchronizationStreamsOverview List health sync streams

		Status overview of the health synchronization streams.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiGetHealthSynchronizationStreamsOverviewRequest
	*/
	GetHealthSynchronizationStreamsOverview(ctx context.Context) ApiGetHealthSynchronizationStreamsOverviewRequest

	// GetHealthSynchronizationStreamsOverviewExecute executes the request
	//  @return StreamList
	GetHealthSynchronizationStreamsOverviewExecute(r ApiGetHealthSynchronizationStreamsOverviewRequest) (*StreamList, *http.Response, error)

	/*
		GetHealthSynchronizationSubStreamOverview List health sync sub-streams

		Overview of all sub-streams in a certain health stream.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param healthStreamUrn Urn of the health stream.
		@return ApiGetHealthSynchronizationSubStreamOverviewRequest
	*/
	GetHealthSynchronizationSubStreamOverview(ctx context.Context, healthStreamUrn string) ApiGetHealthSynchronizationSubStreamOverviewRequest

	// GetHealthSynchronizationSubStreamOverviewExecute executes the request
	//  @return SubStreamList
	GetHealthSynchronizationSubStreamOverviewExecute(r ApiGetHealthSynchronizationSubStreamOverviewRequest) (*SubStreamList, *http.Response, error)

	/*
		GetHealthSynchronizationSubStreamStatus Get health sync sub-stream status

		Status overview of a single health synchronization sub stream

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param healthStreamUrn Urn of the health stream.
		@param healthSyncSubStreamId Health synchronization sub stream id.
		@return ApiGetHealthSynchronizationSubStreamStatusRequest
	*/
	GetHealthSynchronizationSubStreamStatus(ctx context.Context, healthStreamUrn string, healthSyncSubStreamId string) ApiGetHealthSynchronizationSubStreamStatusRequest

	// GetHealthSynchronizationSubStreamStatusExecute executes the request
	//  @return HealthSubStreamStatus
	GetHealthSynchronizationSubStreamStatusExecute(r ApiGetHealthSynchronizationSubStreamStatusRequest) (*HealthSubStreamStatus, *http.Response, error)

	/*
		GetHealthSynchronizationSubStreamTopologyMatches List health sync sub-stream check-states

		Overview of check-states matched to topology on the main stream.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param healthStreamUrn Urn of the health stream.
		@param healthSyncSubStreamId Health synchronization sub stream id.
		@return ApiGetHealthSynchronizationSubStreamTopologyMatchesRequest
	*/
	GetHealthSynchronizationSubStreamTopologyMatches(ctx context.Context, healthStreamUrn string, healthSyncSubStreamId string) ApiGetHealthSynchronizationSubStreamTopologyMatchesRequest

	// GetHealthSynchronizationSubStreamTopologyMatchesExecute executes the request
	//  @return TopologyMatchResult
	GetHealthSynchronizationSubStreamTopologyMatchesExecute(r ApiGetHealthSynchronizationSubStreamTopologyMatchesRequest) (*TopologyMatchResult, *http.Response, error)

	/*
		PostHealthSynchronizationStreamClearErrors Clear health sync stream errors

		Clear all errors for a stream and its sub-streams.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param healthStreamUrn Urn of the health stream.
		@return ApiPostHealthSynchronizationStreamClearErrorsRequest
	*/
	PostHealthSynchronizationStreamClearErrors(ctx context.Context, healthStreamUrn string) ApiPostHealthSynchronizationStreamClearErrorsRequest

	// PostHealthSynchronizationStreamClearErrorsExecute executes the request
	PostHealthSynchronizationStreamClearErrorsExecute(r ApiPostHealthSynchronizationStreamClearErrorsRequest) (*http.Response, error)
}

// HealthSynchronizationAPIService HealthSynchronizationAPI service
type HealthSynchronizationAPIService service

type ApiDeleteHealthSynchronizationStreamRequest struct {
	ctx             context.Context
	ApiService      HealthSynchronizationAPI
	healthStreamUrn string
}

func (r ApiDeleteHealthSynchronizationStreamRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteHealthSynchronizationStreamExecute(r)
}

/*
DeleteHealthSynchronizationStream Delete health sync stream

Delete a health synchronization stream. Deletion will not be immediate.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param healthStreamUrn Urn of the health stream.
	@return ApiDeleteHealthSynchronizationStreamRequest
*/
func (a *HealthSynchronizationAPIService) DeleteHealthSynchronizationStream(ctx context.Context, healthStreamUrn string) ApiDeleteHealthSynchronizationStreamRequest {
	return ApiDeleteHealthSynchronizationStreamRequest{
		ApiService:      a,
		ctx:             ctx,
		healthStreamUrn: healthStreamUrn,
	}
}

// Execute executes the request
func (a *HealthSynchronizationAPIService) DeleteHealthSynchronizationStreamExecute(r ApiDeleteHealthSynchronizationStreamRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthSynchronizationAPIService.DeleteHealthSynchronizationStream")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/synchronization/health/streams/{healthStreamUrn}"
	localVarPath = strings.Replace(localVarPath, "{"+"healthStreamUrn"+"}", url.PathEscape(parameterToString(r.healthStreamUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidUrn
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HealthStreamNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetHealthSynchronizationStreamStatusRequest struct {
	ctx             context.Context
	ApiService      HealthSynchronizationAPI
	healthStreamUrn string
}

func (r ApiGetHealthSynchronizationStreamStatusRequest) Execute() (*HealthStreamStatus, *http.Response, error) {
	return r.ApiService.GetHealthSynchronizationStreamStatusExecute(r)
}

/*
GetHealthSynchronizationStreamStatus Get health sync stream status

Status overview of a single health synchronization stream

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param healthStreamUrn Urn of the health stream.
	@return ApiGetHealthSynchronizationStreamStatusRequest
*/
func (a *HealthSynchronizationAPIService) GetHealthSynchronizationStreamStatus(ctx context.Context, healthStreamUrn string) ApiGetHealthSynchronizationStreamStatusRequest {
	return ApiGetHealthSynchronizationStreamStatusRequest{
		ApiService:      a,
		ctx:             ctx,
		healthStreamUrn: healthStreamUrn,
	}
}

// Execute executes the request
//
//	@return HealthStreamStatus
func (a *HealthSynchronizationAPIService) GetHealthSynchronizationStreamStatusExecute(r ApiGetHealthSynchronizationStreamStatusRequest) (*HealthStreamStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HealthStreamStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthSynchronizationAPIService.GetHealthSynchronizationStreamStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/synchronization/health/streams/{healthStreamUrn}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"healthStreamUrn"+"}", url.PathEscape(parameterToString(r.healthStreamUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidUrn
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HealthStreamNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHealthSynchronizationStreamTopologyMatchesRequest struct {
	ctx             context.Context
	ApiService      HealthSynchronizationAPI
	healthStreamUrn string
}

func (r ApiGetHealthSynchronizationStreamTopologyMatchesRequest) Execute() (*TopologyMatchResult, *http.Response, error) {
	return r.ApiService.GetHealthSynchronizationStreamTopologyMatchesExecute(r)
}

/*
GetHealthSynchronizationStreamTopologyMatches List health sync stream check-states

Overview of check-states matched to topology on the main stream.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param healthStreamUrn Urn of the health stream.
	@return ApiGetHealthSynchronizationStreamTopologyMatchesRequest
*/
func (a *HealthSynchronizationAPIService) GetHealthSynchronizationStreamTopologyMatches(ctx context.Context, healthStreamUrn string) ApiGetHealthSynchronizationStreamTopologyMatchesRequest {
	return ApiGetHealthSynchronizationStreamTopologyMatchesRequest{
		ApiService:      a,
		ctx:             ctx,
		healthStreamUrn: healthStreamUrn,
	}
}

// Execute executes the request
//
//	@return TopologyMatchResult
func (a *HealthSynchronizationAPIService) GetHealthSynchronizationStreamTopologyMatchesExecute(r ApiGetHealthSynchronizationStreamTopologyMatchesRequest) (*TopologyMatchResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TopologyMatchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthSynchronizationAPIService.GetHealthSynchronizationStreamTopologyMatches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/synchronization/health/streams/{healthStreamUrn}/topologyMatches"
	localVarPath = strings.Replace(localVarPath, "{"+"healthStreamUrn"+"}", url.PathEscape(parameterToString(r.healthStreamUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidUrn
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HealthSubStreamError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHealthSynchronizationStreamsOverviewRequest struct {
	ctx        context.Context
	ApiService HealthSynchronizationAPI
}

func (r ApiGetHealthSynchronizationStreamsOverviewRequest) Execute() (*StreamList, *http.Response, error) {
	return r.ApiService.GetHealthSynchronizationStreamsOverviewExecute(r)
}

/*
GetHealthSynchronizationStreamsOverview List health sync streams

Status overview of the health synchronization streams.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetHealthSynchronizationStreamsOverviewRequest
*/
func (a *HealthSynchronizationAPIService) GetHealthSynchronizationStreamsOverview(ctx context.Context) ApiGetHealthSynchronizationStreamsOverviewRequest {
	return ApiGetHealthSynchronizationStreamsOverviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StreamList
func (a *HealthSynchronizationAPIService) GetHealthSynchronizationStreamsOverviewExecute(r ApiGetHealthSynchronizationStreamsOverviewRequest) (*StreamList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StreamList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthSynchronizationAPIService.GetHealthSynchronizationStreamsOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/synchronization/health/streams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHealthSynchronizationSubStreamOverviewRequest struct {
	ctx             context.Context
	ApiService      HealthSynchronizationAPI
	healthStreamUrn string
}

func (r ApiGetHealthSynchronizationSubStreamOverviewRequest) Execute() (*SubStreamList, *http.Response, error) {
	return r.ApiService.GetHealthSynchronizationSubStreamOverviewExecute(r)
}

/*
GetHealthSynchronizationSubStreamOverview List health sync sub-streams

Overview of all sub-streams in a certain health stream.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param healthStreamUrn Urn of the health stream.
	@return ApiGetHealthSynchronizationSubStreamOverviewRequest
*/
func (a *HealthSynchronizationAPIService) GetHealthSynchronizationSubStreamOverview(ctx context.Context, healthStreamUrn string) ApiGetHealthSynchronizationSubStreamOverviewRequest {
	return ApiGetHealthSynchronizationSubStreamOverviewRequest{
		ApiService:      a,
		ctx:             ctx,
		healthStreamUrn: healthStreamUrn,
	}
}

// Execute executes the request
//
//	@return SubStreamList
func (a *HealthSynchronizationAPIService) GetHealthSynchronizationSubStreamOverviewExecute(r ApiGetHealthSynchronizationSubStreamOverviewRequest) (*SubStreamList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubStreamList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthSynchronizationAPIService.GetHealthSynchronizationSubStreamOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/synchronization/health/streams/{healthStreamUrn}/substreams"
	localVarPath = strings.Replace(localVarPath, "{"+"healthStreamUrn"+"}", url.PathEscape(parameterToString(r.healthStreamUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidUrn
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HealthStreamNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHealthSynchronizationSubStreamStatusRequest struct {
	ctx                   context.Context
	ApiService            HealthSynchronizationAPI
	healthStreamUrn       string
	healthSyncSubStreamId string
}

func (r ApiGetHealthSynchronizationSubStreamStatusRequest) Execute() (*HealthSubStreamStatus, *http.Response, error) {
	return r.ApiService.GetHealthSynchronizationSubStreamStatusExecute(r)
}

/*
GetHealthSynchronizationSubStreamStatus Get health sync sub-stream status

Status overview of a single health synchronization sub stream

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param healthStreamUrn Urn of the health stream.
	@param healthSyncSubStreamId Health synchronization sub stream id.
	@return ApiGetHealthSynchronizationSubStreamStatusRequest
*/
func (a *HealthSynchronizationAPIService) GetHealthSynchronizationSubStreamStatus(ctx context.Context, healthStreamUrn string, healthSyncSubStreamId string) ApiGetHealthSynchronizationSubStreamStatusRequest {
	return ApiGetHealthSynchronizationSubStreamStatusRequest{
		ApiService:            a,
		ctx:                   ctx,
		healthStreamUrn:       healthStreamUrn,
		healthSyncSubStreamId: healthSyncSubStreamId,
	}
}

// Execute executes the request
//
//	@return HealthSubStreamStatus
func (a *HealthSynchronizationAPIService) GetHealthSynchronizationSubStreamStatusExecute(r ApiGetHealthSynchronizationSubStreamStatusRequest) (*HealthSubStreamStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HealthSubStreamStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthSynchronizationAPIService.GetHealthSynchronizationSubStreamStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/synchronization/health/streams/{healthStreamUrn}/substreams/{healthSyncSubStreamId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"healthStreamUrn"+"}", url.PathEscape(parameterToString(r.healthStreamUrn, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"healthSyncSubStreamId"+"}", url.PathEscape(parameterToString(r.healthSyncSubStreamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidUrn
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HealthSubStreamError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHealthSynchronizationSubStreamTopologyMatchesRequest struct {
	ctx                   context.Context
	ApiService            HealthSynchronizationAPI
	healthStreamUrn       string
	healthSyncSubStreamId string
}

func (r ApiGetHealthSynchronizationSubStreamTopologyMatchesRequest) Execute() (*TopologyMatchResult, *http.Response, error) {
	return r.ApiService.GetHealthSynchronizationSubStreamTopologyMatchesExecute(r)
}

/*
GetHealthSynchronizationSubStreamTopologyMatches List health sync sub-stream check-states

Overview of check-states matched to topology on the main stream.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param healthStreamUrn Urn of the health stream.
	@param healthSyncSubStreamId Health synchronization sub stream id.
	@return ApiGetHealthSynchronizationSubStreamTopologyMatchesRequest
*/
func (a *HealthSynchronizationAPIService) GetHealthSynchronizationSubStreamTopologyMatches(ctx context.Context, healthStreamUrn string, healthSyncSubStreamId string) ApiGetHealthSynchronizationSubStreamTopologyMatchesRequest {
	return ApiGetHealthSynchronizationSubStreamTopologyMatchesRequest{
		ApiService:            a,
		ctx:                   ctx,
		healthStreamUrn:       healthStreamUrn,
		healthSyncSubStreamId: healthSyncSubStreamId,
	}
}

// Execute executes the request
//
//	@return TopologyMatchResult
func (a *HealthSynchronizationAPIService) GetHealthSynchronizationSubStreamTopologyMatchesExecute(r ApiGetHealthSynchronizationSubStreamTopologyMatchesRequest) (*TopologyMatchResult, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TopologyMatchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthSynchronizationAPIService.GetHealthSynchronizationSubStreamTopologyMatches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/synchronization/health/streams/{healthStreamUrn}/substreams/{healthSyncSubStreamId}/topologyMatches"
	localVarPath = strings.Replace(localVarPath, "{"+"healthStreamUrn"+"}", url.PathEscape(parameterToString(r.healthStreamUrn, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"healthSyncSubStreamId"+"}", url.PathEscape(parameterToString(r.healthSyncSubStreamId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidUrn
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HealthSubStreamError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostHealthSynchronizationStreamClearErrorsRequest struct {
	ctx             context.Context
	ApiService      HealthSynchronizationAPI
	healthStreamUrn string
}

func (r ApiPostHealthSynchronizationStreamClearErrorsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostHealthSynchronizationStreamClearErrorsExecute(r)
}

/*
PostHealthSynchronizationStreamClearErrors Clear health sync stream errors

Clear all errors for a stream and its sub-streams.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param healthStreamUrn Urn of the health stream.
	@return ApiPostHealthSynchronizationStreamClearErrorsRequest
*/
func (a *HealthSynchronizationAPIService) PostHealthSynchronizationStreamClearErrors(ctx context.Context, healthStreamUrn string) ApiPostHealthSynchronizationStreamClearErrorsRequest {
	return ApiPostHealthSynchronizationStreamClearErrorsRequest{
		ApiService:      a,
		ctx:             ctx,
		healthStreamUrn: healthStreamUrn,
	}
}

// Execute executes the request
func (a *HealthSynchronizationAPIService) PostHealthSynchronizationStreamClearErrorsExecute(r ApiPostHealthSynchronizationStreamClearErrorsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthSynchronizationAPIService.PostHealthSynchronizationStreamClearErrors")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/synchronization/health/streams/{healthStreamUrn}/clearErrors"
	localVarPath = strings.Replace(localVarPath, "{"+"healthStreamUrn"+"}", url.PathEscape(parameterToString(r.healthStreamUrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Key"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ServiceBearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-ServiceBearer"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvalidUrn
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v HealthStreamNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ---------------------------------------------
// ------------------ MOCKS --------------------
// ---------------------------------------------

type HealthSynchronizationAPIMock struct {
	DeleteHealthSynchronizationStreamCalls                   *[]DeleteHealthSynchronizationStreamCall
	DeleteHealthSynchronizationStreamResponse                DeleteHealthSynchronizationStreamMockResponse
	GetHealthSynchronizationStreamStatusCalls                *[]GetHealthSynchronizationStreamStatusCall
	GetHealthSynchronizationStreamStatusResponse             GetHealthSynchronizationStreamStatusMockResponse
	GetHealthSynchronizationStreamTopologyMatchesCalls       *[]GetHealthSynchronizationStreamTopologyMatchesCall
	GetHealthSynchronizationStreamTopologyMatchesResponse    GetHealthSynchronizationStreamTopologyMatchesMockResponse
	GetHealthSynchronizationStreamsOverviewCalls             *[]GetHealthSynchronizationStreamsOverviewCall
	GetHealthSynchronizationStreamsOverviewResponse          GetHealthSynchronizationStreamsOverviewMockResponse
	GetHealthSynchronizationSubStreamOverviewCalls           *[]GetHealthSynchronizationSubStreamOverviewCall
	GetHealthSynchronizationSubStreamOverviewResponse        GetHealthSynchronizationSubStreamOverviewMockResponse
	GetHealthSynchronizationSubStreamStatusCalls             *[]GetHealthSynchronizationSubStreamStatusCall
	GetHealthSynchronizationSubStreamStatusResponse          GetHealthSynchronizationSubStreamStatusMockResponse
	GetHealthSynchronizationSubStreamTopologyMatchesCalls    *[]GetHealthSynchronizationSubStreamTopologyMatchesCall
	GetHealthSynchronizationSubStreamTopologyMatchesResponse GetHealthSynchronizationSubStreamTopologyMatchesMockResponse
	PostHealthSynchronizationStreamClearErrorsCalls          *[]PostHealthSynchronizationStreamClearErrorsCall
	PostHealthSynchronizationStreamClearErrorsResponse       PostHealthSynchronizationStreamClearErrorsMockResponse
}

func NewHealthSynchronizationAPIMock() HealthSynchronizationAPIMock {
	xDeleteHealthSynchronizationStreamCalls := make([]DeleteHealthSynchronizationStreamCall, 0)
	xGetHealthSynchronizationStreamStatusCalls := make([]GetHealthSynchronizationStreamStatusCall, 0)
	xGetHealthSynchronizationStreamTopologyMatchesCalls := make([]GetHealthSynchronizationStreamTopologyMatchesCall, 0)
	xGetHealthSynchronizationStreamsOverviewCalls := make([]GetHealthSynchronizationStreamsOverviewCall, 0)
	xGetHealthSynchronizationSubStreamOverviewCalls := make([]GetHealthSynchronizationSubStreamOverviewCall, 0)
	xGetHealthSynchronizationSubStreamStatusCalls := make([]GetHealthSynchronizationSubStreamStatusCall, 0)
	xGetHealthSynchronizationSubStreamTopologyMatchesCalls := make([]GetHealthSynchronizationSubStreamTopologyMatchesCall, 0)
	xPostHealthSynchronizationStreamClearErrorsCalls := make([]PostHealthSynchronizationStreamClearErrorsCall, 0)
	return HealthSynchronizationAPIMock{
		DeleteHealthSynchronizationStreamCalls:                &xDeleteHealthSynchronizationStreamCalls,
		GetHealthSynchronizationStreamStatusCalls:             &xGetHealthSynchronizationStreamStatusCalls,
		GetHealthSynchronizationStreamTopologyMatchesCalls:    &xGetHealthSynchronizationStreamTopologyMatchesCalls,
		GetHealthSynchronizationStreamsOverviewCalls:          &xGetHealthSynchronizationStreamsOverviewCalls,
		GetHealthSynchronizationSubStreamOverviewCalls:        &xGetHealthSynchronizationSubStreamOverviewCalls,
		GetHealthSynchronizationSubStreamStatusCalls:          &xGetHealthSynchronizationSubStreamStatusCalls,
		GetHealthSynchronizationSubStreamTopologyMatchesCalls: &xGetHealthSynchronizationSubStreamTopologyMatchesCalls,
		PostHealthSynchronizationStreamClearErrorsCalls:       &xPostHealthSynchronizationStreamClearErrorsCalls,
	}
}

type DeleteHealthSynchronizationStreamMockResponse struct {
	Response *http.Response
	Error    error
}

type DeleteHealthSynchronizationStreamCall struct {
	PhealthStreamUrn string
}

func (mock HealthSynchronizationAPIMock) DeleteHealthSynchronizationStream(ctx context.Context, healthStreamUrn string) ApiDeleteHealthSynchronizationStreamRequest {
	return ApiDeleteHealthSynchronizationStreamRequest{
		ApiService:      mock,
		ctx:             ctx,
		healthStreamUrn: healthStreamUrn,
	}
}

func (mock HealthSynchronizationAPIMock) DeleteHealthSynchronizationStreamExecute(r ApiDeleteHealthSynchronizationStreamRequest) (*http.Response, error) {
	p := DeleteHealthSynchronizationStreamCall{
		PhealthStreamUrn: r.healthStreamUrn,
	}
	*mock.DeleteHealthSynchronizationStreamCalls = append(*mock.DeleteHealthSynchronizationStreamCalls, p)
	return mock.DeleteHealthSynchronizationStreamResponse.Response, mock.DeleteHealthSynchronizationStreamResponse.Error
}

type GetHealthSynchronizationStreamStatusMockResponse struct {
	Result   HealthStreamStatus
	Response *http.Response
	Error    error
}

type GetHealthSynchronizationStreamStatusCall struct {
	PhealthStreamUrn string
}

func (mock HealthSynchronizationAPIMock) GetHealthSynchronizationStreamStatus(ctx context.Context, healthStreamUrn string) ApiGetHealthSynchronizationStreamStatusRequest {
	return ApiGetHealthSynchronizationStreamStatusRequest{
		ApiService:      mock,
		ctx:             ctx,
		healthStreamUrn: healthStreamUrn,
	}
}

func (mock HealthSynchronizationAPIMock) GetHealthSynchronizationStreamStatusExecute(r ApiGetHealthSynchronizationStreamStatusRequest) (*HealthStreamStatus, *http.Response, error) {
	p := GetHealthSynchronizationStreamStatusCall{
		PhealthStreamUrn: r.healthStreamUrn,
	}
	*mock.GetHealthSynchronizationStreamStatusCalls = append(*mock.GetHealthSynchronizationStreamStatusCalls, p)
	return &mock.GetHealthSynchronizationStreamStatusResponse.Result, mock.GetHealthSynchronizationStreamStatusResponse.Response, mock.GetHealthSynchronizationStreamStatusResponse.Error
}

type GetHealthSynchronizationStreamTopologyMatchesMockResponse struct {
	Result   TopologyMatchResult
	Response *http.Response
	Error    error
}

type GetHealthSynchronizationStreamTopologyMatchesCall struct {
	PhealthStreamUrn string
}

func (mock HealthSynchronizationAPIMock) GetHealthSynchronizationStreamTopologyMatches(ctx context.Context, healthStreamUrn string) ApiGetHealthSynchronizationStreamTopologyMatchesRequest {
	return ApiGetHealthSynchronizationStreamTopologyMatchesRequest{
		ApiService:      mock,
		ctx:             ctx,
		healthStreamUrn: healthStreamUrn,
	}
}

func (mock HealthSynchronizationAPIMock) GetHealthSynchronizationStreamTopologyMatchesExecute(r ApiGetHealthSynchronizationStreamTopologyMatchesRequest) (*TopologyMatchResult, *http.Response, error) {
	p := GetHealthSynchronizationStreamTopologyMatchesCall{
		PhealthStreamUrn: r.healthStreamUrn,
	}
	*mock.GetHealthSynchronizationStreamTopologyMatchesCalls = append(*mock.GetHealthSynchronizationStreamTopologyMatchesCalls, p)
	return &mock.GetHealthSynchronizationStreamTopologyMatchesResponse.Result, mock.GetHealthSynchronizationStreamTopologyMatchesResponse.Response, mock.GetHealthSynchronizationStreamTopologyMatchesResponse.Error
}

type GetHealthSynchronizationStreamsOverviewMockResponse struct {
	Result   StreamList
	Response *http.Response
	Error    error
}

type GetHealthSynchronizationStreamsOverviewCall struct {
}

func (mock HealthSynchronizationAPIMock) GetHealthSynchronizationStreamsOverview(ctx context.Context) ApiGetHealthSynchronizationStreamsOverviewRequest {
	return ApiGetHealthSynchronizationStreamsOverviewRequest{
		ApiService: mock,
		ctx:        ctx,
	}
}

func (mock HealthSynchronizationAPIMock) GetHealthSynchronizationStreamsOverviewExecute(r ApiGetHealthSynchronizationStreamsOverviewRequest) (*StreamList, *http.Response, error) {
	p := GetHealthSynchronizationStreamsOverviewCall{}
	*mock.GetHealthSynchronizationStreamsOverviewCalls = append(*mock.GetHealthSynchronizationStreamsOverviewCalls, p)
	return &mock.GetHealthSynchronizationStreamsOverviewResponse.Result, mock.GetHealthSynchronizationStreamsOverviewResponse.Response, mock.GetHealthSynchronizationStreamsOverviewResponse.Error
}

type GetHealthSynchronizationSubStreamOverviewMockResponse struct {
	Result   SubStreamList
	Response *http.Response
	Error    error
}

type GetHealthSynchronizationSubStreamOverviewCall struct {
	PhealthStreamUrn string
}

func (mock HealthSynchronizationAPIMock) GetHealthSynchronizationSubStreamOverview(ctx context.Context, healthStreamUrn string) ApiGetHealthSynchronizationSubStreamOverviewRequest {
	return ApiGetHealthSynchronizationSubStreamOverviewRequest{
		ApiService:      mock,
		ctx:             ctx,
		healthStreamUrn: healthStreamUrn,
	}
}

func (mock HealthSynchronizationAPIMock) GetHealthSynchronizationSubStreamOverviewExecute(r ApiGetHealthSynchronizationSubStreamOverviewRequest) (*SubStreamList, *http.Response, error) {
	p := GetHealthSynchronizationSubStreamOverviewCall{
		PhealthStreamUrn: r.healthStreamUrn,
	}
	*mock.GetHealthSynchronizationSubStreamOverviewCalls = append(*mock.GetHealthSynchronizationSubStreamOverviewCalls, p)
	return &mock.GetHealthSynchronizationSubStreamOverviewResponse.Result, mock.GetHealthSynchronizationSubStreamOverviewResponse.Response, mock.GetHealthSynchronizationSubStreamOverviewResponse.Error
}

type GetHealthSynchronizationSubStreamStatusMockResponse struct {
	Result   HealthSubStreamStatus
	Response *http.Response
	Error    error
}

type GetHealthSynchronizationSubStreamStatusCall struct {
	PhealthStreamUrn       string
	PhealthSyncSubStreamId string
}

func (mock HealthSynchronizationAPIMock) GetHealthSynchronizationSubStreamStatus(ctx context.Context, healthStreamUrn string, healthSyncSubStreamId string) ApiGetHealthSynchronizationSubStreamStatusRequest {
	return ApiGetHealthSynchronizationSubStreamStatusRequest{
		ApiService:            mock,
		ctx:                   ctx,
		healthStreamUrn:       healthStreamUrn,
		healthSyncSubStreamId: healthSyncSubStreamId,
	}
}

func (mock HealthSynchronizationAPIMock) GetHealthSynchronizationSubStreamStatusExecute(r ApiGetHealthSynchronizationSubStreamStatusRequest) (*HealthSubStreamStatus, *http.Response, error) {
	p := GetHealthSynchronizationSubStreamStatusCall{
		PhealthStreamUrn:       r.healthStreamUrn,
		PhealthSyncSubStreamId: r.healthSyncSubStreamId,
	}
	*mock.GetHealthSynchronizationSubStreamStatusCalls = append(*mock.GetHealthSynchronizationSubStreamStatusCalls, p)
	return &mock.GetHealthSynchronizationSubStreamStatusResponse.Result, mock.GetHealthSynchronizationSubStreamStatusResponse.Response, mock.GetHealthSynchronizationSubStreamStatusResponse.Error
}

type GetHealthSynchronizationSubStreamTopologyMatchesMockResponse struct {
	Result   TopologyMatchResult
	Response *http.Response
	Error    error
}

type GetHealthSynchronizationSubStreamTopologyMatchesCall struct {
	PhealthStreamUrn       string
	PhealthSyncSubStreamId string
}

func (mock HealthSynchronizationAPIMock) GetHealthSynchronizationSubStreamTopologyMatches(ctx context.Context, healthStreamUrn string, healthSyncSubStreamId string) ApiGetHealthSynchronizationSubStreamTopologyMatchesRequest {
	return ApiGetHealthSynchronizationSubStreamTopologyMatchesRequest{
		ApiService:            mock,
		ctx:                   ctx,
		healthStreamUrn:       healthStreamUrn,
		healthSyncSubStreamId: healthSyncSubStreamId,
	}
}

func (mock HealthSynchronizationAPIMock) GetHealthSynchronizationSubStreamTopologyMatchesExecute(r ApiGetHealthSynchronizationSubStreamTopologyMatchesRequest) (*TopologyMatchResult, *http.Response, error) {
	p := GetHealthSynchronizationSubStreamTopologyMatchesCall{
		PhealthStreamUrn:       r.healthStreamUrn,
		PhealthSyncSubStreamId: r.healthSyncSubStreamId,
	}
	*mock.GetHealthSynchronizationSubStreamTopologyMatchesCalls = append(*mock.GetHealthSynchronizationSubStreamTopologyMatchesCalls, p)
	return &mock.GetHealthSynchronizationSubStreamTopologyMatchesResponse.Result, mock.GetHealthSynchronizationSubStreamTopologyMatchesResponse.Response, mock.GetHealthSynchronizationSubStreamTopologyMatchesResponse.Error
}

type PostHealthSynchronizationStreamClearErrorsMockResponse struct {
	Response *http.Response
	Error    error
}

type PostHealthSynchronizationStreamClearErrorsCall struct {
	PhealthStreamUrn string
}

func (mock HealthSynchronizationAPIMock) PostHealthSynchronizationStreamClearErrors(ctx context.Context, healthStreamUrn string) ApiPostHealthSynchronizationStreamClearErrorsRequest {
	return ApiPostHealthSynchronizationStreamClearErrorsRequest{
		ApiService:      mock,
		ctx:             ctx,
		healthStreamUrn: healthStreamUrn,
	}
}

func (mock HealthSynchronizationAPIMock) PostHealthSynchronizationStreamClearErrorsExecute(r ApiPostHealthSynchronizationStreamClearErrorsRequest) (*http.Response, error) {
	p := PostHealthSynchronizationStreamClearErrorsCall{
		PhealthStreamUrn: r.healthStreamUrn,
	}
	*mock.PostHealthSynchronizationStreamClearErrorsCalls = append(*mock.PostHealthSynchronizationStreamClearErrorsCalls, p)
	return mock.PostHealthSynchronizationStreamClearErrorsResponse.Response, mock.PostHealthSynchronizationStreamClearErrorsResponse.Error
}
