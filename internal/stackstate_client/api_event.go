/*
StackState API

StackState's API specification

API version: 0.0.1
Contact: info@stackstate.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stackstate_client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


type EventApi interface {

	/*
	GetEvent Get single event

	Retrieves a specific event by its identifier.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param eventId The Identifier of an event.
	@return ApiGetEventRequest
	*/
	GetEvent(ctx context.Context, eventId string) ApiGetEventRequest

	// GetEventExecute executes the request
	//  @return TopologyEvent
	GetEventExecute(r ApiGetEventRequest) (*TopologyEvent, *http.Response, error)

	/*
	GetEventSources Get event sources

	Get a list of event sources.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetEventSourcesRequest
	*/
	GetEventSources(ctx context.Context) ApiGetEventSourcesRequest

	// GetEventSourcesExecute executes the request
	//  @return StringItemsWithTotal
	GetEventSourcesExecute(r ApiGetEventSourcesRequest) (*StringItemsWithTotal, *http.Response, error)

	/*
	GetEventTags Get event tags

	Gets a list of tags that exist in a list of events.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetEventTagsRequest
	*/
	GetEventTags(ctx context.Context) ApiGetEventTagsRequest

	// GetEventTagsExecute executes the request
	//  @return StringItemsWithTotal
	GetEventTagsExecute(r ApiGetEventTagsRequest) (*StringItemsWithTotal, *http.Response, error)

	/*
	GetEventTypes Get event types

	Get a list of event types for a certain STQL query.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetEventTypesRequest
	*/
	GetEventTypes(ctx context.Context) ApiGetEventTypesRequest

	// GetEventTypesExecute executes the request
	//  @return StringItemsWithTotal
	GetEventTypesExecute(r ApiGetEventTypesRequest) (*StringItemsWithTotal, *http.Response, error)

	/*
	GetEvents Get events

	Gets you a list of events that exist for topology and time selections.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetEventsRequest
	*/
	GetEvents(ctx context.Context) ApiGetEventsRequest

	// GetEventsExecute executes the request
	//  @return EventItemsWithTotal
	GetEventsExecute(r ApiGetEventsRequest) (*EventItemsWithTotal, *http.Response, error)
}

// EventApiService EventApi service
type EventApiService service

type ApiGetEventRequest struct {
	ctx context.Context
	ApiService EventApi
	eventId string
	startTimestampMs *int32
	endTimestampMs *int32
	playHeadTimestampMs *int32
}

func (r ApiGetEventRequest) StartTimestampMs(startTimestampMs int32) ApiGetEventRequest {
	r.startTimestampMs = &startTimestampMs
	return r
}

func (r ApiGetEventRequest) EndTimestampMs(endTimestampMs int32) ApiGetEventRequest {
	r.endTimestampMs = &endTimestampMs
	return r
}

func (r ApiGetEventRequest) PlayHeadTimestampMs(playHeadTimestampMs int32) ApiGetEventRequest {
	r.playHeadTimestampMs = &playHeadTimestampMs
	return r
}

func (r ApiGetEventRequest) Execute() (*TopologyEvent, *http.Response, error) {
	return r.ApiService.GetEventExecute(r)
}

/*
GetEvent Get single event

Retrieves a specific event by its identifier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param eventId The Identifier of an event.
 @return ApiGetEventRequest
*/
func (a *EventApiService) GetEvent(ctx context.Context, eventId string) ApiGetEventRequest {
	return ApiGetEventRequest{
		ApiService: a,
		ctx: ctx,
		eventId: eventId,
	}
}

// Execute executes the request
//  @return TopologyEvent
func (a *EventApiService) GetEventExecute(r ApiGetEventRequest) (*TopologyEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TopologyEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventApiService.GetEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", url.PathEscape(parameterToString(r.eventId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTimestampMs == nil {
		return localVarReturnValue, nil, reportError("startTimestampMs is required and must be specified")
	}
	if r.endTimestampMs == nil {
		return localVarReturnValue, nil, reportError("endTimestampMs is required and must be specified")
	}

	localVarQueryParams.Add("startTimestampMs", parameterToString(*r.startTimestampMs, ""))
	localVarQueryParams.Add("endTimestampMs", parameterToString(*r.endTimestampMs, ""))
	if r.playHeadTimestampMs != nil {
		localVarQueryParams.Add("playHeadTimestampMs", parameterToString(*r.playHeadTimestampMs, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v EventNotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventSourcesRequest struct {
	ctx context.Context
	ApiService EventApi
	startTimestampMs *int32
	endTimestampMs *int32
	topologyQuery *string
	limit *int32
	rootCauseMode *RootCauseMode
	playHeadTimestampMs *int32
	eventTypes *[]string
	eventCategories *[]EventCategory
	eventSources *[]string
	eventTags *[]string
	match *string
}

func (r ApiGetEventSourcesRequest) StartTimestampMs(startTimestampMs int32) ApiGetEventSourcesRequest {
	r.startTimestampMs = &startTimestampMs
	return r
}

func (r ApiGetEventSourcesRequest) EndTimestampMs(endTimestampMs int32) ApiGetEventSourcesRequest {
	r.endTimestampMs = &endTimestampMs
	return r
}

func (r ApiGetEventSourcesRequest) TopologyQuery(topologyQuery string) ApiGetEventSourcesRequest {
	r.topologyQuery = &topologyQuery
	return r
}

func (r ApiGetEventSourcesRequest) Limit(limit int32) ApiGetEventSourcesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetEventSourcesRequest) RootCauseMode(rootCauseMode RootCauseMode) ApiGetEventSourcesRequest {
	r.rootCauseMode = &rootCauseMode
	return r
}

func (r ApiGetEventSourcesRequest) PlayHeadTimestampMs(playHeadTimestampMs int32) ApiGetEventSourcesRequest {
	r.playHeadTimestampMs = &playHeadTimestampMs
	return r
}

func (r ApiGetEventSourcesRequest) EventTypes(eventTypes []string) ApiGetEventSourcesRequest {
	r.eventTypes = &eventTypes
	return r
}

// The category labels of an event.
func (r ApiGetEventSourcesRequest) EventCategories(eventCategories []EventCategory) ApiGetEventSourcesRequest {
	r.eventCategories = &eventCategories
	return r
}

func (r ApiGetEventSourcesRequest) EventSources(eventSources []string) ApiGetEventSourcesRequest {
	r.eventSources = &eventSources
	return r
}

func (r ApiGetEventSourcesRequest) EventTags(eventTags []string) ApiGetEventSourcesRequest {
	r.eventTags = &eventTags
	return r
}

func (r ApiGetEventSourcesRequest) Match(match string) ApiGetEventSourcesRequest {
	r.match = &match
	return r
}

func (r ApiGetEventSourcesRequest) Execute() (*StringItemsWithTotal, *http.Response, error) {
	return r.ApiService.GetEventSourcesExecute(r)
}

/*
GetEventSources Get event sources

Get a list of event sources.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEventSourcesRequest
*/
func (a *EventApiService) GetEventSources(ctx context.Context) ApiGetEventSourcesRequest {
	return ApiGetEventSourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StringItemsWithTotal
func (a *EventApiService) GetEventSourcesExecute(r ApiGetEventSourcesRequest) (*StringItemsWithTotal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StringItemsWithTotal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventApiService.GetEventSources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventSources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTimestampMs == nil {
		return localVarReturnValue, nil, reportError("startTimestampMs is required and must be specified")
	}
	if r.endTimestampMs == nil {
		return localVarReturnValue, nil, reportError("endTimestampMs is required and must be specified")
	}
	if r.topologyQuery == nil {
		return localVarReturnValue, nil, reportError("topologyQuery is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	localVarQueryParams.Add("startTimestampMs", parameterToString(*r.startTimestampMs, ""))
	localVarQueryParams.Add("endTimestampMs", parameterToString(*r.endTimestampMs, ""))
	localVarQueryParams.Add("topologyQuery", parameterToString(*r.topologyQuery, ""))
	if r.rootCauseMode != nil {
		localVarQueryParams.Add("rootCauseMode", parameterToString(*r.rootCauseMode, ""))
	}
	if r.playHeadTimestampMs != nil {
		localVarQueryParams.Add("playHeadTimestampMs", parameterToString(*r.playHeadTimestampMs, ""))
	}
	if r.eventTypes != nil {
		localVarQueryParams.Add("eventTypes", parameterToString(*r.eventTypes, "pipes"))
	}
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	if r.eventCategories != nil {
		localVarQueryParams.Add("eventCategories", parameterToString(*r.eventCategories, "pipes"))
	}
	if r.eventSources != nil {
		localVarQueryParams.Add("eventSources", parameterToString(*r.eventSources, "pipes"))
	}
	if r.eventTags != nil {
		localVarQueryParams.Add("eventTags", parameterToString(*r.eventTags, "pipes"))
	}
	if r.match != nil {
		localVarQueryParams.Add("match", parameterToString(*r.match, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventTagsRequest struct {
	ctx context.Context
	ApiService EventApi
	startTimestampMs *int32
	endTimestampMs *int32
	topologyQuery *string
	limit *int32
	rootCauseMode *RootCauseMode
	playHeadTimestampMs *int32
	eventTypes *[]string
	eventCategories *[]EventCategory
	eventSources *[]string
	eventTags *[]string
	match *string
}

func (r ApiGetEventTagsRequest) StartTimestampMs(startTimestampMs int32) ApiGetEventTagsRequest {
	r.startTimestampMs = &startTimestampMs
	return r
}

func (r ApiGetEventTagsRequest) EndTimestampMs(endTimestampMs int32) ApiGetEventTagsRequest {
	r.endTimestampMs = &endTimestampMs
	return r
}

func (r ApiGetEventTagsRequest) TopologyQuery(topologyQuery string) ApiGetEventTagsRequest {
	r.topologyQuery = &topologyQuery
	return r
}

func (r ApiGetEventTagsRequest) Limit(limit int32) ApiGetEventTagsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetEventTagsRequest) RootCauseMode(rootCauseMode RootCauseMode) ApiGetEventTagsRequest {
	r.rootCauseMode = &rootCauseMode
	return r
}

func (r ApiGetEventTagsRequest) PlayHeadTimestampMs(playHeadTimestampMs int32) ApiGetEventTagsRequest {
	r.playHeadTimestampMs = &playHeadTimestampMs
	return r
}

func (r ApiGetEventTagsRequest) EventTypes(eventTypes []string) ApiGetEventTagsRequest {
	r.eventTypes = &eventTypes
	return r
}

// The category labels of an event.
func (r ApiGetEventTagsRequest) EventCategories(eventCategories []EventCategory) ApiGetEventTagsRequest {
	r.eventCategories = &eventCategories
	return r
}

func (r ApiGetEventTagsRequest) EventSources(eventSources []string) ApiGetEventTagsRequest {
	r.eventSources = &eventSources
	return r
}

func (r ApiGetEventTagsRequest) EventTags(eventTags []string) ApiGetEventTagsRequest {
	r.eventTags = &eventTags
	return r
}

func (r ApiGetEventTagsRequest) Match(match string) ApiGetEventTagsRequest {
	r.match = &match
	return r
}

func (r ApiGetEventTagsRequest) Execute() (*StringItemsWithTotal, *http.Response, error) {
	return r.ApiService.GetEventTagsExecute(r)
}

/*
GetEventTags Get event tags

Gets a list of tags that exist in a list of events.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEventTagsRequest
*/
func (a *EventApiService) GetEventTags(ctx context.Context) ApiGetEventTagsRequest {
	return ApiGetEventTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StringItemsWithTotal
func (a *EventApiService) GetEventTagsExecute(r ApiGetEventTagsRequest) (*StringItemsWithTotal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StringItemsWithTotal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventApiService.GetEventTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventTags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTimestampMs == nil {
		return localVarReturnValue, nil, reportError("startTimestampMs is required and must be specified")
	}
	if r.endTimestampMs == nil {
		return localVarReturnValue, nil, reportError("endTimestampMs is required and must be specified")
	}
	if r.topologyQuery == nil {
		return localVarReturnValue, nil, reportError("topologyQuery is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	localVarQueryParams.Add("startTimestampMs", parameterToString(*r.startTimestampMs, ""))
	localVarQueryParams.Add("endTimestampMs", parameterToString(*r.endTimestampMs, ""))
	localVarQueryParams.Add("topologyQuery", parameterToString(*r.topologyQuery, ""))
	if r.rootCauseMode != nil {
		localVarQueryParams.Add("rootCauseMode", parameterToString(*r.rootCauseMode, ""))
	}
	if r.playHeadTimestampMs != nil {
		localVarQueryParams.Add("playHeadTimestampMs", parameterToString(*r.playHeadTimestampMs, ""))
	}
	if r.eventTypes != nil {
		localVarQueryParams.Add("eventTypes", parameterToString(*r.eventTypes, "pipes"))
	}
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	if r.eventCategories != nil {
		localVarQueryParams.Add("eventCategories", parameterToString(*r.eventCategories, "pipes"))
	}
	if r.eventSources != nil {
		localVarQueryParams.Add("eventSources", parameterToString(*r.eventSources, "pipes"))
	}
	if r.eventTags != nil {
		localVarQueryParams.Add("eventTags", parameterToString(*r.eventTags, "pipes"))
	}
	if r.match != nil {
		localVarQueryParams.Add("match", parameterToString(*r.match, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventTypesRequest struct {
	ctx context.Context
	ApiService EventApi
	startTimestampMs *int32
	endTimestampMs *int32
	topologyQuery *string
	limit *int32
	rootCauseMode *RootCauseMode
	playHeadTimestampMs *int32
	eventTypes *[]string
	eventCategories *[]EventCategory
	eventSources *[]string
	eventTags *[]string
	match *string
}

func (r ApiGetEventTypesRequest) StartTimestampMs(startTimestampMs int32) ApiGetEventTypesRequest {
	r.startTimestampMs = &startTimestampMs
	return r
}

func (r ApiGetEventTypesRequest) EndTimestampMs(endTimestampMs int32) ApiGetEventTypesRequest {
	r.endTimestampMs = &endTimestampMs
	return r
}

func (r ApiGetEventTypesRequest) TopologyQuery(topologyQuery string) ApiGetEventTypesRequest {
	r.topologyQuery = &topologyQuery
	return r
}

func (r ApiGetEventTypesRequest) Limit(limit int32) ApiGetEventTypesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetEventTypesRequest) RootCauseMode(rootCauseMode RootCauseMode) ApiGetEventTypesRequest {
	r.rootCauseMode = &rootCauseMode
	return r
}

func (r ApiGetEventTypesRequest) PlayHeadTimestampMs(playHeadTimestampMs int32) ApiGetEventTypesRequest {
	r.playHeadTimestampMs = &playHeadTimestampMs
	return r
}

func (r ApiGetEventTypesRequest) EventTypes(eventTypes []string) ApiGetEventTypesRequest {
	r.eventTypes = &eventTypes
	return r
}

// The category labels of an event.
func (r ApiGetEventTypesRequest) EventCategories(eventCategories []EventCategory) ApiGetEventTypesRequest {
	r.eventCategories = &eventCategories
	return r
}

func (r ApiGetEventTypesRequest) EventSources(eventSources []string) ApiGetEventTypesRequest {
	r.eventSources = &eventSources
	return r
}

func (r ApiGetEventTypesRequest) EventTags(eventTags []string) ApiGetEventTypesRequest {
	r.eventTags = &eventTags
	return r
}

func (r ApiGetEventTypesRequest) Match(match string) ApiGetEventTypesRequest {
	r.match = &match
	return r
}

func (r ApiGetEventTypesRequest) Execute() (*StringItemsWithTotal, *http.Response, error) {
	return r.ApiService.GetEventTypesExecute(r)
}

/*
GetEventTypes Get event types

Get a list of event types for a certain STQL query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEventTypesRequest
*/
func (a *EventApiService) GetEventTypes(ctx context.Context) ApiGetEventTypesRequest {
	return ApiGetEventTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StringItemsWithTotal
func (a *EventApiService) GetEventTypesExecute(r ApiGetEventTypesRequest) (*StringItemsWithTotal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StringItemsWithTotal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventApiService.GetEventTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eventTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startTimestampMs == nil {
		return localVarReturnValue, nil, reportError("startTimestampMs is required and must be specified")
	}
	if r.endTimestampMs == nil {
		return localVarReturnValue, nil, reportError("endTimestampMs is required and must be specified")
	}
	if r.topologyQuery == nil {
		return localVarReturnValue, nil, reportError("topologyQuery is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}

	localVarQueryParams.Add("startTimestampMs", parameterToString(*r.startTimestampMs, ""))
	localVarQueryParams.Add("endTimestampMs", parameterToString(*r.endTimestampMs, ""))
	localVarQueryParams.Add("topologyQuery", parameterToString(*r.topologyQuery, ""))
	if r.rootCauseMode != nil {
		localVarQueryParams.Add("rootCauseMode", parameterToString(*r.rootCauseMode, ""))
	}
	if r.playHeadTimestampMs != nil {
		localVarQueryParams.Add("playHeadTimestampMs", parameterToString(*r.playHeadTimestampMs, ""))
	}
	if r.eventTypes != nil {
		localVarQueryParams.Add("eventTypes", parameterToString(*r.eventTypes, "pipes"))
	}
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	if r.eventCategories != nil {
		localVarQueryParams.Add("eventCategories", parameterToString(*r.eventCategories, "pipes"))
	}
	if r.eventSources != nil {
		localVarQueryParams.Add("eventSources", parameterToString(*r.eventSources, "pipes"))
	}
	if r.eventTags != nil {
		localVarQueryParams.Add("eventTags", parameterToString(*r.eventTags, "pipes"))
	}
	if r.match != nil {
		localVarQueryParams.Add("match", parameterToString(*r.match, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventsRequest struct {
	ctx context.Context
	ApiService EventApi
	eventListRequest *EventListRequest
}

func (r ApiGetEventsRequest) EventListRequest(eventListRequest EventListRequest) ApiGetEventsRequest {
	r.eventListRequest = &eventListRequest
	return r
}

func (r ApiGetEventsRequest) Execute() (*EventItemsWithTotal, *http.Response, error) {
	return r.ApiService.GetEventsExecute(r)
}

/*
GetEvents Get events

Gets you a list of events that exist for topology and time selections.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEventsRequest
*/
func (a *EventApiService) GetEvents(ctx context.Context) ApiGetEventsRequest {
	return ApiGetEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EventItemsWithTotal
func (a *EventApiService) GetEventsExecute(r ApiGetEventsRequest) (*EventItemsWithTotal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EventItemsWithTotal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventApiService.GetEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.eventListRequest == nil {
		return localVarReturnValue, nil, reportError("eventListRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.eventListRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-API-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v RequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GenericErrorsResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}


// ---------------------------------------------
// ------------------ MOCKS --------------------
// ---------------------------------------------


type EventApiMock struct {
	GetEventCalls *[]GetEventCall
	GetEventResponse GetEventMockResponse
	GetEventSourcesCalls *[]GetEventSourcesCall
	GetEventSourcesResponse GetEventSourcesMockResponse
	GetEventTagsCalls *[]GetEventTagsCall
	GetEventTagsResponse GetEventTagsMockResponse
	GetEventTypesCalls *[]GetEventTypesCall
	GetEventTypesResponse GetEventTypesMockResponse
	GetEventsCalls *[]GetEventsCall
	GetEventsResponse GetEventsMockResponse
}	

func NewEventApiMock() EventApiMock {
	xGetEventCalls := make([]GetEventCall, 0)
	xGetEventSourcesCalls := make([]GetEventSourcesCall, 0)
	xGetEventTagsCalls := make([]GetEventTagsCall, 0)
	xGetEventTypesCalls := make([]GetEventTypesCall, 0)
	xGetEventsCalls := make([]GetEventsCall, 0)
	return EventApiMock {
		GetEventCalls: &xGetEventCalls,
		GetEventSourcesCalls: &xGetEventSourcesCalls,
		GetEventTagsCalls: &xGetEventTagsCalls,
		GetEventTypesCalls: &xGetEventTypesCalls,
		GetEventsCalls: &xGetEventsCalls,
	}
}

type GetEventMockResponse struct {
	Result TopologyEvent
	Response *http.Response
	Error error
}

type GetEventCall struct {
	PeventId string
	PstartTimestampMs *int32
	PendTimestampMs *int32
	PplayHeadTimestampMs *int32
}


func (mock EventApiMock) GetEvent(ctx context.Context, eventId string) ApiGetEventRequest {
	return ApiGetEventRequest{
		ApiService: mock,
		ctx: ctx,
		eventId: eventId,
	}
}

func (mock EventApiMock) GetEventExecute(r ApiGetEventRequest) (*TopologyEvent, *http.Response, error) {
	p := GetEventCall {
			PeventId: r.eventId,
			PstartTimestampMs: r.startTimestampMs,
			PendTimestampMs: r.endTimestampMs,
			PplayHeadTimestampMs: r.playHeadTimestampMs,
	}
	*mock.GetEventCalls = append(*mock.GetEventCalls, p)
	return &mock.GetEventResponse.Result, mock.GetEventResponse.Response, mock.GetEventResponse.Error
}

type GetEventSourcesMockResponse struct {
	Result StringItemsWithTotal
	Response *http.Response
	Error error
}

type GetEventSourcesCall struct {
	PstartTimestampMs *int32
	PendTimestampMs *int32
	PtopologyQuery *string
	Plimit *int32
	ProotCauseMode *RootCauseMode
	PplayHeadTimestampMs *int32
	PeventTypes *[]string
	PeventCategories *[]EventCategory
	PeventSources *[]string
	PeventTags *[]string
	Pmatch *string
}


func (mock EventApiMock) GetEventSources(ctx context.Context) ApiGetEventSourcesRequest {
	return ApiGetEventSourcesRequest{
		ApiService: mock,
		ctx: ctx,
	}
}

func (mock EventApiMock) GetEventSourcesExecute(r ApiGetEventSourcesRequest) (*StringItemsWithTotal, *http.Response, error) {
	p := GetEventSourcesCall {
			PstartTimestampMs: r.startTimestampMs,
			PendTimestampMs: r.endTimestampMs,
			PtopologyQuery: r.topologyQuery,
			Plimit: r.limit,
			ProotCauseMode: r.rootCauseMode,
			PplayHeadTimestampMs: r.playHeadTimestampMs,
			PeventTypes: r.eventTypes,
			PeventCategories: r.eventCategories,
			PeventSources: r.eventSources,
			PeventTags: r.eventTags,
			Pmatch: r.match,
	}
	*mock.GetEventSourcesCalls = append(*mock.GetEventSourcesCalls, p)
	return &mock.GetEventSourcesResponse.Result, mock.GetEventSourcesResponse.Response, mock.GetEventSourcesResponse.Error
}

type GetEventTagsMockResponse struct {
	Result StringItemsWithTotal
	Response *http.Response
	Error error
}

type GetEventTagsCall struct {
	PstartTimestampMs *int32
	PendTimestampMs *int32
	PtopologyQuery *string
	Plimit *int32
	ProotCauseMode *RootCauseMode
	PplayHeadTimestampMs *int32
	PeventTypes *[]string
	PeventCategories *[]EventCategory
	PeventSources *[]string
	PeventTags *[]string
	Pmatch *string
}


func (mock EventApiMock) GetEventTags(ctx context.Context) ApiGetEventTagsRequest {
	return ApiGetEventTagsRequest{
		ApiService: mock,
		ctx: ctx,
	}
}

func (mock EventApiMock) GetEventTagsExecute(r ApiGetEventTagsRequest) (*StringItemsWithTotal, *http.Response, error) {
	p := GetEventTagsCall {
			PstartTimestampMs: r.startTimestampMs,
			PendTimestampMs: r.endTimestampMs,
			PtopologyQuery: r.topologyQuery,
			Plimit: r.limit,
			ProotCauseMode: r.rootCauseMode,
			PplayHeadTimestampMs: r.playHeadTimestampMs,
			PeventTypes: r.eventTypes,
			PeventCategories: r.eventCategories,
			PeventSources: r.eventSources,
			PeventTags: r.eventTags,
			Pmatch: r.match,
	}
	*mock.GetEventTagsCalls = append(*mock.GetEventTagsCalls, p)
	return &mock.GetEventTagsResponse.Result, mock.GetEventTagsResponse.Response, mock.GetEventTagsResponse.Error
}

type GetEventTypesMockResponse struct {
	Result StringItemsWithTotal
	Response *http.Response
	Error error
}

type GetEventTypesCall struct {
	PstartTimestampMs *int32
	PendTimestampMs *int32
	PtopologyQuery *string
	Plimit *int32
	ProotCauseMode *RootCauseMode
	PplayHeadTimestampMs *int32
	PeventTypes *[]string
	PeventCategories *[]EventCategory
	PeventSources *[]string
	PeventTags *[]string
	Pmatch *string
}


func (mock EventApiMock) GetEventTypes(ctx context.Context) ApiGetEventTypesRequest {
	return ApiGetEventTypesRequest{
		ApiService: mock,
		ctx: ctx,
	}
}

func (mock EventApiMock) GetEventTypesExecute(r ApiGetEventTypesRequest) (*StringItemsWithTotal, *http.Response, error) {
	p := GetEventTypesCall {
			PstartTimestampMs: r.startTimestampMs,
			PendTimestampMs: r.endTimestampMs,
			PtopologyQuery: r.topologyQuery,
			Plimit: r.limit,
			ProotCauseMode: r.rootCauseMode,
			PplayHeadTimestampMs: r.playHeadTimestampMs,
			PeventTypes: r.eventTypes,
			PeventCategories: r.eventCategories,
			PeventSources: r.eventSources,
			PeventTags: r.eventTags,
			Pmatch: r.match,
	}
	*mock.GetEventTypesCalls = append(*mock.GetEventTypesCalls, p)
	return &mock.GetEventTypesResponse.Result, mock.GetEventTypesResponse.Response, mock.GetEventTypesResponse.Error
}

type GetEventsMockResponse struct {
	Result EventItemsWithTotal
	Response *http.Response
	Error error
}

type GetEventsCall struct {
	PeventListRequest *EventListRequest
}


func (mock EventApiMock) GetEvents(ctx context.Context) ApiGetEventsRequest {
	return ApiGetEventsRequest{
		ApiService: mock,
		ctx: ctx,
	}
}

func (mock EventApiMock) GetEventsExecute(r ApiGetEventsRequest) (*EventItemsWithTotal, *http.Response, error) {
	p := GetEventsCall {
			PeventListRequest: r.eventListRequest,
	}
	*mock.GetEventsCalls = append(*mock.GetEventsCalls, p)
	return &mock.GetEventsResponse.Result, mock.GetEventsResponse.Response, mock.GetEventsResponse.Error
}


